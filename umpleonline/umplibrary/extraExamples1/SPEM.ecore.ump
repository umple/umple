/************
This file is an Umple translation of a model
of SPEM version 0.1 found at the following URL

date : 2005/08/10

Domain : Software Process

Description : This metamodel describes SPEM (Software Process Engineering Metamodel) which is is a meta-model for defining processes and their components. A tool based on SPEM would be a tool for process authoring and customizing. The actual enactment of processes - that is, planning and executing a project using a process described with SPEM, is not in the scope of this model. In the chapters so far, SPEM has been directly defined as a meta-model. SPEM can be used by directly instantiating this stand-alone meta-model. But SPEM is also defined as a UML Profile. SPEM is dedicated to software processes modeling. Many features of the UML provide the necessary basis for modeling processes, and many other UML features provide useful additional modeling capacities. Being a UML profile, SPEM both defines modeling capacities dedicated to the software process domain, and gains the benefit of the expressiveness of UML. For example, Use Case modeling, which is sometimes used for modeling processes, is not defined as a specific SPEM facility, but can be inherited from UML. Alignment with various process modeling languages is another advantage of using UML Profiles. The SPEM profile uses extensively the UML Activity Diagram model to give more detail to the work decomposition that is represented in the stand-alone meta-model by the WorkDefinition::subWork association. It is expected that the various kinds of process modeling techniques (Business Process Modeling, Workflow, etc.) will be aligned with UML at some time. SPEM will naturally benefit from this convergence, and from any other convergence and improvements that will occur with UML.

Title: Software Process Engineering

Authors : Hugo Bruneliere (hugo.bruneliere <at> gmail.com), Pierrick Guyard (pierrick.guyard <at> gmail.com)
*************/
namespace PrimitiveTypes;

class Boolean
{
}

namespace SPEM;

class ArtifactUsageName
{
	Boolean isInput;
	Boolean isOutput;
	Boolean hasWorkPerArtifact;
	* artifactUsageNames -- 1..* ArtifactKind artifactKind;
	* artifactUsageNames -- 1..* WorkDefinition workDefinition;
}

class ProcessDefinitionElement
{
	1..* processDefinitionElements -- * Guidance guidances;
	* processDefinitionElements -- * ProcessComponent processComponents;
}

class Guidance
{
	isA ProcessDefinitionElement;
}

class ArtifactKind
{
	isA ProcessDefinitionElement;
	* artifactKinds -- * RoleKind responsible;
}

class WorkItem
{
	isA ProcessDefinitionElement;
}

class RoleKind
{
	isA ProcessDefinitionElement;
}

class Condition
{
	isA ProcessDefinitionElement;
}

class ProcessComponent
{
	isA ProcessDefinitionElement;
}

class Goal
{
	isA Condition;
	* goal -- 1..* WorkDefinition workDefinition;
}

class Precondition
{
	isA Condition;
	* precondition -- 1..* WorkDefinition workDefinition;
}

class WorkDefinition
{
	isA WorkItem;
}

class ActivityKind
{
	isA WorkDefinition;
	0..1 -> 1..* RoleKind performer;
	0..1 -> * RoleKind assistant;
}

class Iteration
{
	isA WorkDefinition;
}

class Phase
{
	isA WorkDefinition;
}

class Lifecycle
{
	isA WorkDefinition;
}