Basic State Machines
State Machines
noreferences

@@description

<p>      
A state machine has a fixed set of of values (called states) The state machine transitions from state to state by the occurrence of events. State machines are very useful
for quickly defining a program's behaviour.
</p>

<p>
In Umple, a state machine is modeled as a special type of attribute. In any class, simply specify the state machine name, and follow the name by a block starting with '{' and ending with '}'. This indicates to Umple that you are defining a state machine, and not an ordinary attribute.
</p>

<p>
Within the block, you list the names of the various states. Each state is followed by a block, again indicated using '{' to start and '} to end. This block defines the details of a state.
<p/>

<p>
Details of each state can include:
<ul>
<li><b>Transitions</b>. A transition has an <b>event</b> name, the symbol '->', and then the name of a destination state. The event name will become the name of a generated method. To trigger the transition, you simply call the method. When the event occurs while the state machine is in the origin state, the state machine will change to the destination state.<br/> Transitions can also have:&nbsp;<br/>
  <ul>
  <li><b>transition actions</b>, specified as '/' followed by a block of code to execute.
  <li><b>guards</b>, which are boolean expressions in square brackets. Even if the event occurs, the transition only takes place if the guard evaluates to true.
  </ul>
<li>Entry actions, exit actions and do activities. <a href="StateMachineActionsandDoActivities.html">See the separate manual page</a>.
<li>Nested states. <a href="NestedStateMachines.html">See the separate manual page.</a> You can nest state machines to arbitrary levels of depth.
</ul>
</p>

<p>The following diagram shows a garage door state machine as a UML diagram. The Umple code for this is at the bottom of this page. Note that UmpleOnline currently cannot draw state machines.

<img src="examples/GarageStateMachine.png" alt="state machne for garage door"/>


&nbsp;<br/>

@@syntax

inlineStateMachine : [name] { ( [[comment]] | [[state]] )* }<br/>&nbsp;<br/>

state : [stateName] { ( [[comment]] | [=changeType:-|*]? [[stateEntity]] )* }<br/>&nbsp;<br/>

stateEntity- : [=-||] | [[transition]] | [[entryOrExitAction]] | [[activity]] | [[state]]<br/>&nbsp;<br/>

transition : [[guard]] [[eventDefinition]] -> [[action]]? [stateName] ; | [[eventDefinition]] [[guard]]? -> [[action]]? [stateName] ; | [[activity]] -> [stateName]<br/>&nbsp;<br/>

eventDefinition- : [[afterEveryEvent]] | [[afterEvent]] | [event]<br/>&nbsp;<br/>


@@example

// This example shows a simple state machine without any actions or guards
//
// In the following, status is a state machine, and acts like an
// attributes, whose value is set by various events.
//
// Open, Closing, Closed, Opening and HalfOpen are the possible
// values, or states, of status.
//
// buttonOrObstacle, reachBottom and reachTop are events. These
// become generated methods that can be called to cause a state
// change.

class GarageDoor
{
   status {
      Open { buttonOrObstacle -> Closing;  }
      Closing {
          buttonOrObstacle -> Opening;
          reachBottom -> Closed;
      }
      Closed { buttonOrObstacle -> Opening; }
      Opening {
          buttonOrObstacle -> HalfOpen;
          reachTop -> Open;
      }
      HalfOpen { buttonOrObstacle -> Opening; }
  }
}

@@endexample


@@example
// This is a more fully-featured state machine for
// a garage door corresponding to the diagram above
class Garage {
  lazy Boolean entranceClear=true;
  GarageDoor { 
    Closed {
      entry/{stopMotor();}  
      entry/{triggerEnergySaveMode();}
      exit/ {triggerNormalEnergyMode();}
      pressButton -> /{turnLightOn();} Opening; 
    }
    Opening {
      entry/{runMotorForward();}
      openingCompleted -> Open;
    }
    Open {
      entry/{stopMotor();}
      // do {wait(60000); turnLightOff();}
      pressButton [getEntranceClear()] -> Closing;
    }
    Closing {
      entry/{runMotorInReverse();}
      closingCompleted -> Closed;
      pressButton -> /{flashLightOn();} Opening; 
    }
  }
  
  boolean runMotorInReverse() {
     System.out.println("Running motor in reverse");
    return true;
  }
  
  boolean flashLightOn() {
     System.out.println("Flashing light on");
    return true;
  }

  boolean turnLightOn() {
     System.out.println("Turning light on");
    return true;
  }
  
   boolean turnLightOff() {
     System.out.println("Turning light off");
    return true;
  }
  
  boolean runMotorForward() {
     System.out.println("Running motor forwards");
    return true;
  }

  boolean triggerEnergySaveMode() {
     System.out.println("Triggering Energy Saving Mode");
    return true;
  }

  boolean stopMotor() {
     System.out.println("Stopping motor");
    return true;
  }

  boolean triggerNormalEnergyMode() {
     System.out.println("Triggering Normal Energy Mode");
         return true;
  }
  
  boolean waitawhile() {
    System.out.println("Waiting");
    return true;
  }
  
  boolean test() {
          System.out.println("Testing");
         return true;
  }
  
}
@@endexample
