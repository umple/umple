namespace weka.filters.unsupervised.instance;

class Randomize
{
  isA UnsupervisedFilter,OptionHandler;
  isA Filter;
 depend java.util.Enumeration;
 depend java.util.Random;
 depend java.util.Vector;
 depend weka.core.Capabilities;
 depend weka.core.Capabilities.Capability;
 depend weka.core.Instance;
 depend weka.core.Instances;
 depend weka.core.Option;
 depend weka.core.OptionHandler;
 depend weka.core.RevisionUtils;
 depend weka.core.Utils;
 depend weka.filters.Filter;
 depend weka.filters.UnsupervisedFilter;
/** 
 * for serialization 
 */
static final long serialVersionUID=8854479785121877582L;

/** 
 * The random number seed 
 */
protected int m_Seed=42;

/** 
 * The current random number generator 
 */
protected Random m_Random;

/** 
 * Returns a string describing this classifier
 * @return a description of the classifier suitable for displaying in theexplorer/experimenter gui
 */
public String globalInfo(){
  return "Randomly shuffles the order of instances passed through it. " + "The random number generator is reset with the seed value whenever " + "a new set of instances is passed in.";
}

/** 
 * Returns an enumeration describing the available options.
 * @return an enumeration of all the available options.
 */
@Override public Enumeration<Option> listOptions(){
  Vector<Option> newVector=new Vector<Option>(1);
  newVector.addElement(new Option("\tSpecify the random number seed (default 42)","S",1,"-S <num>"));
  return newVector.elements();
}

/** 
 * Parses a given list of options. <p/> <!-- options-start --> Valid options are: <p/> <pre> -S &lt;num&gt; Specify the random number seed (default 42) </pre> <!-- options-end -->
 * @param options the list of options as an array of strings
 * @throws Exception if an option is not supported
 */
@Override public void setOptions(String[] options) throws Exception {
  String seedString=Utils.getOption('S',options);
  if (seedString.length() != 0) {
    setRandomSeed(Integer.parseInt(seedString));
  }
 else {
    setRandomSeed(42);
  }
  if (getInputFormat() != null) {
    setInputFormat(getInputFormat());
  }
}

/** 
 * Gets the current settings of the filter.
 * @return an array of strings suitable for passing to setOptions
 */
@Override public String[] getOptions(){
  Vector<String> options=new Vector<String>();
  options.add("-S");
  options.add("" + getRandomSeed());
  return options.toArray(new String[0]);
}

/** 
 * Returns the tip text for this property
 * @return tip text for this property suitable for displaying in theexplorer/experimenter gui
 */
public String randomSeedTipText(){
  return "Seed for the random number generator.";
}

/** 
 * Get the random number generator seed value.
 * @return random number generator seed value.
 */
public int getRandomSeed(){
  return m_Seed;
}

/** 
 * Set the random number generator seed value.
 * @param newRandomSeed value to use as the random number generator seed.
 */
public void setRandomSeed(int newRandomSeed){
  m_Seed=newRandomSeed;
}

/** 
 * Returns the Capabilities of this filter.
 * @return the capabilities of this object
 * @see Capabilities
 */
@Override public Capabilities getCapabilities(){
  Capabilities result=super.getCapabilities();
  result.disableAll();
  result.enableAllAttributes();
  result.enable(Capability.MISSING_VALUES);
  result.enableAllClasses();
  result.enable(Capability.MISSING_CLASS_VALUES);
  result.enable(Capability.NO_CLASS);
  return result;
}

/** 
 * Sets the format of the input instances.
 * @param instanceInfo an Instances object containing the input instancestructure (any instances contained in the object are ignored - only the structure is required).
 * @return true if the outputFormat may be collected immediately
 * @throws Exception if format cannot be processed
 */
@Override public boolean setInputFormat(Instances instanceInfo) throws Exception {
  super.setInputFormat(instanceInfo);
  setOutputFormat(instanceInfo);
  m_Random=new Random(m_Seed);
  return true;
}

/** 
 * Input an instance for filtering. Filter requires all training instances be read before producing output.
 * @param instance the input instance
 * @return true if the filtered instance may now be collected with output().
 * @throws IllegalStateException if no input structure has been defined
 */
@Override public boolean input(Instance instance){
  if (getInputFormat() == null) {
    throw new IllegalStateException("No input instance format defined");
  }
  if (m_NewBatch) {
    resetQueue();
    m_NewBatch=false;
  }
  if (isFirstBatchDone()) {
    push(instance);
    return true;
  }
 else {
    bufferInput(instance);
    return false;
  }
}

/** 
 * Signify that this batch of input to the filter is finished. If the filter requires all instances prior to filtering, output() may now be called to retrieve the filtered instances. Any subsequent instances filtered should be filtered based on setting obtained from the first batch (unless the setInputFormat has been re-assigned or new options have been set). This implementation randomizes all the instances received in the batch.
 * @return true if there are instances pending output
 * @throws IllegalStateException if no input format has been set.
 */
@Override public boolean batchFinished(){
  if (getInputFormat() == null) {
    throw new IllegalStateException("No input instance format defined");
  }
  if (!isFirstBatchDone()) {
    getInputFormat().randomize(m_Random);
  }
  for (int i=0; i < getInputFormat().numInstances(); i++) {
    push(getInputFormat().instance(i));
  }
  flushInput();
  m_NewBatch=true;
  m_FirstBatchDone=true;
  return (numPendingOutput() != 0);
}

/** 
 * Returns the revision string.
 * @return the revision
 */
@Override public String getRevision(){
  return RevisionUtils.extract("$Revision: 10215 $");
}

/** 
 * Main method for testing this class.
 * @param argv should contain arguments to the filter: use -h for help
 */
public static void main(String[] argv){
  runFilter(new Randomize(),argv);
}
}
