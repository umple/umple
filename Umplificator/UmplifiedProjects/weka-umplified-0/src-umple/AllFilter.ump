namespace weka.filters;

class AllFilter
{
  isA Sourcable;
  isA Filter;
 depend weka.core.Capabilities;
 depend weka.core.Capabilities.Capability;
 depend weka.core.Instance;
 depend weka.core.Instances;
 depend weka.core.RevisionUtils;
/** 
 * for serialization 
 */
static final long serialVersionUID=5022109283147503266L;

/** 
 * Returns a string describing this filter
 * @return a description of the filter suitable fordisplaying in the explorer/experimenter gui
 */
public String globalInfo(){
  return "An instance filter that passes all instances through unmodified." + " Primarily for testing purposes.";
}

/** 
 * Returns the Capabilities of this filter.
 * @return            the capabilities of this object
 * @see Capabilities
 */
public Capabilities getCapabilities(){
  Capabilities result=super.getCapabilities();
  result.disableAll();
  result.enableAllAttributes();
  result.enable(Capability.MISSING_VALUES);
  result.enableAllClasses();
  result.enable(Capability.MISSING_CLASS_VALUES);
  result.enable(Capability.NO_CLASS);
  return result;
}

/** 
 * Sets the format of the input instances.
 * @param instanceInfo 	an Instances object containing the input instance structure (any instances contained  in the object are ignored - only the structure  is required).
 * @return true 		if the outputFormat may be collected immediately
 * @throws Exception 		if something goes wrong
 */
public boolean setInputFormat(Instances instanceInfo) throws Exception {
  super.setInputFormat(instanceInfo);
  setOutputFormat(instanceInfo);
  return true;
}

/** 
 * Input an instance for filtering. Ordinarily the instance is processed and made available for output immediately. Some filters require all instances be read before producing output.
 * @param instance the input instance
 * @return true if the filtered instance may now becollected with output().
 * @throws IllegalStateException if no input format has been defined.
 */
public boolean input(Instance instance){
  if (getInputFormat() == null) {
    throw new IllegalStateException("No input instance format defined");
  }
  if (m_NewBatch) {
    resetQueue();
    m_NewBatch=false;
  }
  push((Instance)instance.copy());
  return true;
}

/** 
 * Returns a string that describes the filter as source. The filter will be contained in a class with the given name (there may be auxiliary classes), and will contain two methods with these signatures: <pre><code> // converts one row public static Object[] filter(Object[] i); // converts a full dataset (first dimension is row index) public static Object[][] filter(Object[][] i); </code></pre> where the array <code>i</code> contains elements that are either Double, String, with missing values represented as null. The generated code is public domain and comes with no warranty.
 * @param className   the name that should be given to the source class.
 * @param data	the dataset used for initializing the filter
 * @return            the object source described by a string
 * @throws Exception  if the source can't be computed
 */
public String toSource(String className,Instances data) throws Exception {
  StringBuffer result;
  result=new StringBuffer();
  result.append("class " + className + " {\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * filters a single row\n");
  result.append("   * \n");
  result.append("   * @param i the row to process\n");
  result.append("   * @return the processed row\n");
  result.append("   */\n");
  result.append("  public static Object[] filter(Object[] i) {\n");
  result.append("    return i;\n");
  result.append("  }\n");
  result.append("\n");
  result.append("  /**\n");
  result.append("   * filters multiple rows\n");
  result.append("   * \n");
  result.append("   * @param i the rows to process\n");
  result.append("   * @return the processed rows\n");
  result.append("   */\n");
  result.append("  public static Object[][] filter(Object[][] i) {\n");
  result.append("    return i;\n");
  result.append("  }\n");
  result.append("}\n");
  return result.toString();
}

/** 
 * Returns the revision string.
 * @return		the revision
 */
public String getRevision(){
  return RevisionUtils.extract("$Revision: 8034 $");
}

/** 
 * Main method for testing this class.
 * @param argv should contain arguments to the filter: use -h for help
 */
public static void main(String[] argv){
  runFilter(new AllFilter(),argv);
}
}
