namespace weka.gui.beans;

class RunThread
{
  isA Thread;
 depend java.awt.BasicStroke;
 depend java.awt.BorderLayout;
 depend java.awt.Color;
 depend java.awt.Component;
 depend java.awt.Cursor;
 depend java.awt.Dialog.ModalityType;
 depend java.awt.Dimension;
 depend java.awt.FlowLayout;
 depend java.awt.Font;
 depend java.awt.FontMetrics;
 depend java.awt.Graphics;
 depend java.awt.Graphics2D;
 depend java.awt.GridLayout;
 depend java.awt.Image;
 depend java.awt.Menu;
 depend java.awt.MenuItem;
 depend java.awt.Point;
 depend java.awt.PopupMenu;
 depend java.awt.Rectangle;
 depend java.awt.RenderingHints;
 depend java.awt.Toolkit;
 depend java.awt.event.ActionEvent;
 depend java.awt.event.ActionListener;
 depend java.awt.event.InputEvent;
 depend java.awt.event.KeyAdapter;
 depend java.awt.event.KeyEvent;
 depend java.awt.event.MouseAdapter;
 depend java.awt.event.MouseEvent;
 depend java.awt.event.MouseMotionAdapter;
 depend java.awt.image.BufferedImage;
 depend java.beans.BeanInfo;
 depend java.beans.Beans;
 depend java.beans.Customizer;
 depend java.beans.EventSetDescriptor;
 depend java.beans.IntrospectionException;
 depend java.beans.Introspector;
 depend java.beans.PropertyChangeEvent;
 depend java.beans.PropertyChangeListener;
 depend java.beans.beancontext.BeanContextChild;
 depend java.beans.beancontext.BeanContextSupport;
 depend java.io.BufferedWriter;
 depend java.io.File;
 depend java.io.FileInputStream;
 depend java.io.FileOutputStream;
 depend java.io.FileWriter;
 depend java.io.IOException;
 depend java.io.InputStream;
 depend java.io.InputStreamReader;
 depend java.io.LineNumberReader;
 depend java.io.ObjectInputStream;
 depend java.io.ObjectOutputStream;
 depend java.io.OutputStream;
 depend java.io.OutputStreamWriter;
 depend java.io.Reader;
 depend java.io.Serializable;
 depend java.lang.annotation.Annotation;
 depend java.text.SimpleDateFormat;
 depend java.util.ArrayList;
 depend java.util.Date;
 depend java.util.Enumeration;
 depend java.util.HashMap;
 depend java.util.Hashtable;
 depend java.util.Iterator;
 depend java.util.LinkedHashMap;
 depend java.util.List;
 depend java.util.Map;
 depend java.util.Properties;
 depend java.util.SortedSet;
 depend java.util.Stack;
 depend java.util.StringTokenizer;
 depend java.util.TreeMap;
 depend java.util.TreeSet;
 depend java.util.Vector;
 depend javax.swing.AbstractAction;
 depend javax.swing.AbstractButton;
 depend javax.swing.Action;
 depend javax.swing.BorderFactory;
 depend javax.swing.ButtonGroup;
 depend javax.swing.Icon;
 depend javax.swing.ImageIcon;
 depend javax.swing.JButton;
 depend javax.swing.JCheckBox;
 depend javax.swing.JComponent;
 depend javax.swing.JDialog;
 depend javax.swing.JFileChooser;
 depend javax.swing.JFrame;
 depend javax.swing.JLabel;
 depend javax.swing.JOptionPane;
 depend javax.swing.JPanel;
 depend javax.swing.JScrollPane;
 depend javax.swing.JSplitPane;
 depend javax.swing.JTabbedPane;
 depend javax.swing.JTextArea;
 depend javax.swing.JTextField;
 depend javax.swing.JToggleButton;
 depend javax.swing.JToolBar;
 depend javax.swing.JTree;
 depend javax.swing.JWindow;
 depend javax.swing.KeyStroke;
 depend javax.swing.event.ChangeEvent;
 depend javax.swing.event.ChangeListener;
 depend javax.swing.filechooser.FileFilter;
 depend javax.swing.plaf.basic.BasicButtonUI;
 depend javax.swing.tree.DefaultMutableTreeNode;
 depend javax.swing.tree.DefaultTreeCellRenderer;
 depend javax.swing.tree.DefaultTreeModel;
 depend javax.swing.tree.DefaultTreeSelectionModel;
 depend javax.swing.tree.MutableTreeNode;
 depend javax.swing.tree.TreeNode;
 depend javax.swing.tree.TreePath;
 depend javax.swing.tree.TreeSelectionModel;
 depend weka.core.Attribute;
 depend weka.core.Copyright;
 depend weka.core.Environment;
 depend weka.core.EnvironmentHandler;
 depend weka.core.Instances;
 depend weka.core.Memory;
 depend weka.core.SerializedObject;
 depend weka.core.Utils;
 depend weka.core.WekaEnumeration;
 depend weka.core.WekaPackageManager;
 depend weka.core.converters.FileSourcedConverter;
 depend weka.core.xml.KOML;
 depend weka.core.xml.XStream;
 depend weka.gui.AttributeSelectionPanel;
 depend weka.gui.ExtensionFileFilter;
 depend weka.gui.GenericObjectEditor;
 depend weka.gui.GenericPropertiesCreator;
 depend weka.gui.HierarchyPropertyParser;
 depend weka.gui.LookAndFeel;
 depend weka.gui.beans.xml.XMLBeans;
 depend weka.gui.visualize.PrintablePanel;
/** 
 * for serialization 
 */
private static final long serialVersionUID=-7064906770289728431L;

/** 
 * Map of all plugin perspectives 
 */
protected Map<String,String> m_pluginPerspectiveLookup=new HashMap<String,String>();

/** 
 * Those perspectives that have been instantiated 
 */
protected Map<String,KFPerspective> m_perspectiveCache=new HashMap<String,KFPerspective>();

/** 
 * Holds the details needed to construct button bars for various supported classes of weka algorithms/tools
 */
private static Vector<Vector<?>> TOOLBARS=new Vector<Vector<?>>();

/** 
 * Added ID to avoid warning. 
 */
private static final long serialVersionUID=-4488876734500244945L;

/** 
 */
private static final long serialVersionUID=-9064396835384819887L;

protected boolean m_isVisible;

/** 
 */
private static final long serialVersionUID=6940101211275068260L;

protected boolean m_filterIsActive;

/** 
 * For serialization
 */
private static final long serialVersionUID=6197221540272931626L;

/** 
 * fully qualified bean name 
 */
protected String m_fullyQualifiedCompName="";

/** 
 * the label (usually derived from the qualified name or wrapped algorithm) for the leaf
 */
protected String m_leafLabel="";

/** 
 * the fully qualified wrapped weka algorithm name 
 */
protected String m_wekaAlgoName="";

/** 
 * icon to display at the leaf (scaled appropriately) 
 */
protected transient Icon m_scaledIcon=null;

/** 
 * XML serialized MetaBean (if this is a user component) 
 */
protected Vector<Object> m_metaBean=null;

/** 
 * true if this is a MetaBean (user component) 
 */
protected boolean m_isMeta=false;

/** 
 * tool tip text to display 
 */
protected String m_toolTipText=null;

/** 
 * for serialization 
 */
private static final long serialVersionUID=-146377012429662757L;

/** 
 */
private static final long serialVersionUID=7666381888012259527L;

/** 
 * Holds the tabs of the perspective 
 */
protected JTabbedPane m_flowTabs=new JTabbedPane();

/** 
 * List of layouts - one for each tab 
 */
protected List<BeanLayout> m_beanLayouts=new ArrayList<BeanLayout>();

/** 
 * List of zoom settings - one for each tab 
 */
protected List<Integer> m_zoomSettings=new ArrayList<Integer>();

/** 
 * List of log panels - one for each tab 
 */
protected List<KFLogPanel> m_logPanels=new ArrayList<KFLogPanel>();

/** 
 * List of environment variable settings - one for each tab 
 */
protected List<Environment> m_environmentSettings=new ArrayList<Environment>();

/** 
 * List of flow file paths - one for each tab 
 */
protected List<File> m_filePaths=new ArrayList<File>();

/** 
 * Keeps track of which tabs have been edited but not saved 
 */
protected List<Boolean> m_editedList=new ArrayList<Boolean>();

/** 
 * Keeps track of which tabs have flows that are executing 
 */
protected List<Boolean> m_executingList=new ArrayList<Boolean>();

/** 
 * Keeps track of the threads used for execution 
 */
protected List<RunThread> m_executionThreads=new ArrayList<RunThread>();

/** 
 * Keeps track of any highlighted beans on the canvas for a tab 
 */
protected List<Vector<Object>> m_selectedBeans=new ArrayList<Vector<Object>>();

/** 
 * Keeps track of the undo buffers for each tab 
 */
protected List<Stack<File>> m_undoBufferList=new ArrayList<Stack<File>>();

protected Map<String,DefaultMutableTreeNode> m_nodeTextIndex=new LinkedHashMap<String,DefaultMutableTreeNode>();

/** 
 */
private static final long serialVersionUID=4762166880144590384L;

/** 
 */
private static final long serialVersionUID=5182044142154404706L;

/** 
 */
private static final long serialVersionUID=-5106547209818805444L;

/** 
 */
private static final long serialVersionUID=8002244400334262966L;

/** 
 */
private static final long serialVersionUID=-8086754050844707658L;

/** 
 */
private static final long serialVersionUID=1348383794897269484L;

/** 
 */
private static final long serialVersionUID=-1120096894263455918L;

/** 
 */
private static final long serialVersionUID=-5752742619180091435L;

/** 
 */
private static final long serialVersionUID=-4955878102742013040L;

/** 
 */
private static final long serialVersionUID=4621688037874199553L;

/** 
 */
private static final long serialVersionUID=117010390180468707L;

/** 
 */
private static final long serialVersionUID=5935121051028929455L;

/** 
 */
private static final long serialVersionUID=7820689847829357449L;

/** 
 */
private static final long serialVersionUID=2991743619130024875L;

/** 
 */
private static final long serialVersionUID=7248362305594881263L;

/** 
 */
private static final long serialVersionUID=3301809940717051925L;

/** 
 */
private static final long serialVersionUID=5394622655137498495L;

/** 
 */
private static final long serialVersionUID=6628795889296634120L;

/** 
 */
private static final long serialVersionUID=-6844232025394346426L;

private final JTabbedPane m_enclosingPane;

private JLabel m_tabLabel;

private TabButton m_tabButton;

/** 
 */
private static final long serialVersionUID=8515052190461050324L;

/** 
 */
private static final long serialVersionUID=-4915800749132175968L;

FontMetrics m_fontM;

protected static final int NONE=0;

protected static final int MOVING=1;

protected static final int CONNECTING=2;

protected static final int ADDING=3;

protected static final int SELECTING=4;

protected static final int PASTING=5;

private int m_mode=NONE;

/** 
 * the extension for the user components, when serialized to XML 
 */
protected final static String USERCOMPONENTS_XML_EXTENSION=".xml";

/** 
 * Holds the selected toolbar bean
 */
private Object m_toolBarBean;

/** 
 * Snap-to-grid spacing 
 */
private final int m_gridSpacing=40;

/** 
 * Number of untitled tabs so far 
 */
protected int m_untitledCount=1;

/** 
 * The layout area
 */
private BeanLayout m_beanLayout=null;

private int m_layoutZoom=100;

/** 
 * Whether to allow more than one tab or not 
 */
private boolean m_allowMultipleTabs=true;

private final Vector<Object> m_userComponents=new Vector<Object>();

private boolean m_firstUserComponentOpp=true;

protected JButton m_pointerB;

protected JButton m_saveB;

protected JButton m_saveBB;

protected JButton m_loadB;

protected JButton m_stopB;

protected JButton m_playB;

protected JButton m_playBB;

protected JButton m_helpB;

protected JButton m_newB;

protected JButton m_togglePerspectivesB;

protected JButton m_templatesB;

protected JButton m_groupB;

protected JButton m_cutB;

protected JButton m_copyB;

protected JButton m_pasteB;

protected JButton m_deleteB;

protected JButton m_noteB;

protected JButton m_selectAllB;

protected JButton m_undoB;

protected JButton m_zoomInB;

protected JButton m_zoomOutB;

protected JToggleButton m_snapToGridB;

/** 
 * Reference to bean being manipulated
 */
private BeanInstance m_editElement;

/** 
 * Event set descriptor for the bean being manipulated
 */
private EventSetDescriptor m_sourceEventSetDescriptor;

/** 
 * Used to record screen coordinates during move, select and connect operations
 */
private int m_oldX, m_oldY;

private int m_startX, m_startY;

/** 
 * The file chooser for selecting layout files 
 */
protected JFileChooser m_FileChooser=new JFileChooser(new File(System.getProperty("user.dir")));

/** 
 */
private static final long serialVersionUID=-2224509243343105276L;

protected KFLogPanel m_logPanel=null;

/** 
 * Toolbar to hold the perspective buttons 
 */
protected JToolBar m_perspectiveToolBar=new JToolBar(JToolBar.HORIZONTAL);

/** 
 * Panel to hold the perspectives toolbar and config button 
 */
protected JPanel m_configAndPerspectives;

/** 
 * Whether the perspectives toolbar is visible at present (will never be visible if there are no plugin perspectives installed)
 */
protected boolean m_configAndPerspectivesVisible=true;

/** 
 * Button group to manage all perspective toggle buttons
 */
private final ButtonGroup m_perspectiveGroup=new ButtonGroup();

/** 
 * Component that holds the currently visible perspective 
 */
protected JPanel m_perspectiveHolder;

/** 
 * Holds the list of currently loaded perspectives. Element at 0 is always the main KF data mining flow perspective
 */
protected List<KFPerspective> m_perspectives=new ArrayList<KFPerspective>();

/** 
 * Thread for loading data for perspectives 
 */
protected Thread m_perspectiveDataLoadThread=null;

protected AttributeSelectionPanel m_perspectiveConfigurer;

/** 
 * Shortcut to the main perspective 
 */
protected MainKFPerspective m_mainKFPerspective;

protected BeanContextSupport m_bcSupport=new BeanContextSupport();

/** 
 * the extension for the serialized setups (Java serialization) 
 */
public final static String FILE_EXTENSION=".kf";

/** 
 * the extension for the serialized setups (Java serialization) 
 */
public final static String FILE_EXTENSION_XML=".kfml";

/** 
 * A filter to ensure only KnowledgeFlow files in binary format get shown in the chooser
 */
protected FileFilter m_KfFilter=new ExtensionFileFilter(FILE_EXTENSION,"Binary KnowledgeFlow configuration files (*" + FILE_EXTENSION + ")");

/** 
 * A filter to ensure only KnowledgeFlow files in KOML format get shown in the chooser
 */
protected FileFilter m_KOMLFilter=new ExtensionFileFilter(KOML.FILE_EXTENSION + "kf","XML KnowledgeFlow configuration files (*" + KOML.FILE_EXTENSION + "kf)");

/** 
 * A filter to ensure only KnowledgeFlow files in XStream format get shown in the chooser
 */
protected FileFilter m_XStreamFilter=new ExtensionFileFilter(XStream.FILE_EXTENSION + "kf","XML KnowledgeFlow configuration files (*" + XStream.FILE_EXTENSION + "kf)");

/** 
 * A filter to ensure only KnowledgeFlow layout files in XML format get shown in the chooser
 */
protected FileFilter m_XMLFilter=new ExtensionFileFilter(FILE_EXTENSION_XML,"XML KnowledgeFlow layout files (*" + FILE_EXTENSION_XML + ")");

/** 
 * the scrollbar increment of the layout scrollpane 
 */
protected int m_ScrollBarIncrementLayout=20;

/** 
 * the scrollbar increment of the components scrollpane 
 */
protected int m_ScrollBarIncrementComponents=50;

/** 
 * the flow layout width 
 */
protected int m_FlowWidth=2560;

/** 
 * the flow layout height 
 */
protected int m_FlowHeight=1440;

/** 
 * the preferred file extension 
 */
protected String m_PreferredExtension=FILE_EXTENSION;

/** 
 * whether to store the user components in XML or in binary format 
 */
protected boolean m_UserComponentsInXML=false;

/** 
 * Environment variables for the current flow 
 */
protected Environment m_flowEnvironment=new Environment();

/** 
 * Palette of components stored in a JTree 
 */
protected JTree m_componentTree;

/** 
 * The node of the JTree that holds "user" (metabean) components 
 */
protected DefaultMutableTreeNode m_userCompNode;

/** 
 * The clip board 
 */
protected StringBuffer m_pasteBuffer;

int m_flowIndex;

boolean m_sequential;

boolean m_wasUserStopped=false;

/** 
 * variable for the KnowLedgeFlow class which would be set to null by the memory monitoring thread to free up some memory if we running out of memory.
 */
private static KnowledgeFlowApp m_knowledgeFlow;

/** 
 * for monitoring the Memory consumption 
 */
private static Memory m_Memory=new Memory(true);

public static Vector<StartUpListener> s_startupListeners=new Vector<StartUpListener>();

private boolean m_showFileMenu=true;

/** 
 * Add a plugin bean props file
 * @param beanPropsFile the plugin properties to add
 * @throws Exception if a problem occurs
 */
public static void addToPluginBeanProps(File beanPropsFile) throws Exception {
  BeansProperties.addToPluginBeanProps(beanPropsFile);
}

/** 
 * Remove a plugin bean props file
 * @param beanPropsFile the plugin properties to remove
 * @throws Exception if a problem occurs
 */
public static void removeFromPluginBeanProps(File beanPropsFile) throws Exception {
  BeansProperties.removeFromPluginBeanProps(beanPropsFile);
}

/** 
 * Loads KnowledgeFlow properties and any plugins (adds jars to the classpath)
 */
public static synchronized void loadProperties(){
  BeansProperties.loadProperties();
}

public static void reInitialize(){
  loadProperties();
  init();
}

/** 
 * Initializes the temporary files necessary to construct the toolbars from.
 */
private static void init(){
  weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"[KnowledgeFlow] Initializing KF...");
  if (!XMLBeans.SUPPRESS_PROPERTY_WARNINGS.contains("visual.iconPath")) {
    XMLBeans.SUPPRESS_PROPERTY_WARNINGS.add("visual.iconPath");
  }
  if (!XMLBeans.SUPPRESS_PROPERTY_WARNINGS.contains("visual.animatedIconPath")) {
    XMLBeans.SUPPRESS_PROPERTY_WARNINGS.add("visual.animatedIconPath");
  }
  try {
    TOOLBARS=new Vector<Vector<?>>();
    TreeMap<Integer,Object> wrapList=new TreeMap<Integer,Object>();
    Properties GEOProps=GenericPropertiesCreator.getGlobalOutputProperties();
    if (GEOProps == null) {
      GenericPropertiesCreator creator=new GenericPropertiesCreator();
      if (creator.useDynamic()) {
        creator.execute(false);
        GEOProps=creator.getOutputProperties();
      }
 else {
        GEOProps=Utils.readProperties("weka/gui/GenericObjectEditor.props");
      }
    }
    Enumeration<?> en=GEOProps.propertyNames();
    while (en.hasMoreElements()) {
      String geoKey=(String)en.nextElement();
      String beanCompName=BeansProperties.BEAN_PROPERTIES.getProperty(geoKey);
      if (beanCompName != null) {
        Vector<Object> newV=new Vector<Object>();
        String toolBarNameAlias=BeansProperties.BEAN_PROPERTIES.getProperty(geoKey + ".alias");
        String toolBarName=(toolBarNameAlias != null) ? toolBarNameAlias : geoKey.substring(geoKey.lastIndexOf('.') + 1,geoKey.length());
        String order=BeansProperties.BEAN_PROPERTIES.getProperty(geoKey + ".order");
        Integer intOrder=(order != null) ? new Integer(order) : new Integer(0);
        newV.addElement(toolBarName);
        newV.addElement(beanCompName);
        String rootPackage=geoKey.substring(0,geoKey.lastIndexOf('.'));
        newV.addElement(rootPackage);
        String wekaAlgs=GEOProps.getProperty(geoKey);
        Hashtable<String,String> roots=GenericObjectEditor.sortClassesByRoot(wekaAlgs);
        Hashtable<String,HierarchyPropertyParser> hpps=new Hashtable<String,HierarchyPropertyParser>();
        Enumeration<String> enm=roots.keys();
        while (enm.hasMoreElements()) {
          String root=enm.nextElement();
          String classes=roots.get(root);
          weka.gui.HierarchyPropertyParser hpp=new weka.gui.HierarchyPropertyParser();
          hpp.build(classes,", ");
          hpps.put(root,hpp);
        }
        newV.addElement(hpps);
        StringTokenizer st=new StringTokenizer(wekaAlgs,", ");
        while (st.hasMoreTokens()) {
          String current=st.nextToken().trim();
          newV.addElement(current);
        }
        wrapList.put(intOrder,newV);
      }
    }
    Iterator<Integer> keysetIt=wrapList.keySet().iterator();
    while (keysetIt.hasNext()) {
      Integer key=keysetIt.next();
      @SuppressWarnings("unchecked") Vector<Object> newV=(Vector<Object>)wrapList.get(key);
      if (newV != null) {
        TOOLBARS.addElement(newV);
      }
    }
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(null,"Could not read a configuration file for the generic objecte editor" + ". An example file is included with the Weka distribution.\n" + "This file should be named \"GenericObjectEditor.props\" and\n"+ "should be placed either in your user home (which is set\n"+ "to \"" + System.getProperties().getProperty("user.home") + "\")\n"+ "or the directory that java was started from\n","KnowledgeFlow",JOptionPane.ERROR_MESSAGE);
  }
  try {
    String standardToolBarNames=BeansProperties.BEAN_PROPERTIES.getProperty("weka.gui.beans.KnowledgeFlow.standardToolBars");
    StringTokenizer st=new StringTokenizer(standardToolBarNames,", ");
    while (st.hasMoreTokens()) {
      String tempBarName=st.nextToken().trim();
      Vector<String> newV=new Vector<String>();
      newV.addElement(tempBarName);
      newV.addElement("null");
      String toolBarContents=BeansProperties.BEAN_PROPERTIES.getProperty("weka.gui.beans.KnowledgeFlow." + tempBarName);
      StringTokenizer st2=new StringTokenizer(toolBarContents,", ");
      while (st2.hasMoreTokens()) {
        String tempBeanName=st2.nextToken().trim();
        newV.addElement(tempBeanName);
      }
      TOOLBARS.addElement(newV);
    }
  }
 catch (  Exception ex) {
    JOptionPane.showMessageDialog(null,ex.getMessage(),"KnowledgeFlow",JOptionPane.ERROR_MESSAGE);
  }
}

@Override public Component getTreeCellRendererComponent(JTree tree,Object value,boolean sel,boolean expanded,boolean leaf,int row,boolean hasFocus){
  super.getTreeCellRendererComponent(tree,value,sel,expanded,leaf,row,hasFocus);
  if (leaf) {
    Object userO=((DefaultMutableTreeNode)value).getUserObject();
    if (userO instanceof JTreeLeafDetails) {
      Icon i=((JTreeLeafDetails)userO).getIcon();
      if (i != null) {
        setIcon(i);
      }
    }
  }
  return this;
}

public InvisibleNode(){
  this(null);
}

public InvisibleNode(Object userObject){
  this(userObject,true,true);
}

public InvisibleNode(Object userObject,boolean allowsChildren,boolean isVisible){
  super(userObject,allowsChildren);
  this.m_isVisible=isVisible;
}

public TreeNode getChildAt(int index,boolean filterIsActive){
  if (!filterIsActive) {
    return super.getChildAt(index);
  }
  if (children == null) {
    throw new ArrayIndexOutOfBoundsException("node has no children");
  }
  int realIndex=-1;
  int visibleIndex=-1;
  @SuppressWarnings("unchecked") Enumeration<InvisibleNode> e=new WekaEnumeration<InvisibleNode>(children);
  while (e.hasMoreElements()) {
    InvisibleNode node=e.nextElement();
    if (node.isVisible()) {
      visibleIndex++;
    }
    realIndex++;
    if (visibleIndex == index) {
      return (TreeNode)children.elementAt(realIndex);
    }
  }
  throw new ArrayIndexOutOfBoundsException("index unmatched");
}

public int getChildCount(boolean filterIsActive){
  if (!filterIsActive) {
    return super.getChildCount();
  }
  if (children == null) {
    return 0;
  }
  int count=0;
  @SuppressWarnings("unchecked") Enumeration<InvisibleNode> e=new WekaEnumeration<InvisibleNode>(children);
  while (e.hasMoreElements()) {
    InvisibleNode node=e.nextElement();
    if (node.isVisible()) {
      count++;
    }
  }
  return count;
}

public void setVisible(boolean visible){
  this.m_isVisible=visible;
}

public boolean isVisible(){
  return m_isVisible;
}

public InvisibleTreeModel(TreeNode root){
  this(root,false);
}

public InvisibleTreeModel(TreeNode root,boolean asksAllowsChildren){
  this(root,false,false);
}

public InvisibleTreeModel(TreeNode root,boolean asksAllowsChildren,boolean filterIsActive){
  super(root,asksAllowsChildren);
  this.m_filterIsActive=filterIsActive;
}

public void activateFilter(boolean newValue){
  m_filterIsActive=newValue;
}

public boolean isActivatedFilter(){
  return m_filterIsActive;
}

@Override public Object getChild(Object parent,int index){
  if (m_filterIsActive) {
    if (parent instanceof InvisibleNode) {
      return ((InvisibleNode)parent).getChildAt(index,m_filterIsActive);
    }
  }
  return ((TreeNode)parent).getChildAt(index);
}

@Override public int getChildCount(Object parent){
  if (m_filterIsActive) {
    if (parent instanceof InvisibleNode) {
      return ((InvisibleNode)parent).getChildCount(m_filterIsActive);
    }
  }
  return ((TreeNode)parent).getChildCount();
}

/** 
 * Constructor.
 * @param fullName flully qualified name of the bean
 * @param icon icon for the bean
 */
protected JTreeLeafDetails(String fullName,Icon icon){
  this(fullName,"",icon);
}

/** 
 * Constructor
 * @param name fully qualified name of the bean
 * @param serializedMeta empty string or XML serialized MetaBean if thisleaf represents a "user" component
 * @param icon icon for the bean
 */
protected JTreeLeafDetails(String name,Vector<Object> serializedMeta,Icon icon){
  this(name,"",icon);
  m_metaBean=serializedMeta;
  m_isMeta=true;
  m_toolTipText="Hold down shift and click to remove";
}

/** 
 * Constructor
 * @param fullName fully qualified name of the bean
 * @param wekaAlgoName fully qualified name of the encapsulated (wrapped)weka algorithm, or null if this bean does not wrap a Weka algorithm
 * @param icon icon for the bean
 */
protected JTreeLeafDetails(String fullName,String wekaAlgoName,Icon icon){
  m_fullyQualifiedCompName=fullName;
  m_wekaAlgoName=wekaAlgoName;
  m_leafLabel=(wekaAlgoName.length() > 0) ? wekaAlgoName : m_fullyQualifiedCompName;
  if (m_leafLabel.lastIndexOf('.') > 0) {
    m_leafLabel=m_leafLabel.substring(m_leafLabel.lastIndexOf('.') + 1,m_leafLabel.length());
  }
  m_scaledIcon=icon;
}

/** 
 * Get the tool tip for this leaf
 * @return the tool tip
 */
protected String getToolTipText(){
  return m_toolTipText;
}

protected void setToolTipText(String tipText){
  m_toolTipText=tipText;
}

/** 
 * Returns the leaf label
 * @return the leaf label
 */
@Override public String toString(){
  return m_leafLabel;
}

/** 
 * Gets the icon for this bean
 * @return the icon for this bean
 */
protected Icon getIcon(){
  return m_scaledIcon;
}

/** 
 * Set the icon to use for this bean
 * @param icon the icon to use
 */
protected void setIcon(Icon icon){
  m_scaledIcon=icon;
}

/** 
 * Returns true if this leaf represents a wrapped Weka algorithm (i.e. filter, classifier, clusterer etc.).
 * @return true if this leaf represents a wrapped algorithm
 */
protected boolean isWrappedAlgorithm(){
  return (m_wekaAlgoName != null && m_wekaAlgoName.length() > 0);
}

/** 
 * Returns true if this leaf represents a MetaBean (i.e. "user" component)
 * @return true if this leaf represents a MetaBean
 */
protected boolean isMetaBean(){
  return (m_metaBean != null);
}

/** 
 * Gets the XML serialized MetaBean and associated information (icon, displayname)
 * @return the XML serialized MetaBean as a 3-element Vector containingdisplay name serialized bean and icon
 */
protected Vector<Object> getMetaBean(){
  return m_metaBean;
}

/** 
 * "Instantiates" the bean represented by this leaf.
 */
protected void instantiateBean(){
  try {
    if (isMetaBean()) {
      m_toolBarBean=m_metaBean.get(1);
    }
 else {
      m_toolBarBean=Beans.instantiate(KnowledgeFlowApp.this.getClass().getClassLoader(),m_fullyQualifiedCompName);
      if (isWrappedAlgorithm()) {
        Object algo=Beans.instantiate(KnowledgeFlowApp.this.getClass().getClassLoader(),m_wekaAlgoName);
        ((WekaWrapper)m_toolBarBean).setWrappedAlgorithm(algo);
      }
    }
    KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
    m_mode=ADDING;
    m_pasteB.setEnabled(false);
  }
 catch (  Exception ex) {
    System.err.println("Problem instantiating bean \"" + m_fullyQualifiedCompName + "\" (JTreeLeafDetails.instantiateBean()");
    ex.printStackTrace();
  }
}

@Override public void paintComponent(Graphics gx){
  double lz=m_layoutZoom / 100.0;
  ((Graphics2D)gx).scale(lz,lz);
  if (m_layoutZoom < 100) {
    ((Graphics2D)gx).setStroke(new BasicStroke(2));
  }
  super.paintComponent(gx);
  ((Graphics2D)gx).setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  ((Graphics2D)gx).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_GASP);
  BeanInstance.paintLabels(gx,m_mainKFPerspective.getCurrentTabIndex());
  BeanConnection.paintConnections(gx,m_mainKFPerspective.getCurrentTabIndex());
  if (m_mode == CONNECTING) {
    gx.drawLine(m_startX,m_startY,m_oldX,m_oldY);
  }
 else   if (m_mode == SELECTING) {
    gx.drawRect((m_startX < m_oldX) ? m_startX : m_oldX,(m_startY < m_oldY) ? m_startY : m_oldY,Math.abs(m_oldX - m_startX),Math.abs(m_oldY - m_startY));
  }
}

@Override public void doLayout(){
  super.doLayout();
  Vector<Object> comps=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
  for (int i=0; i < comps.size(); i++) {
    BeanInstance bi=(BeanInstance)comps.elementAt(i);
    JComponent c=(JComponent)bi.getBean();
    Dimension d=c.getPreferredSize();
    c.setBounds(bi.getX(),bi.getY(),d.width,d.height);
    c.revalidate();
  }
}

/** 
 * Set instances (if the perspective accepts them)
 * @param insts the instances
 */
void setInstances(Instances insts) throws Exception ;

/** 
 * Returns true if this perspective accepts instances
 * @return true if this perspective can accept instances
 */
boolean acceptsInstances();

/** 
 * Get the title of this perspective
 * @return the title of this perspective
 */
String getPerspectiveTitle();

/** 
 * Get the tool tip text for this perspective.
 * @return the tool tip text for this perspective
 */
String getPerspectiveTipText();

/** 
 * Get the icon for this perspective.
 * @return the Icon for this perspective (or null if the perspective doesnot have an icon)
 */
Icon getPerspectiveIcon();

/** 
 * Set active status of this perspective. True indicates that this perspective is the visible active perspective in the KnowledgeFlow
 * @param active true if this perspective is the active one
 */
void setActive(boolean active);

/** 
 * Set whether this perspective is "loaded" - i.e. whether or not the user has opted to have it available in the perspective toolbar. The perspective can make the decision as to allocating or freeing resources on the basis of this.
 * @param loaded true if the perspective is available in the perspectivetoolbar of the KnowledgeFlow
 */
void setLoaded(boolean loaded);

/** 
 * Set a reference to the main KnowledgeFlow perspective - i.e. the perspective that manages flow layouts.
 * @param main the main KnowledgeFlow perspective.
 */
void setMainKFPerspective(KnowledgeFlowApp.MainKFPerspective main);

@Override public void setActive(boolean active){
}

@Override public void setLoaded(boolean loaded){
}

@Override public void setMainKFPerspective(MainKFPerspective main){
}

public JTabbedPane getTabbedPane(){
  return m_flowTabs;
}

public synchronized int getNumTabs(){
  return m_flowTabs.getTabCount();
}

public synchronized String getTabTitle(int index){
  if (index < getNumTabs() && index >= 0) {
    return m_flowTabs.getTitleAt(index);
  }
  return null;
}

public synchronized int getCurrentTabIndex(){
  return m_flowTabs.getSelectedIndex();
}

public synchronized KFLogPanel getCurrentLogPanel(){
  if (getCurrentTabIndex() >= 0) {
    return m_logPanels.get(getCurrentTabIndex());
  }
  return null;
}

public synchronized KFLogPanel getLogPanel(int index){
  if (index >= 0 && index < m_logPanels.size()) {
    return m_logPanels.get(index);
  }
  return null;
}

public synchronized BeanLayout getCurrentBeanLayout(){
  if (getCurrentTabIndex() >= 0) {
    return m_beanLayouts.get(getCurrentTabIndex());
  }
  return null;
}

public synchronized BeanLayout getBeanLayout(int index){
  if (index >= 0 && index < m_logPanels.size()) {
    return m_beanLayouts.get(getCurrentTabIndex());
  }
  return null;
}

public synchronized int getCurrentZoomSetting(){
  if (getCurrentTabIndex() >= 0) {
    return m_zoomSettings.get(getCurrentTabIndex()).intValue();
  }
  return 100;
}

public synchronized int getZoomSetting(int index){
  if (index >= 0 && index < m_zoomSettings.size()) {
    return m_zoomSettings.get(index);
  }
  return 100;
}

public synchronized void setCurrentZoomSetting(int z){
  if (getNumTabs() > 0) {
    setZoomSetting(getCurrentTabIndex(),z);
  }
}

public synchronized void setZoomSetting(int index,int z){
  if (index < getNumTabs() && index >= 0) {
    m_zoomSettings.set(index,new Integer(z));
  }
}

public synchronized void setActiveTab(int index){
  if (index < getNumTabs() && index >= 0) {
    m_flowTabs.setSelectedIndex(index);
    m_logPanel=m_logPanels.get(index);
    m_beanLayout=m_beanLayouts.get(index);
    m_layoutZoom=m_zoomSettings.get(index);
    m_flowEnvironment=m_environmentSettings.get(index);
    m_saveB.setEnabled(!getExecuting());
    m_saveBB.setEnabled(!getExecuting());
    m_playB.setEnabled(!getExecuting());
    m_playBB.setEnabled(!getExecuting());
    m_saveB.setEnabled(!getExecuting());
    m_saveBB.setEnabled(!getExecuting());
    m_zoomOutB.setEnabled(!getExecuting());
    m_zoomInB.setEnabled(!getExecuting());
    if (m_layoutZoom == 50) {
      m_zoomOutB.setEnabled(false);
    }
    if (m_layoutZoom == 200) {
      m_zoomInB.setEnabled(false);
    }
    m_groupB.setEnabled(false);
    if (getSelectedBeans().size() > 0 && !getExecuting()) {
      final Vector<Object> selected=m_mainKFPerspective.getSelectedBeans();
      final Vector<Object> inputs=BeanConnection.inputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      final Vector<Object> outputs=BeanConnection.outputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      if (groupable(selected,inputs,outputs)) {
        m_groupB.setEnabled(true);
      }
    }
    m_cutB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_copyB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_deleteB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_selectAllB.setEnabled(BeanInstance.getBeanInstances(getCurrentTabIndex()).size() > 0 && !getExecuting());
    m_pasteB.setEnabled((m_pasteBuffer != null && m_pasteBuffer.length() > 0) && !getExecuting());
    m_stopB.setEnabled(getExecuting());
    m_undoB.setEnabled(!getExecuting() && getUndoBuffer().size() > 0);
  }
}

public synchronized void setExecuting(boolean executing){
  if (getNumTabs() > 0) {
    setExecuting(getCurrentTabIndex(),executing);
  }
}

public synchronized void setExecuting(int index,boolean executing){
  if (index < getNumTabs() && index >= 0) {
    m_executingList.set(index,new Boolean(executing));
    ((CloseableTabTitle)m_flowTabs.getTabComponentAt(index)).setButtonEnabled(!executing);
    m_saveB.setEnabled(!getExecuting());
    m_saveBB.setEnabled(!getExecuting());
    m_playB.setEnabled(!getExecuting());
    m_playBB.setEnabled(!getExecuting());
    m_stopB.setEnabled(getExecuting());
    m_groupB.setEnabled(false);
    if (getSelectedBeans().size() > 0 && !getExecuting()) {
      final Vector<Object> selected=m_mainKFPerspective.getSelectedBeans();
      final Vector<Object> inputs=BeanConnection.inputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      final Vector<Object> outputs=BeanConnection.outputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      if (groupable(selected,inputs,outputs)) {
        m_groupB.setEnabled(true);
      }
    }
    m_cutB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_deleteB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_selectAllB.setEnabled(BeanInstance.getBeanInstances(getCurrentTabIndex()).size() > 0 && !getExecuting());
    m_copyB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_pasteB.setEnabled((m_pasteBuffer != null && m_pasteBuffer.length() > 0) && !getExecuting());
    m_undoB.setEnabled(!getExecuting() && getUndoBuffer().size() > 0);
  }
}

public synchronized boolean getExecuting(){
  return getExecuting(getCurrentTabIndex());
}

public synchronized boolean getExecuting(int index){
  if (index < getNumTabs() && index >= 0) {
    return m_executingList.get(index);
  }
  return false;
}

public synchronized void setExecutionThread(RunThread execution){
  if (getNumTabs() > 0) {
    setExecutionThread(getCurrentTabIndex(),execution);
  }
}

public synchronized void setExecutionThread(int index,RunThread execution){
  if (index < getNumTabs() && index >= 0) {
    m_executionThreads.set(index,execution);
  }
}

public synchronized RunThread getExecutionThread(){
  return getExecutionThread(getCurrentTabIndex());
}

public synchronized RunThread getExecutionThread(int index){
  if (index < getNumTabs() && index >= 0) {
    return m_executionThreads.get(index);
  }
  return null;
}

public synchronized File getFlowFile(){
  if (getNumTabs() > 0) {
    return getFlowFile(getCurrentTabIndex());
  }
  return null;
}

public synchronized File getFlowFile(int index){
  if (index >= 0 && index < getNumTabs()) {
    return m_filePaths.get(index);
  }
  return null;
}

public synchronized void setFlowFile(File flowFile){
  if (getNumTabs() > 0) {
    setFlowFile(getCurrentTabIndex(),flowFile);
  }
}

public synchronized void setFlowFile(int index,File flowFile){
  if (index < getNumTabs() && index >= 0) {
    m_filePaths.set(index,flowFile);
  }
}

public synchronized void setTabTitle(String title){
  if (getNumTabs() > 0) {
    setTabTitle(getCurrentTabIndex(),title);
  }
}

public synchronized void setTabTitle(int index,String title){
  if (index < getNumTabs() && index >= 0) {
    m_flowTabs.setTitleAt(index,title);
    ((CloseableTabTitle)m_flowTabs.getTabComponentAt(index)).revalidate();
  }
}

public synchronized void setEditedStatus(boolean status){
  if (getNumTabs() > 0) {
    int current=getCurrentTabIndex();
    setEditedStatus(current,status);
  }
}

public synchronized void setEditedStatus(int index,boolean status){
  if (index < getNumTabs() && index >= 0) {
    Boolean newStatus=new Boolean(status);
    m_editedList.set(index,newStatus);
    ((CloseableTabTitle)m_flowTabs.getTabComponentAt(index)).setBold(status);
  }
}

/** 
 * Get the edited status of the currently selected tab. Returns false if there are no tabs
 * @return the edited status of the currently selected tab or false if thereare no tabs
 */
public synchronized boolean getEditedStatus(){
  if (getNumTabs() <= 0) {
    return false;
  }
  return getEditedStatus(getCurrentTabIndex());
}

/** 
 * Get the edited status of the tab at the supplied index. Returns false if the index is out of bounds or there are no tabs
 * @param index the index of the tab to check
 * @return the edited status of the tab
 */
public synchronized boolean getEditedStatus(int index){
  if (index < getNumTabs() && index >= 0) {
    return m_editedList.get(index);
  }
  return false;
}

public synchronized void setUndoBuffer(Stack<File> buffer){
  if (getNumTabs() > 0) {
    setUndoBuffer(getCurrentTabIndex(),buffer);
  }
}

public synchronized void setUndoBuffer(int index,Stack<File> buffer){
  if (index < getNumTabs() && index >= 0) {
    m_undoBufferList.set(index,buffer);
  }
}

public synchronized Stack<File> getUndoBuffer(){
  if (getNumTabs() > 0) {
    return getUndoBuffer(getCurrentTabIndex());
  }
  return null;
}

public synchronized Stack<File> getUndoBuffer(int index){
  if (index >= 0 && index < getNumTabs()) {
    return m_undoBufferList.get(index);
  }
  return null;
}

public synchronized Vector<Object> getSelectedBeans(){
  if (getNumTabs() > 0) {
    return getSelectedBeans(getCurrentTabIndex());
  }
  return null;
}

public synchronized Vector<Object> getSelectedBeans(int index){
  if (index < getNumTabs() && index >= 0) {
    return m_selectedBeans.get(index);
  }
  return null;
}

public synchronized void setSelectedBeans(Vector<Object> beans){
  if (getNumTabs() > 0) {
    setSelectedBeans(getCurrentTabIndex(),beans);
    m_groupB.setEnabled(false);
    if (getSelectedBeans().size() > 0 && !getExecuting()) {
      final Vector<Object> selected=m_mainKFPerspective.getSelectedBeans();
      final Vector<Object> inputs=BeanConnection.inputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      final Vector<Object> outputs=BeanConnection.outputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      if (groupable(selected,inputs,outputs)) {
        m_groupB.setEnabled(true);
      }
    }
    m_cutB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_copyB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
    m_deleteB.setEnabled(getSelectedBeans().size() > 0 && !getExecuting());
  }
}

public synchronized void setSelectedBeans(int index,Vector<Object> beans){
  if (index < getNumTabs() && index >= 0) {
    for (int i=0; i < m_selectedBeans.get(index).size(); i++) {
      BeanInstance temp=(BeanInstance)m_selectedBeans.get(index).elementAt(i);
      if (temp.getBean() instanceof Visible) {
        ((Visible)temp.getBean()).getVisual().setDisplayConnectors(false);
      }
 else       if (temp.getBean() instanceof Note) {
        ((Note)temp.getBean()).setHighlighted(false);
      }
    }
    m_selectedBeans.set(index,beans);
    for (int i=0; i < beans.size(); i++) {
      BeanInstance temp=(BeanInstance)beans.elementAt(i);
      if (temp.getBean() instanceof Visible) {
        ((Visible)temp.getBean()).getVisual().setDisplayConnectors(true);
      }
 else       if (temp.getBean() instanceof Note) {
        ((Note)temp.getBean()).setHighlighted(true);
      }
    }
  }
}

public synchronized Environment getEnvironmentSettings(){
  if (getNumTabs() > 0) {
    return getEnvironmentSettings(getCurrentTabIndex());
  }
  return null;
}

public synchronized Environment getEnvironmentSettings(int index){
  if (index < getNumTabs() && index >= 0) {
    return m_environmentSettings.get(index);
  }
  return null;
}

@Override public void setInstances(Instances insts){
}

@Override public boolean acceptsInstances(){
  return false;
}

/** 
 * Get the title of this perspective
 */
@Override public String getPerspectiveTitle(){
  return "Data mining processes";
}

/** 
 * Get the tool tip text for this perspective
 */
@Override public String getPerspectiveTipText(){
  return "Knowledge Flow processes";
}

/** 
 * Get the icon for this perspective
 */
@Override public Icon getPerspectiveIcon(){
  Image wekaI=loadImage("weka/gui/weka_icon_new.png");
  ImageIcon icon=new ImageIcon(wekaI);
  double width=icon.getIconWidth();
  double height=icon.getIconHeight();
  width*=0.035;
  height*=0.035;
  wekaI=wekaI.getScaledInstance((int)width,(int)height,Image.SCALE_SMOOTH);
  icon=new ImageIcon(wekaI);
  return icon;
}

@SuppressWarnings("unchecked") private void setUpToolsAndJTree(){
  JPanel toolBarPanel=new JPanel();
  toolBarPanel.setLayout(new BorderLayout());
  if (m_showFileMenu) {
    final Action closeAction=new AbstractAction("Close"){
      /** 
 */
      private static final long serialVersionUID=4762166880144590384L;
      @Override public void actionPerformed(      ActionEvent e){
        if (m_mainKFPerspective.getCurrentTabIndex() >= 0) {
          m_mainKFPerspective.removeTab(getCurrentTabIndex());
        }
      }
    }
;
    KeyStroke closeKey=KeyStroke.getKeyStroke(KeyEvent.VK_W,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Close",closeAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(closeKey,"Close");
    JToolBar fixedTools=new JToolBar();
    fixedTools.setOrientation(JToolBar.HORIZONTAL);
    m_groupB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "bricks.png")));
    m_groupB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_groupB.setToolTipText("Group selected (Ctrl+Z)");
    m_cutB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "cut.png")));
    m_cutB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_cutB.setToolTipText("Cut selected (Ctrl+X)");
    m_copyB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "page_copy.png")));
    m_copyB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_copyB.setToolTipText("Copy selected (Ctrl+C)");
    m_pasteB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "paste_plain.png")));
    m_pasteB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_pasteB.setToolTipText("Paste from clipboard (Ctrl+V)");
    m_deleteB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "delete.png")));
    m_deleteB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_deleteB.setToolTipText("Delete selected (DEL)");
    m_snapToGridB=new JToggleButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "shape_handles.png")));
    m_snapToGridB.setToolTipText("Snap to grid (Ctrl+G)");
    m_saveB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "disk.png")));
    m_saveB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_saveB.setToolTipText("Save layout (Ctrl+S)");
    m_saveBB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "disk_multiple.png")));
    m_saveBB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_saveBB.setToolTipText("Save layout with new name");
    m_loadB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "folder_add.png")));
    m_loadB.setToolTipText("Open (Ctrl+O)");
    m_loadB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_newB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "page_add.png")));
    m_newB.setToolTipText("New layout (Ctrl+N)");
    m_newB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_newB.setEnabled(getAllowMultipleTabs());
    m_helpB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "help.png")));
    m_helpB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_helpB.setToolTipText("Display help (Ctrl+H)");
    m_togglePerspectivesB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "cog_go.png")));
    m_togglePerspectivesB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_togglePerspectivesB.setToolTipText("Show/hide perspectives toolbar (Ctrl+P)");
    m_templatesB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "application_view_tile.png")));
    m_templatesB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_templatesB.setToolTipText("Load a template layout");
    m_noteB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "note_add.png")));
    m_noteB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_noteB.setToolTipText("Add a note to the layout (Ctrl+I)");
    m_selectAllB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "shape_group.png")));
    m_selectAllB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_selectAllB.setToolTipText("Select all (Ctrl+A)");
    m_zoomInB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "zoom_in.png")));
    m_zoomInB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_zoomInB.setToolTipText("Zoom in (Ctrl++)");
    m_zoomOutB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "zoom_out.png")));
    m_zoomOutB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_zoomOutB.setToolTipText("Zoom out (Ctrl+-)");
    m_undoB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "arrow_undo.png")));
    m_undoB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
    m_undoB.setToolTipText("Undo (Ctrl+U)");
    fixedTools.add(m_zoomInB);
    fixedTools.add(m_zoomOutB);
    fixedTools.addSeparator();
    fixedTools.add(m_selectAllB);
    fixedTools.add(m_groupB);
    fixedTools.add(m_cutB);
    fixedTools.add(m_copyB);
    fixedTools.add(m_deleteB);
    fixedTools.add(m_pasteB);
    fixedTools.add(m_undoB);
    fixedTools.add(m_noteB);
    fixedTools.addSeparator();
    fixedTools.add(m_snapToGridB);
    fixedTools.addSeparator();
    fixedTools.add(m_newB);
    fixedTools.add(m_saveB);
    fixedTools.add(m_saveBB);
    fixedTools.add(m_loadB);
    fixedTools.add(m_templatesB);
    fixedTools.addSeparator();
    fixedTools.add(m_togglePerspectivesB);
    fixedTools.add(m_helpB);
    Dimension d=m_undoB.getPreferredSize();
    Dimension d2=fixedTools.getMinimumSize();
    Dimension d3=new Dimension(d2.width,d.height + 4);
    fixedTools.setPreferredSize(d3);
    fixedTools.setMaximumSize(d3);
    final Action saveAction=new AbstractAction("Save"){
      /** 
 */
      private static final long serialVersionUID=5182044142154404706L;
      @Override public void actionPerformed(      ActionEvent e){
        if (m_mainKFPerspective.getCurrentTabIndex() >= 0) {
          saveLayout(m_mainKFPerspective.getCurrentTabIndex(),false);
        }
      }
    }
;
    KeyStroke saveKey=KeyStroke.getKeyStroke(KeyEvent.VK_S,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Save",saveAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(saveKey,"Save");
    m_saveB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        saveAction.actionPerformed(e);
      }
    }
);
    m_saveBB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        saveLayout(m_mainKFPerspective.getCurrentTabIndex(),true);
      }
    }
);
    final Action openAction=new AbstractAction("Open"){
      /** 
 */
      private static final long serialVersionUID=-5106547209818805444L;
      @Override public void actionPerformed(      ActionEvent e){
        m_flowEnvironment=new Environment();
        loadLayout();
      }
    }
;
    KeyStroke openKey=KeyStroke.getKeyStroke(KeyEvent.VK_O,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Open",openAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(openKey,"Open");
    m_loadB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        openAction.actionPerformed(e);
      }
    }
);
    final Action newAction=new AbstractAction("New"){
      /** 
 */
      private static final long serialVersionUID=8002244400334262966L;
      @Override public void actionPerformed(      ActionEvent e){
        clearLayout();
      }
    }
;
    KeyStroke newKey=KeyStroke.getKeyStroke(KeyEvent.VK_N,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("New",newAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(newKey,"New");
    m_newB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent ae){
        newAction.actionPerformed(ae);
      }
    }
);
    final Action selectAllAction=new AbstractAction("SelectAll"){
      /** 
 */
      private static final long serialVersionUID=-8086754050844707658L;
      @Override public void actionPerformed(      ActionEvent e){
        if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0) {
          Vector<Object> allBeans=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
          Vector<Object> newSelected=new Vector<Object>();
          for (int i=0; i < allBeans.size(); i++) {
            newSelected.add(allBeans.get(i));
          }
          if (newSelected.size() == m_mainKFPerspective.getSelectedBeans().size()) {
            m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
          }
 else {
            m_mainKFPerspective.setSelectedBeans(newSelected);
          }
        }
        revalidate();
        repaint();
        notifyIsDirty();
      }
    }
;
    KeyStroke selectAllKey=KeyStroke.getKeyStroke(KeyEvent.VK_A,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("SelectAll",selectAllAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(selectAllKey,"SelectAll");
    m_selectAllB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        selectAllAction.actionPerformed(e);
      }
    }
);
    final Action zoomInAction=new AbstractAction("ZoomIn"){
      /** 
 */
      private static final long serialVersionUID=1348383794897269484L;
      @Override public void actionPerformed(      ActionEvent e){
        m_layoutZoom+=25;
        m_zoomOutB.setEnabled(true);
        if (m_layoutZoom >= 200) {
          m_layoutZoom=200;
          m_zoomInB.setEnabled(false);
        }
        m_mainKFPerspective.setCurrentZoomSetting(m_layoutZoom);
        revalidate();
        repaint();
        notifyIsDirty();
      }
    }
;
    KeyStroke zoomInKey=KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("ZoomIn",zoomInAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(zoomInKey,"ZoomIn");
    m_zoomInB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        zoomInAction.actionPerformed(e);
      }
    }
);
    final Action zoomOutAction=new AbstractAction("ZoomOut"){
      /** 
 */
      private static final long serialVersionUID=-1120096894263455918L;
      @Override public void actionPerformed(      ActionEvent e){
        m_layoutZoom-=25;
        m_zoomInB.setEnabled(true);
        if (m_layoutZoom <= 50) {
          m_layoutZoom=50;
          m_zoomOutB.setEnabled(false);
        }
        m_mainKFPerspective.setCurrentZoomSetting(m_layoutZoom);
        revalidate();
        repaint();
        notifyIsDirty();
      }
    }
;
    KeyStroke zoomOutKey=KeyStroke.getKeyStroke(KeyEvent.VK_MINUS,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("ZoomOut",zoomOutAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(zoomOutKey,"ZoomOut");
    m_zoomOutB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        zoomOutAction.actionPerformed(e);
      }
    }
);
    final Action groupAction=new AbstractAction("Group"){
      /** 
 */
      private static final long serialVersionUID=-5752742619180091435L;
      @Override public void actionPerformed(      ActionEvent e){
        final Vector<Object> selected=m_mainKFPerspective.getSelectedBeans();
        final Vector<Object> inputs=BeanConnection.inputs(selected,m_mainKFPerspective.getCurrentTabIndex());
        final Vector<Object> outputs=BeanConnection.outputs(selected,m_mainKFPerspective.getCurrentTabIndex());
        groupSubFlow(selected,inputs,outputs);
      }
    }
;
    KeyStroke groupKey=KeyStroke.getKeyStroke(KeyEvent.VK_Z,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Group",groupAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(groupKey,"Group");
    m_groupB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        groupAction.actionPerformed(e);
      }
    }
);
    final Action cutAction=new AbstractAction("Cut"){
      /** 
 */
      private static final long serialVersionUID=-4955878102742013040L;
      @Override public void actionPerformed(      ActionEvent e){
        if (copyToClipboard()) {
          deleteSelectedBeans();
        }
      }
    }
;
    KeyStroke cutKey=KeyStroke.getKeyStroke(KeyEvent.VK_X,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Cut",cutAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(cutKey,"Cut");
    m_cutB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        cutAction.actionPerformed(e);
      }
    }
);
    final Action deleteAction=new AbstractAction("Delete"){
      /** 
 */
      private static final long serialVersionUID=4621688037874199553L;
      @Override public void actionPerformed(      ActionEvent e){
        deleteSelectedBeans();
      }
    }
;
    KeyStroke deleteKey=KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,0);
    MainKFPerspective.this.getActionMap().put("Delete",deleteAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(deleteKey,"Delete");
    m_deleteB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        deleteAction.actionPerformed(e);
      }
    }
);
    final Action copyAction=new AbstractAction("Copy"){
      /** 
 */
      private static final long serialVersionUID=117010390180468707L;
      @Override public void actionPerformed(      ActionEvent e){
        copyToClipboard();
        m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
      }
    }
;
    KeyStroke copyKey=KeyStroke.getKeyStroke(KeyEvent.VK_C,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Copy",copyAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(copyKey,"Copy");
    m_copyB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        copyAction.actionPerformed(e);
      }
    }
);
    final Action pasteAction=new AbstractAction("Paste"){
      /** 
 */
      private static final long serialVersionUID=5935121051028929455L;
      @Override public void actionPerformed(      ActionEvent e){
        KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
        m_mode=PASTING;
      }
    }
;
    KeyStroke pasteKey=KeyStroke.getKeyStroke(KeyEvent.VK_V,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Paste",pasteAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(pasteKey,"Paste");
    m_pasteB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        pasteAction.actionPerformed(e);
      }
    }
);
    final Action snapAction=new AbstractAction("Snap"){
      /** 
 */
      private static final long serialVersionUID=7820689847829357449L;
      @Override public void actionPerformed(      ActionEvent e){
        m_snapToGridB.setSelected(!m_snapToGridB.isSelected());
        if (m_snapToGridB.isSelected()) {
          snapSelectedToGrid();
        }
      }
    }
;
    KeyStroke snapKey=KeyStroke.getKeyStroke(KeyEvent.VK_G,InputEvent.CTRL_DOWN_MASK);
    MainKFPerspective.this.getActionMap().put("Snap",snapAction);
    MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(snapKey,"Snap");
    m_snapToGridB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (m_snapToGridB.isSelected()) {
          snapSelectedToGrid();
        }
      }
    }
);
    fixedTools.setFloatable(false);
    toolBarPanel.add(fixedTools,BorderLayout.EAST);
  }
  final Action noteAction=new AbstractAction("Note"){
    /** 
 */
    private static final long serialVersionUID=2991743619130024875L;
    @Override public void actionPerformed(    ActionEvent e){
      Note n=new Note();
      m_toolBarBean=n;
      KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
      m_mode=ADDING;
    }
  }
;
  KeyStroke noteKey=KeyStroke.getKeyStroke(KeyEvent.VK_I,InputEvent.CTRL_DOWN_MASK);
  MainKFPerspective.this.getActionMap().put("Note",noteAction);
  MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(noteKey,"Note");
  m_noteB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      noteAction.actionPerformed(e);
    }
  }
);
  final Action undoAction=new AbstractAction("Undo"){
    /** 
 */
    private static final long serialVersionUID=7248362305594881263L;
    @Override public void actionPerformed(    ActionEvent e){
      Stack<File> undo=m_mainKFPerspective.getUndoBuffer();
      if (undo.size() > 0) {
        File undoF=undo.pop();
        if (undo.size() == 0) {
          m_undoB.setEnabled(false);
        }
        loadLayout(undoF,false,true);
      }
    }
  }
;
  KeyStroke undoKey=KeyStroke.getKeyStroke(KeyEvent.VK_U,InputEvent.CTRL_DOWN_MASK);
  MainKFPerspective.this.getActionMap().put("Undo",undoAction);
  MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(undoKey,"Undo");
  m_undoB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      undoAction.actionPerformed(e);
    }
  }
);
  m_playB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "resultset_next.png")));
  m_playB.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  m_playB.setToolTipText("Run this flow (all start points launched in parallel)");
  m_playB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() == 0) {
        return;
      }
      boolean proceed=true;
      if (m_Memory.memoryIsLow()) {
        proceed=m_Memory.showMemoryIsLow();
      }
      if (proceed) {
        runFlow(false);
      }
    }
  }
);
  m_playBB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "resultset_last.png")));
  m_playBB.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  m_playBB.setToolTipText("Run this flow (start points launched sequentially)");
  m_playBB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() == 0) {
        return;
      }
      if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.SequentialRunInfo")) {
        JCheckBox dontShow=new JCheckBox("Do not show this message again");
        Object[] stuff=new Object[2];
        stuff[0]="The order that data sources are launched in can be\n" + "specified by setting a custom name for each data source that\n" + "that includes a number. E.g. \"1:MyArffLoader\". To set a name,\n"+ "right-click over a data source and select \"Set name\"\n\n"+ "If the prefix is not specified, then the order of execution\n"+ "will correspond to the order that the components were added\n"+ "to the layout. Note that it is also possible to prevent a data\n"+ "source from executing by prefixing its name with a \"!\". E.g\n"+ "\"!:MyArffLoader\"";
        stuff[1]=dontShow;
        JOptionPane.showMessageDialog(KnowledgeFlowApp.this,stuff,"Sequential execution information",JOptionPane.OK_OPTION);
        if (dontShow.isSelected()) {
          try {
            Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.SequentialRunInfo");
          }
 catch (          Exception ex) {
          }
        }
      }
      boolean proceed=true;
      if (m_Memory.memoryIsLow()) {
        proceed=m_Memory.showMemoryIsLow();
      }
      if (proceed) {
        runFlow(true);
      }
    }
  }
);
  m_stopB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "shape_square.png")));
  m_stopB.setBorder(BorderFactory.createEmptyBorder(0,8,0,0));
  m_stopB.setToolTipText("Stop all execution");
  Image tempI=loadImage(BeanVisual.ICON_PATH + "cursor.png");
  m_pointerB=new JButton(new ImageIcon(tempI));
  m_pointerB.setBorder(BorderFactory.createEmptyBorder(0,5,0,0));
  m_pointerB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      m_toolBarBean=null;
      m_mode=NONE;
      KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
      m_componentTree.clearSelection();
    }
  }
);
  JToolBar fixedTools2=new JToolBar();
  fixedTools2.setOrientation(JToolBar.HORIZONTAL);
  fixedTools2.setFloatable(false);
  fixedTools2.add(m_pointerB);
  fixedTools2.add(m_playB);
  fixedTools2.add(m_playBB);
  fixedTools2.add(m_stopB);
  Dimension d=m_playB.getPreferredSize();
  Dimension d2=fixedTools2.getMinimumSize();
  Dimension d3=new Dimension(d2.width,d.height + 4);
  fixedTools2.setPreferredSize(d3);
  fixedTools2.setMaximumSize(d3);
  toolBarPanel.add(fixedTools2,BorderLayout.WEST);
  m_stopB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      m_logPanel.statusMessage("@!@[KnowledgeFlow]|Attempting to stop all components...");
      stopFlow();
      m_logPanel.statusMessage("@!@[KnowledgeFlow]|OK.");
    }
  }
);
  final Action helpAction=new AbstractAction("Help"){
    /** 
 */
    private static final long serialVersionUID=3301809940717051925L;
    @Override public void actionPerformed(    ActionEvent e){
      popupHelp();
    }
  }
;
  KeyStroke helpKey=KeyStroke.getKeyStroke(KeyEvent.VK_H,InputEvent.CTRL_DOWN_MASK);
  MainKFPerspective.this.getActionMap().put("Help",helpAction);
  MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(helpKey,"Help");
  m_helpB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent ae){
      helpAction.actionPerformed(ae);
    }
  }
);
  m_templatesB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      createTemplateMenuPopup();
    }
  }
);
  m_templatesB.setEnabled(BeansProperties.TEMPLATE_PATHS.size() > 0);
  final Action togglePerspectivesAction=new AbstractAction("Toggle perspectives"){
    /** 
 */
    private static final long serialVersionUID=5394622655137498495L;
    @Override public void actionPerformed(    ActionEvent e){
      if (m_firstUserComponentOpp) {
        installWindowListenerForSavingUserStuff();
        m_firstUserComponentOpp=false;
      }
      if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo")) {
        JCheckBox dontShow=new JCheckBox("Do not show this message again");
        Object[] stuff=new Object[2];
        stuff[0]="Perspectives are environments that take over the\n" + "Knowledge Flow UI and provide major additional functionality.\n" + "Many perspectives will operate on a set of instances. Instances\n"+ "Can be sent to a perspective by placing a DataSource on the\n"+ "layout canvas, configuring it and then selecting \"Send to perspective\"\n"+ "from the contextual popup menu that appears when you right-click on\n"+ "it. Several perspectives are built in to the Knowledge Flow, others\n"+ "can be installed via the package manager.\n";
        stuff[1]=dontShow;
        JOptionPane.showMessageDialog(KnowledgeFlowApp.this,stuff,"Perspective information",JOptionPane.OK_OPTION);
        if (dontShow.isSelected()) {
          try {
            Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo");
          }
 catch (          Exception ex) {
          }
        }
      }
      if (m_configAndPerspectivesVisible) {
        KnowledgeFlowApp.this.remove(m_configAndPerspectives);
        m_configAndPerspectivesVisible=false;
      }
 else {
        KnowledgeFlowApp.this.add(m_configAndPerspectives,BorderLayout.NORTH);
        m_configAndPerspectivesVisible=true;
      }
      revalidate();
      repaint();
      notifyIsDirty();
    }
  }
;
  KeyStroke togglePerspectivesKey=KeyStroke.getKeyStroke(KeyEvent.VK_P,InputEvent.CTRL_DOWN_MASK);
  MainKFPerspective.this.getActionMap().put("Toggle perspectives",togglePerspectivesAction);
  MainKFPerspective.this.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(togglePerspectivesKey,"Toggle perspectives");
  m_togglePerspectivesB.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      togglePerspectivesAction.actionPerformed(e);
    }
  }
);
  final int standard_toolset=0;
  final int wrapper_toolset=1;
  int toolBarType=standard_toolset;
  DefaultMutableTreeNode jtreeRoot=new DefaultMutableTreeNode("Weka");
  for (int i=0; i < TOOLBARS.size(); i++) {
    Vector<?> tempBarSpecs=TOOLBARS.elementAt(i);
    String tempToolSetName=(String)tempBarSpecs.elementAt(0);
    DefaultMutableTreeNode subTreeNode=new InvisibleNode(tempToolSetName);
    jtreeRoot.add(subTreeNode);
    String tempBeanCompName=(String)tempBarSpecs.elementAt(1);
    String rootPackage="";
    weka.gui.HierarchyPropertyParser hpp=null;
    Hashtable<String,HierarchyPropertyParser> hpps=null;
    if (tempBeanCompName.compareTo("null") != 0) {
      toolBarType=wrapper_toolset;
      rootPackage=(String)tempBarSpecs.elementAt(2);
      hpps=(Hashtable<String,HierarchyPropertyParser>)tempBarSpecs.elementAt(3);
      try {
        Beans.instantiate(this.getClass().getClassLoader(),tempBeanCompName);
      }
 catch (      Exception ex) {
        weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Failed to instantiate: " + tempBeanCompName);
        break;
      }
    }
 else {
      toolBarType=standard_toolset;
    }
    int z=2;
    if (toolBarType == wrapper_toolset) {
      Enumeration<String> enm=hpps.keys();
      while (enm.hasMoreElements()) {
        String root=enm.nextElement();
        hpp=hpps.get(root);
        if (!hpp.goTo(rootPackage)) {
        }
        String[] primaryPackages=hpp.childrenValues();
        for (        String primaryPackage : primaryPackages) {
          hpp.goToChild(primaryPackage);
          if (hpp.isLeafReached()) {
            String algName=hpp.fullValue();
            Object visibleCheck=instantiateBean((toolBarType == wrapper_toolset),tempBeanCompName,algName);
            if (visibleCheck != null) {
              if (visibleCheck instanceof BeanContextChild) {
                m_bcSupport.add(visibleCheck);
              }
              ImageIcon scaledForTree=null;
              if (visibleCheck instanceof Visible) {
                BeanVisual bv=((Visible)visibleCheck).getVisual();
                if (bv != null) {
                  scaledForTree=new ImageIcon(bv.scale(0.33));
                }
              }
              String toolTip="";
              try {
                Object wrappedA=Class.forName(algName).newInstance();
                toolTip=getGlobalInfo(wrappedA);
              }
 catch (              Exception ex) {
              }
              JTreeLeafDetails leafData=new JTreeLeafDetails(tempBeanCompName,algName,scaledForTree);
              if (toolTip != null && toolTip.length() > 0) {
                leafData.setToolTipText(toolTip);
              }
              DefaultMutableTreeNode leafAlgo=new InvisibleNode(leafData);
              subTreeNode.add(leafAlgo);
              m_nodeTextIndex.put(algName.toLowerCase() + " " + (toolTip != null ? toolTip.toLowerCase() + " " : ""),leafAlgo);
            }
            hpp.goToParent();
          }
 else {
            DefaultMutableTreeNode firstLevelOfMainAlgoType=new InvisibleNode(primaryPackage);
            subTreeNode.add(firstLevelOfMainAlgoType);
            processPackage(tempBeanCompName,hpp,firstLevelOfMainAlgoType,m_nodeTextIndex);
          }
        }
      }
    }
 else {
      for (int j=z; j < tempBarSpecs.size(); j++) {
        tempBeanCompName=(String)tempBarSpecs.elementAt(j);
        Object visibleCheck=instantiateBean((toolBarType == wrapper_toolset),tempBeanCompName,"");
        if (visibleCheck != null) {
          String treeName=tempBeanCompName;
          if (treeName.lastIndexOf('.') > 0) {
            treeName=treeName.substring(treeName.lastIndexOf('.') + 1,treeName.length());
          }
          if (visibleCheck instanceof BeanContextChild) {
            m_bcSupport.add(visibleCheck);
          }
          ImageIcon scaledForTree=null;
          if (visibleCheck instanceof Visible) {
            BeanVisual bv=((Visible)visibleCheck).getVisual();
            if (bv != null) {
              scaledForTree=new ImageIcon(bv.scale(0.33));
            }
          }
          String tipText=null;
          tipText=getGlobalInfo(visibleCheck);
          Class<?> compClass=visibleCheck.getClass();
          Annotation[] annotations=compClass.getDeclaredAnnotations();
          String category=null;
          DefaultMutableTreeNode targetFolder=null;
          for (          Annotation ann : annotations) {
            if (ann instanceof KFStep) {
              tipText="<html><font color=blue>" + ((KFStep)ann).toolTipText() + "</font></html>";
              category=((KFStep)ann).category();
              Enumeration<Object> children=jtreeRoot.children();
              while (children.hasMoreElements()) {
                Object child=children.nextElement();
                if (child instanceof DefaultMutableTreeNode) {
                  if (((DefaultMutableTreeNode)child).getUserObject().toString().equals(category)) {
                    targetFolder=(DefaultMutableTreeNode)child;
                    break;
                  }
                }
              }
              break;
            }
          }
          JTreeLeafDetails leafData=new JTreeLeafDetails(tempBeanCompName,"",scaledForTree);
          if (tipText != null) {
            leafData.setToolTipText(tipText);
          }
          DefaultMutableTreeNode fixedLeafNode=new InvisibleNode(leafData);
          if (targetFolder != null) {
            targetFolder.add(fixedLeafNode);
          }
 else {
            subTreeNode.add(fixedLeafNode);
          }
          m_nodeTextIndex.put(tempBeanCompName.toLowerCase() + " " + (tipText != null ? tipText.toLowerCase() : ""),fixedLeafNode);
        }
      }
    }
  }
  if (BeansProperties.BEAN_PLUGINS_PROPERTIES != null && BeansProperties.BEAN_PLUGINS_PROPERTIES.size() > 0) {
    boolean pluginBeans=false;
    DefaultMutableTreeNode userSubTree=null;
    for (int i=0; i < BeansProperties.BEAN_PLUGINS_PROPERTIES.size(); i++) {
      Properties tempP=BeansProperties.BEAN_PLUGINS_PROPERTIES.get(i);
      String components=tempP.getProperty("weka.gui.beans.KnowledgeFlow.Plugins");
      if (components != null && components.length() > 0) {
        StringTokenizer st2=new StringTokenizer(components,", ");
        while (st2.hasMoreTokens()) {
          String tempBeanCompName=st2.nextToken().trim();
          String treeName=tempBeanCompName;
          if (treeName.lastIndexOf('.') > 0) {
            treeName=treeName.substring(treeName.lastIndexOf('.') + 1,treeName.length());
          }
          Object visibleCheck=instantiateBean((toolBarType == wrapper_toolset),tempBeanCompName,"");
          if (visibleCheck instanceof BeanContextChild) {
            m_bcSupport.add(visibleCheck);
          }
          ImageIcon scaledForTree=null;
          if (visibleCheck instanceof Visible) {
            BeanVisual bv=((Visible)visibleCheck).getVisual();
            if (bv != null) {
              scaledForTree=new ImageIcon(bv.scale(0.33));
            }
          }
          String tipText=null;
          tipText=getGlobalInfo(visibleCheck);
          Class<?> compClass=visibleCheck.getClass();
          Annotation[] annotations=compClass.getDeclaredAnnotations();
          DefaultMutableTreeNode targetFolder=null;
          String category=null;
          for (          Annotation ann : annotations) {
            if (ann instanceof KFStep) {
              category=((KFStep)ann).category();
              tipText="<html><font color=red>" + ((KFStep)ann).toolTipText() + "</font></html>";
              Enumeration<Object> children=jtreeRoot.children();
              while (children.hasMoreElements()) {
                Object child=children.nextElement();
                if (child instanceof DefaultMutableTreeNode) {
                  if (((DefaultMutableTreeNode)child).getUserObject().toString().equals(category)) {
                    targetFolder=(DefaultMutableTreeNode)child;
                    break;
                  }
                }
              }
              break;
            }
          }
          JTreeLeafDetails leafData=new JTreeLeafDetails(tempBeanCompName,"",scaledForTree);
          if (tipText != null) {
            leafData.setToolTipText(tipText);
          }
          DefaultMutableTreeNode pluginLeaf=new InvisibleNode(leafData);
          m_nodeTextIndex.put(tempBeanCompName.toLowerCase() + (tipText != null ? " " + tipText.toLowerCase() : ""),pluginLeaf);
          if (targetFolder != null) {
            targetFolder.add(pluginLeaf);
          }
 else           if (category != null) {
            DefaultMutableTreeNode newCategoryNode=new InvisibleNode(category);
            jtreeRoot.add(newCategoryNode);
            newCategoryNode.add(pluginLeaf);
          }
 else {
            if (!pluginBeans) {
              userSubTree=new InvisibleNode("Plugins");
              jtreeRoot.add(userSubTree);
              pluginBeans=true;
            }
            userSubTree.add(pluginLeaf);
          }
        }
      }
      String perspectives=tempP.getProperty(("weka.gui.beans.KnowledgeFlow.Perspectives"));
      if (perspectives != null && perspectives.length() > 0) {
        StringTokenizer st2=new StringTokenizer(perspectives,",");
        while (st2.hasMoreTokens()) {
          String className=st2.nextToken();
          try {
            if (PluginManager.isInDisabledList(className)) {
              continue;
            }
            Object p=Class.forName(className).newInstance();
            if (p instanceof KFPerspective && p instanceof JPanel) {
              String title=((KFPerspective)p).getPerspectiveTitle();
              weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"[KnowledgeFlow] loaded perspective: " + title);
              m_pluginPerspectiveLookup.put(className,title);
              ((KFPerspective)p).setLoaded(false);
              if (BeansProperties.VISIBLE_PERSPECTIVES.contains(className)) {
                m_perspectiveCache.put(className,(KFPerspective)p);
              }
            }
          }
 catch (          Exception ex) {
            if (m_logPanel != null) {
              m_logPanel.logMessage("[KnowledgeFlow] WARNING: " + "unable to instantiate perspective \"" + className + "\"");
              ex.printStackTrace();
            }
 else {
              System.err.println("[KnowledgeFlow] WARNING: " + "unable to instantiate perspective \"" + className + "\"");
              ex.printStackTrace();
            }
          }
        }
      }
    }
  }
  m_togglePerspectivesB.setEnabled(m_pluginPerspectiveLookup.keySet().size() > 0);
  add(toolBarPanel,BorderLayout.NORTH);
  InvisibleTreeModel model=new InvisibleTreeModel(jtreeRoot);
  model.activateFilter(true);
  m_componentTree=new JTree(model){
    /** 
 */
    private static final long serialVersionUID=6628795889296634120L;
    @Override public String getToolTipText(    MouseEvent e){
      if ((getRowForLocation(e.getX(),e.getY())) == -1) {
        return null;
      }
      TreePath currPath=getPathForLocation(e.getX(),e.getY());
      if (currPath.getLastPathComponent() instanceof DefaultMutableTreeNode) {
        DefaultMutableTreeNode node=(DefaultMutableTreeNode)currPath.getLastPathComponent();
        if (node.isLeaf()) {
          JTreeLeafDetails leaf=(JTreeLeafDetails)node.getUserObject();
          return leaf.getToolTipText();
        }
      }
      return null;
    }
  }
;
  m_componentTree.setEnabled(true);
  m_componentTree.setToolTipText("");
  m_componentTree.setRootVisible(false);
  m_componentTree.setShowsRootHandles(true);
  m_componentTree.setCellRenderer(new BeanIconRenderer());
  DefaultTreeSelectionModel selectionModel=new DefaultTreeSelectionModel();
  selectionModel.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  m_componentTree.setSelectionModel(selectionModel);
  m_componentTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (((e.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || e.isAltDown()) {
        boolean clearSelection=true;
        if (clearSelection) {
          m_toolBarBean=null;
          m_mode=NONE;
          KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
          m_componentTree.clearSelection();
        }
      }
      TreePath p=m_componentTree.getSelectionPath();
      if (p != null) {
        if (p.getLastPathComponent() instanceof DefaultMutableTreeNode) {
          DefaultMutableTreeNode tNode=(DefaultMutableTreeNode)p.getLastPathComponent();
          if (tNode.isLeaf()) {
            Object userObject=tNode.getUserObject();
            if (userObject instanceof JTreeLeafDetails) {
              if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0 && ((JTreeLeafDetails)userObject).isMetaBean()) {
                if (m_firstUserComponentOpp) {
                  installWindowListenerForSavingUserStuff();
                  m_firstUserComponentOpp=false;
                }
                Vector<Object> toRemove=((JTreeLeafDetails)userObject).getMetaBean();
                DefaultTreeModel model=(DefaultTreeModel)m_componentTree.getModel();
                MutableTreeNode userRoot=(MutableTreeNode)tNode.getParent();
                model.removeNodeFromParent(tNode);
                m_userComponents.remove(toRemove);
                if (m_userComponents.size() == 0) {
                  model.removeNodeFromParent(userRoot);
                  m_userCompNode=null;
                }
              }
 else {
                ((JTreeLeafDetails)userObject).instantiateBean();
              }
            }
          }
        }
      }
    }
  }
);
}

@Override public void actionPerformed(ActionEvent e){
  if (m_mainKFPerspective.getCurrentTabIndex() >= 0) {
    m_mainKFPerspective.removeTab(getCurrentTabIndex());
  }
}

@Override public void actionPerformed(ActionEvent e){
  if (m_mainKFPerspective.getCurrentTabIndex() >= 0) {
    saveLayout(m_mainKFPerspective.getCurrentTabIndex(),false);
  }
}

@Override public void actionPerformed(ActionEvent e){
  saveAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  saveLayout(m_mainKFPerspective.getCurrentTabIndex(),true);
}

@Override public void actionPerformed(ActionEvent e){
  m_flowEnvironment=new Environment();
  loadLayout();
}

@Override public void actionPerformed(ActionEvent e){
  openAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  clearLayout();
}

@Override public void actionPerformed(ActionEvent ae){
  newAction.actionPerformed(ae);
}

@Override public void actionPerformed(ActionEvent e){
  if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0) {
    Vector<Object> allBeans=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
    Vector<Object> newSelected=new Vector<Object>();
    for (int i=0; i < allBeans.size(); i++) {
      newSelected.add(allBeans.get(i));
    }
    if (newSelected.size() == m_mainKFPerspective.getSelectedBeans().size()) {
      m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
    }
 else {
      m_mainKFPerspective.setSelectedBeans(newSelected);
    }
  }
  revalidate();
  repaint();
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  selectAllAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  m_layoutZoom+=25;
  m_zoomOutB.setEnabled(true);
  if (m_layoutZoom >= 200) {
    m_layoutZoom=200;
    m_zoomInB.setEnabled(false);
  }
  m_mainKFPerspective.setCurrentZoomSetting(m_layoutZoom);
  revalidate();
  repaint();
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  zoomInAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  m_layoutZoom-=25;
  m_zoomInB.setEnabled(true);
  if (m_layoutZoom <= 50) {
    m_layoutZoom=50;
    m_zoomOutB.setEnabled(false);
  }
  m_mainKFPerspective.setCurrentZoomSetting(m_layoutZoom);
  revalidate();
  repaint();
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  zoomOutAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  final Vector<Object> selected=m_mainKFPerspective.getSelectedBeans();
  final Vector<Object> inputs=BeanConnection.inputs(selected,m_mainKFPerspective.getCurrentTabIndex());
  final Vector<Object> outputs=BeanConnection.outputs(selected,m_mainKFPerspective.getCurrentTabIndex());
  groupSubFlow(selected,inputs,outputs);
}

@Override public void actionPerformed(ActionEvent e){
  groupAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  if (copyToClipboard()) {
    deleteSelectedBeans();
  }
}

@Override public void actionPerformed(ActionEvent e){
  cutAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  deleteSelectedBeans();
}

@Override public void actionPerformed(ActionEvent e){
  deleteAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  copyToClipboard();
  m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
}

@Override public void actionPerformed(ActionEvent e){
  copyAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
  m_mode=PASTING;
}

@Override public void actionPerformed(ActionEvent e){
  pasteAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  m_snapToGridB.setSelected(!m_snapToGridB.isSelected());
  if (m_snapToGridB.isSelected()) {
    snapSelectedToGrid();
  }
}

@Override public void actionPerformed(ActionEvent e){
  if (m_snapToGridB.isSelected()) {
    snapSelectedToGrid();
  }
}

@Override public void actionPerformed(ActionEvent e){
  Note n=new Note();
  m_toolBarBean=n;
  KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
  m_mode=ADDING;
}

@Override public void actionPerformed(ActionEvent e){
  noteAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  Stack<File> undo=m_mainKFPerspective.getUndoBuffer();
  if (undo.size() > 0) {
    File undoF=undo.pop();
    if (undo.size() == 0) {
      m_undoB.setEnabled(false);
    }
    loadLayout(undoF,false,true);
  }
}

@Override public void actionPerformed(ActionEvent e){
  undoAction.actionPerformed(e);
}

@Override public void actionPerformed(ActionEvent e){
  if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() == 0) {
    return;
  }
  boolean proceed=true;
  if (m_Memory.memoryIsLow()) {
    proceed=m_Memory.showMemoryIsLow();
  }
  if (proceed) {
    runFlow(false);
  }
}

@Override public void actionPerformed(ActionEvent e){
  if (BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() == 0) {
    return;
  }
  if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.SequentialRunInfo")) {
    JCheckBox dontShow=new JCheckBox("Do not show this message again");
    Object[] stuff=new Object[2];
    stuff[0]="The order that data sources are launched in can be\n" + "specified by setting a custom name for each data source that\n" + "that includes a number. E.g. \"1:MyArffLoader\". To set a name,\n"+ "right-click over a data source and select \"Set name\"\n\n"+ "If the prefix is not specified, then the order of execution\n"+ "will correspond to the order that the components were added\n"+ "to the layout. Note that it is also possible to prevent a data\n"+ "source from executing by prefixing its name with a \"!\". E.g\n"+ "\"!:MyArffLoader\"";
    stuff[1]=dontShow;
    JOptionPane.showMessageDialog(KnowledgeFlowApp.this,stuff,"Sequential execution information",JOptionPane.OK_OPTION);
    if (dontShow.isSelected()) {
      try {
        Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.SequentialRunInfo");
      }
 catch (      Exception ex) {
      }
    }
  }
  boolean proceed=true;
  if (m_Memory.memoryIsLow()) {
    proceed=m_Memory.showMemoryIsLow();
  }
  if (proceed) {
    runFlow(true);
  }
}

@Override public void actionPerformed(ActionEvent e){
  m_toolBarBean=null;
  m_mode=NONE;
  KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
  m_componentTree.clearSelection();
}

@Override public void actionPerformed(ActionEvent e){
  m_logPanel.statusMessage("@!@[KnowledgeFlow]|Attempting to stop all components...");
  stopFlow();
  m_logPanel.statusMessage("@!@[KnowledgeFlow]|OK.");
}

@Override public void actionPerformed(ActionEvent e){
  popupHelp();
}

@Override public void actionPerformed(ActionEvent ae){
  helpAction.actionPerformed(ae);
}

@Override public void actionPerformed(ActionEvent e){
  createTemplateMenuPopup();
}

@Override public void actionPerformed(ActionEvent e){
  if (m_firstUserComponentOpp) {
    installWindowListenerForSavingUserStuff();
    m_firstUserComponentOpp=false;
  }
  if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo")) {
    JCheckBox dontShow=new JCheckBox("Do not show this message again");
    Object[] stuff=new Object[2];
    stuff[0]="Perspectives are environments that take over the\n" + "Knowledge Flow UI and provide major additional functionality.\n" + "Many perspectives will operate on a set of instances. Instances\n"+ "Can be sent to a perspective by placing a DataSource on the\n"+ "layout canvas, configuring it and then selecting \"Send to perspective\"\n"+ "from the contextual popup menu that appears when you right-click on\n"+ "it. Several perspectives are built in to the Knowledge Flow, others\n"+ "can be installed via the package manager.\n";
    stuff[1]=dontShow;
    JOptionPane.showMessageDialog(KnowledgeFlowApp.this,stuff,"Perspective information",JOptionPane.OK_OPTION);
    if (dontShow.isSelected()) {
      try {
        Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo");
      }
 catch (      Exception ex) {
      }
    }
  }
  if (m_configAndPerspectivesVisible) {
    KnowledgeFlowApp.this.remove(m_configAndPerspectives);
    m_configAndPerspectivesVisible=false;
  }
 else {
    KnowledgeFlowApp.this.add(m_configAndPerspectives,BorderLayout.NORTH);
    m_configAndPerspectivesVisible=true;
  }
  revalidate();
  repaint();
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  togglePerspectivesAction.actionPerformed(e);
}

@Override public String getToolTipText(MouseEvent e){
  if ((getRowForLocation(e.getX(),e.getY())) == -1) {
    return null;
  }
  TreePath currPath=getPathForLocation(e.getX(),e.getY());
  if (currPath.getLastPathComponent() instanceof DefaultMutableTreeNode) {
    DefaultMutableTreeNode node=(DefaultMutableTreeNode)currPath.getLastPathComponent();
    if (node.isLeaf()) {
      JTreeLeafDetails leaf=(JTreeLeafDetails)node.getUserObject();
      return leaf.getToolTipText();
    }
  }
  return null;
}

@Override public void mouseClicked(MouseEvent e){
  if (((e.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || e.isAltDown()) {
    boolean clearSelection=true;
    if (clearSelection) {
      m_toolBarBean=null;
      m_mode=NONE;
      KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
      m_componentTree.clearSelection();
    }
  }
  TreePath p=m_componentTree.getSelectionPath();
  if (p != null) {
    if (p.getLastPathComponent() instanceof DefaultMutableTreeNode) {
      DefaultMutableTreeNode tNode=(DefaultMutableTreeNode)p.getLastPathComponent();
      if (tNode.isLeaf()) {
        Object userObject=tNode.getUserObject();
        if (userObject instanceof JTreeLeafDetails) {
          if ((e.getModifiers() & InputEvent.SHIFT_MASK) != 0 && ((JTreeLeafDetails)userObject).isMetaBean()) {
            if (m_firstUserComponentOpp) {
              installWindowListenerForSavingUserStuff();
              m_firstUserComponentOpp=false;
            }
            Vector<Object> toRemove=((JTreeLeafDetails)userObject).getMetaBean();
            DefaultTreeModel model=(DefaultTreeModel)m_componentTree.getModel();
            MutableTreeNode userRoot=(MutableTreeNode)tNode.getParent();
            model.removeNodeFromParent(tNode);
            m_userComponents.remove(toRemove);
            if (m_userComponents.size() == 0) {
              model.removeNodeFromParent(userRoot);
              m_userCompNode=null;
            }
          }
 else {
            ((JTreeLeafDetails)userObject).instantiateBean();
          }
        }
      }
    }
  }
}

public MainKFPerspective(){
  setLayout(new BorderLayout());
  setUpToolsAndJTree();
  JScrollPane treeView=new JScrollPane(m_componentTree);
  JPanel treeHolder=new JPanel();
  treeHolder.setLayout(new BorderLayout());
  treeHolder.setBorder(BorderFactory.createTitledBorder("Design"));
  treeHolder.add(treeView,BorderLayout.CENTER);
  final JTextField searchField=new JTextField();
  treeHolder.add(searchField,BorderLayout.NORTH);
  searchField.setToolTipText("Search (clear field to reset)");
  searchField.addKeyListener(new KeyAdapter(){
    @Override public void keyReleased(    KeyEvent e){
      String searchTerm=searchField.getText();
      List<DefaultMutableTreeNode> nonhits=new ArrayList<DefaultMutableTreeNode>();
      List<DefaultMutableTreeNode> hits=new ArrayList<DefaultMutableTreeNode>();
      DefaultTreeModel model=(DefaultTreeModel)m_componentTree.getModel();
      model.reload();
      for (      Map.Entry<String,DefaultMutableTreeNode> entry : m_nodeTextIndex.entrySet()) {
        if (entry.getValue() instanceof InvisibleNode) {
          ((InvisibleNode)entry.getValue()).setVisible(true);
        }
        if (searchTerm != null && searchTerm.length() > 0) {
          if (entry.getKey().contains(searchTerm.toLowerCase())) {
            hits.add(entry.getValue());
          }
 else {
            nonhits.add(entry.getValue());
          }
        }
      }
      if (searchTerm == null || searchTerm.length() == 0) {
        model.reload();
      }
      if (hits.size() > 0) {
        for (        DefaultMutableTreeNode h : nonhits) {
          if (h instanceof InvisibleNode) {
            ((InvisibleNode)h).setVisible(false);
          }
        }
        model.reload();
        for (        DefaultMutableTreeNode h : hits) {
          TreeNode[] path=model.getPathToRoot(h);
          TreePath tpath=new TreePath(path);
          tpath=tpath.getParentPath();
          m_componentTree.expandPath(tpath);
        }
      }
    }
  }
);
  JSplitPane p2=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeHolder,m_flowTabs);
  p2.setOneTouchExpandable(true);
  add(p2,BorderLayout.CENTER);
  Dimension d=treeView.getPreferredSize();
  d=new Dimension((int)(d.getWidth() * 1.5),(int)d.getHeight());
  treeView.setPreferredSize(d);
  treeView.setMinimumSize(d);
  m_flowTabs.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent evt){
      int sel=m_flowTabs.getSelectedIndex();
      setActiveTab(sel);
    }
  }
);
}

@Override public void keyReleased(KeyEvent e){
  String searchTerm=searchField.getText();
  List<DefaultMutableTreeNode> nonhits=new ArrayList<DefaultMutableTreeNode>();
  List<DefaultMutableTreeNode> hits=new ArrayList<DefaultMutableTreeNode>();
  DefaultTreeModel model=(DefaultTreeModel)m_componentTree.getModel();
  model.reload();
  for (  Map.Entry<String,DefaultMutableTreeNode> entry : m_nodeTextIndex.entrySet()) {
    if (entry.getValue() instanceof InvisibleNode) {
      ((InvisibleNode)entry.getValue()).setVisible(true);
    }
    if (searchTerm != null && searchTerm.length() > 0) {
      if (entry.getKey().contains(searchTerm.toLowerCase())) {
        hits.add(entry.getValue());
      }
 else {
        nonhits.add(entry.getValue());
      }
    }
  }
  if (searchTerm == null || searchTerm.length() == 0) {
    model.reload();
  }
  if (hits.size() > 0) {
    for (    DefaultMutableTreeNode h : nonhits) {
      if (h instanceof InvisibleNode) {
        ((InvisibleNode)h).setVisible(false);
      }
    }
    model.reload();
    for (    DefaultMutableTreeNode h : hits) {
      TreeNode[] path=model.getPathToRoot(h);
      TreePath tpath=new TreePath(path);
      tpath=tpath.getParentPath();
      m_componentTree.expandPath(tpath);
    }
  }
}

@Override public void stateChanged(ChangeEvent evt){
  int sel=m_flowTabs.getSelectedIndex();
  setActiveTab(sel);
}

public synchronized void removeTab(int tabIndex){
  if (tabIndex < 0 || tabIndex >= getNumTabs()) {
    return;
  }
  if (m_editedList.get(tabIndex)) {
    String tabTitle=m_flowTabs.getTitleAt(tabIndex);
    String message="\"" + tabTitle + "\" has been modified. Save changes "+ "before closing?";
    int result=JOptionPane.showConfirmDialog(KnowledgeFlowApp.this,message,"Save changes",JOptionPane.YES_NO_CANCEL_OPTION);
    if (result == JOptionPane.YES_OPTION) {
      saveLayout(tabIndex,false);
    }
 else     if (result == JOptionPane.CANCEL_OPTION) {
      return;
    }
  }
  BeanLayout bl=m_beanLayouts.get(tabIndex);
  BeanInstance.removeBeanInstances(bl,tabIndex);
  BeanConnection.removeConnectionList(tabIndex);
  m_beanLayouts.remove(tabIndex);
  m_zoomSettings.remove(tabIndex);
  m_logPanels.remove(tabIndex);
  m_editedList.remove(tabIndex);
  m_environmentSettings.remove(tabIndex);
  m_selectedBeans.remove(tabIndex);
  bl=null;
  m_flowTabs.remove(tabIndex);
  if (getCurrentTabIndex() < 0) {
    m_beanLayout=null;
    m_logPanel=null;
    m_saveB.setEnabled(false);
  }
}

public synchronized void addTab(String tabTitle){
  BeanInstance.addBeanInstances(new Vector<Object>(),null);
  BeanConnection.addConnections(new Vector<BeanConnection>());
  JPanel p1=new JPanel();
  p1.setLayout(new BorderLayout());
  BeanLayout tabBeanLayout=new BeanLayout();
  final JScrollPane js=new JScrollPane(tabBeanLayout);
  p1.add(js,BorderLayout.CENTER);
  js.getVerticalScrollBar().setUnitIncrement(m_ScrollBarIncrementLayout);
  js.getHorizontalScrollBar().setUnitIncrement(m_ScrollBarIncrementLayout);
  configureBeanLayout(tabBeanLayout);
  m_beanLayouts.add(tabBeanLayout);
  tabBeanLayout.setSize(m_FlowWidth,m_FlowHeight);
  Dimension d=tabBeanLayout.getPreferredSize();
  tabBeanLayout.setMinimumSize(d);
  tabBeanLayout.setPreferredSize(d);
  m_zoomSettings.add(new Integer(100));
  KFLogPanel tabLogPanel=new KFLogPanel();
  setUpLogPanel(tabLogPanel);
  Dimension d2=new Dimension(100,170);
  tabLogPanel.setPreferredSize(d2);
  tabLogPanel.setMinimumSize(d2);
  m_logPanels.add(tabLogPanel);
  m_environmentSettings.add(new Environment());
  m_filePaths.add(new File("-NONE-"));
  JSplitPane p2=new JSplitPane(JSplitPane.VERTICAL_SPLIT,p1,tabLogPanel);
  p2.setOneTouchExpandable(true);
  p2.setDividerLocation(0.7);
  p2.setResizeWeight(1.0);
  JPanel splitHolder=new JPanel();
  splitHolder.setLayout(new BorderLayout());
  splitHolder.add(p2,BorderLayout.CENTER);
  m_editedList.add(new Boolean(false));
  m_executingList.add(new Boolean(false));
  m_executionThreads.add((RunThread)null);
  m_selectedBeans.add(new Vector<Object>());
  m_undoBufferList.add(new Stack<File>());
  m_flowTabs.addTab(tabTitle,splitHolder);
  int tabIndex=getNumTabs() - 1;
  m_flowTabs.setTabComponentAt(tabIndex,new CloseableTabTitle(m_flowTabs));
  setActiveTab(getNumTabs() - 1);
  m_saveB.setEnabled(true);
}

public CloseableTabTitle(final JTabbedPane pane){
  super(new FlowLayout(FlowLayout.LEFT,0,0));
  m_enclosingPane=pane;
  setOpaque(false);
  setBorder(BorderFactory.createEmptyBorder(2,0,0,0));
  m_tabLabel=new JLabel(){
    /** 
 */
    private static final long serialVersionUID=8515052190461050324L;
    @Override public String getText(){
      int index=m_enclosingPane.indexOfTabComponent(CloseableTabTitle.this);
      if (index >= 0) {
        return m_enclosingPane.getTitleAt(index);
      }
      return null;
    }
  }
;
  add(m_tabLabel);
  m_tabLabel.setBorder(BorderFactory.createEmptyBorder(0,0,0,5));
  m_tabButton=new TabButton();
  add(m_tabButton);
}

@Override public String getText(){
  int index=m_enclosingPane.indexOfTabComponent(CloseableTabTitle.this);
  if (index >= 0) {
    return m_enclosingPane.getTitleAt(index);
  }
  return null;
}

public void setBold(boolean bold){
  m_tabLabel.setEnabled(bold);
}

public void setButtonEnabled(boolean enabled){
  m_tabButton.setEnabled(enabled);
}

public TabButton(){
  int size=17;
  setPreferredSize(new Dimension(size,size));
  setToolTipText("close this tab");
  setUI(new BasicButtonUI());
  setContentAreaFilled(false);
  setFocusable(false);
  setBorder(BorderFactory.createEtchedBorder());
  setBorderPainted(false);
  addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      Component component=e.getComponent();
      if (component instanceof AbstractButton) {
        AbstractButton button=(AbstractButton)component;
        button.setBorderPainted(true);
        int i=m_enclosingPane.indexOfTabComponent(CloseableTabTitle.this);
        if (i == m_mainKFPerspective.getCurrentTabIndex()) {
          button.setToolTipText("close this tab (Ctrl+W)");
        }
 else {
          button.setToolTipText("close this tab");
        }
      }
    }
    @Override public void mouseExited(    MouseEvent e){
      Component component=e.getComponent();
      if (component instanceof AbstractButton) {
        AbstractButton button=(AbstractButton)component;
        button.setBorderPainted(false);
      }
    }
  }
);
  setRolloverEnabled(true);
  addActionListener(this);
}

@Override public void mouseEntered(MouseEvent e){
  Component component=e.getComponent();
  if (component instanceof AbstractButton) {
    AbstractButton button=(AbstractButton)component;
    button.setBorderPainted(true);
    int i=m_enclosingPane.indexOfTabComponent(CloseableTabTitle.this);
    if (i == m_mainKFPerspective.getCurrentTabIndex()) {
      button.setToolTipText("close this tab (Ctrl+W)");
    }
 else {
      button.setToolTipText("close this tab");
    }
  }
}

@Override public void mouseExited(MouseEvent e){
  Component component=e.getComponent();
  if (component instanceof AbstractButton) {
    AbstractButton button=(AbstractButton)component;
    button.setBorderPainted(false);
  }
}

@Override public void actionPerformed(ActionEvent e){
  int i=m_enclosingPane.indexOfTabComponent(CloseableTabTitle.this);
  if (i >= 0 && getAllowMultipleTabs()) {
    m_mainKFPerspective.removeTab(i);
  }
}

@Override public void updateUI(){
}

@Override protected void paintComponent(Graphics g){
  super.paintComponent(g);
  Graphics2D g2=(Graphics2D)g.create();
  if (getModel().isPressed()) {
    g2.translate(1,1);
  }
  g2.setStroke(new BasicStroke(2));
  g2.setColor(Color.BLACK);
  if (!isEnabled()) {
    g2.setColor(Color.GRAY);
  }
  if (getModel().isRollover()) {
    g2.setColor(Color.MAGENTA);
  }
  int delta=6;
  g2.drawLine(delta,delta,getWidth() - delta - 1,getHeight() - delta - 1);
  g2.drawLine(getWidth() - delta - 1,delta,delta,getHeight() - delta - 1);
  g2.dispose();
}

public synchronized void setMessageOnAll(boolean mainKFLine,String message){
  for (  String key : m_tableIndexes.keySet()) {
    if (!mainKFLine && key.equals("[KnowledgeFlow]")) {
      continue;
    }
    String tm=key + "|" + message;
    statusMessage(tm);
  }
}

/** 
 * Set the environment variables to use. NOTE: loading a new layout resets back to the default set of variables
 * @param env
 */
public void setEnvironment(Environment env){
  m_flowEnvironment=env;
  setEnvironment();
}

private void setEnvironment(){
  Vector<Object> beans=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
  for (int i=0; i < beans.size(); i++) {
    Object temp=((BeanInstance)beans.elementAt(i)).getBean();
    if (temp instanceof EnvironmentHandler) {
      ((EnvironmentHandler)temp).setEnvironment(m_flowEnvironment);
    }
  }
}

/** 
 * Creates a new <code>KnowledgeFlowApp</code> instance.
 */
public KnowledgeFlowApp(boolean showFileMenu){
  if (BeansProperties.BEAN_PROPERTIES == null) {
    loadProperties();
    init();
  }
  m_showFileMenu=showFileMenu;
  JWindow temp=new JWindow();
  temp.setVisible(true);
  temp.getGraphics().setFont(new Font(null,Font.PLAIN,9));
  m_fontM=temp.getGraphics().getFontMetrics();
  temp.setVisible(false);
  try {
    m_ScrollBarIncrementLayout=Integer.parseInt(BeansProperties.BEAN_PROPERTIES.getProperty("ScrollBarIncrementLayout","" + m_ScrollBarIncrementLayout));
    m_ScrollBarIncrementComponents=Integer.parseInt(BeansProperties.BEAN_PROPERTIES.getProperty("ScrollBarIncrementComponents","" + m_ScrollBarIncrementComponents));
    m_FlowWidth=Integer.parseInt(BeansProperties.BEAN_PROPERTIES.getProperty("FlowWidth","" + m_FlowWidth));
    m_FlowHeight=Integer.parseInt(BeansProperties.BEAN_PROPERTIES.getProperty("FlowHeight","" + m_FlowHeight));
    m_PreferredExtension=BeansProperties.BEAN_PROPERTIES.getProperty("PreferredExtension",m_PreferredExtension);
    m_UserComponentsInXML=Boolean.valueOf(BeansProperties.BEAN_PROPERTIES.getProperty("UserComponentsInXML","" + m_UserComponentsInXML)).booleanValue();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  m_FileChooser.addChoosableFileFilter(m_KfFilter);
  if (KOML.isPresent()) {
    m_FileChooser.addChoosableFileFilter(m_KOMLFilter);
  }
  if (XStream.isPresent()) {
    m_FileChooser.addChoosableFileFilter(m_XStreamFilter);
  }
  m_FileChooser.addChoosableFileFilter(m_XMLFilter);
  if (m_PreferredExtension.equals(FILE_EXTENSION_XML)) {
    m_FileChooser.setFileFilter(m_XMLFilter);
  }
 else   if (KOML.isPresent() && m_PreferredExtension.equals(KOML.FILE_EXTENSION + "kf")) {
    m_FileChooser.setFileFilter(m_KOMLFilter);
  }
 else   if (XStream.isPresent() && m_PreferredExtension.equals(XStream.FILE_EXTENSION + "kf")) {
    m_FileChooser.setFileFilter(m_XStreamFilter);
  }
 else {
    m_FileChooser.setFileFilter(m_KfFilter);
  }
  m_FileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
  m_bcSupport.setDesignTime(true);
  m_perspectiveHolder=new JPanel();
  m_perspectiveHolder.setLayout(new BorderLayout());
  m_mainKFPerspective=new MainKFPerspective();
  m_perspectives.add(m_mainKFPerspective);
  setLayout(new BorderLayout());
  add(m_perspectiveHolder,BorderLayout.CENTER);
  m_perspectiveHolder.add(m_mainKFPerspective,BorderLayout.CENTER);
  if (m_pluginPerspectiveLookup.size() > 0) {
    String titleM=m_mainKFPerspective.getPerspectiveTitle();
    Icon icon=m_mainKFPerspective.getPerspectiveIcon();
    JToggleButton tBut=new JToggleButton(titleM,icon,true);
    tBut.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        KFPerspective current=(KFPerspective)m_perspectiveHolder.getComponent(0);
        current.setActive(false);
        m_perspectiveHolder.remove(0);
        m_perspectiveHolder.add((JComponent)m_perspectives.get(0),BorderLayout.CENTER);
        m_perspectives.get(0).setActive(true);
        KnowledgeFlowApp.this.revalidate();
        KnowledgeFlowApp.this.repaint();
        notifyIsDirty();
      }
    }
);
    m_perspectiveToolBar.add(tBut);
    m_perspectiveGroup.add(tBut);
    setupUserPerspectives();
  }
  if (m_pluginPerspectiveLookup.size() > 0) {
    m_configAndPerspectives=new JPanel();
    m_configAndPerspectives.setLayout(new BorderLayout());
    m_configAndPerspectives.add(m_perspectiveToolBar,BorderLayout.CENTER);
    try {
      Properties visible=Utils.readProperties(BeansProperties.VISIBLE_PERSPECTIVES_PROPERTIES_FILE);
      Enumeration<?> keys=visible.propertyNames();
      if (keys.hasMoreElements()) {
        String toolBarIsVisible=visible.getProperty("weka.gui.beans.KnowledgeFlow.PerspectiveToolBarVisisble");
        if (toolBarIsVisible != null && toolBarIsVisible.length() > 0) {
          m_configAndPerspectivesVisible=toolBarIsVisible.equalsIgnoreCase("yes");
        }
      }
    }
 catch (    Exception ex) {
      System.err.println("Problem reading visible perspectives property file");
      ex.printStackTrace();
    }
    if (m_configAndPerspectivesVisible) {
      add(m_configAndPerspectives,BorderLayout.NORTH);
    }
    JButton configB=new JButton(new ImageIcon(loadImage(BeanVisual.ICON_PATH + "cog.png")));
    configB.setBorder(BorderFactory.createEmptyBorder(0,5,0,1));
    configB.setToolTipText("Enable/disable perspectives");
    m_configAndPerspectives.add(configB,BorderLayout.WEST);
    configB.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo")) {
          JCheckBox dontShow=new JCheckBox("Do not show this message again");
          Object[] stuff=new Object[2];
          stuff[0]="Perspectives are environments that take over the\n" + "Knowledge Flow UI and provide major additional functionality.\n" + "Many perspectives will operate on a set of instances. Instances\n"+ "Can be sent to a perspective by placing a DataSource on the\n"+ "layout canvas, configuring it and then selecting \"Send to perspective\"\n"+ "from the contextual popup menu that appears when you right-click on\n"+ "it. Several perspectives are built in to the Knowledge Flow, others\n"+ "can be installed via the package manager.\n";
          stuff[1]=dontShow;
          JOptionPane.showMessageDialog(KnowledgeFlowApp.this,stuff,"Perspective information",JOptionPane.OK_OPTION);
          if (dontShow.isSelected()) {
            try {
              Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo");
            }
 catch (            Exception ex) {
            }
          }
        }
        popupPerspectiveConfigurer();
      }
    }
);
  }
  for (  String pName : m_perspectiveCache.keySet()) {
    m_perspectiveCache.get(pName).setMainKFPerspective(m_mainKFPerspective);
  }
  loadUserComponents();
  clearLayout();
}

@Override public void actionPerformed(ActionEvent e){
  KFPerspective current=(KFPerspective)m_perspectiveHolder.getComponent(0);
  current.setActive(false);
  m_perspectiveHolder.remove(0);
  m_perspectiveHolder.add((JComponent)m_perspectives.get(0),BorderLayout.CENTER);
  m_perspectives.get(0).setActive(true);
  KnowledgeFlowApp.this.revalidate();
  KnowledgeFlowApp.this.repaint();
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  if (!Utils.getDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo")) {
    JCheckBox dontShow=new JCheckBox("Do not show this message again");
    Object[] stuff=new Object[2];
    stuff[0]="Perspectives are environments that take over the\n" + "Knowledge Flow UI and provide major additional functionality.\n" + "Many perspectives will operate on a set of instances. Instances\n"+ "Can be sent to a perspective by placing a DataSource on the\n"+ "layout canvas, configuring it and then selecting \"Send to perspective\"\n"+ "from the contextual popup menu that appears when you right-click on\n"+ "it. Several perspectives are built in to the Knowledge Flow, others\n"+ "can be installed via the package manager.\n";
    stuff[1]=dontShow;
    JOptionPane.showMessageDialog(KnowledgeFlowApp.this,stuff,"Perspective information",JOptionPane.OK_OPTION);
    if (dontShow.isSelected()) {
      try {
        Utils.setDontShowDialog("weka.gui.beans.KnowledgeFlow.PerspectiveInfo");
      }
 catch (      Exception ex) {
      }
    }
  }
  popupPerspectiveConfigurer();
}

/** 
 * Gets the main knowledge flow perspective
 * @return the main knowledge flow perspective
 */
public MainKFPerspective getMainPerspective(){
  return m_mainKFPerspective;
}

private void popupPerspectiveConfigurer(){
  if (m_perspectiveConfigurer == null) {
    m_perspectiveConfigurer=new AttributeSelectionPanel(true,true,true,true);
  }
  if (m_firstUserComponentOpp) {
    installWindowListenerForSavingUserStuff();
    m_firstUserComponentOpp=false;
  }
  ArrayList<Attribute> atts=new ArrayList<Attribute>();
  final ArrayList<String> pClasses=new ArrayList<String>();
  SortedSet<String> sortedPerspectives=new TreeSet<String>();
  for (  String clName : m_pluginPerspectiveLookup.keySet()) {
    sortedPerspectives.add(clName);
  }
  for (  String clName : sortedPerspectives) {
    pClasses.add(clName);
    String pName=m_pluginPerspectiveLookup.get(clName);
    atts.add(new Attribute(pName));
  }
  Instances perspectiveInstances=new Instances("Perspectives",atts,1);
  boolean[] selectedPerspectives=new boolean[perspectiveInstances.numAttributes()];
  for (  String selected : BeansProperties.VISIBLE_PERSPECTIVES) {
    String pName=m_pluginPerspectiveLookup.get(selected);
    if (pName != null) {
      int index=perspectiveInstances.attribute(pName).index();
      selectedPerspectives[index]=true;
    }
  }
  m_perspectiveConfigurer.setInstances(perspectiveInstances);
  try {
    m_perspectiveConfigurer.setSelectedAttributes(selectedPerspectives);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    return;
  }
  final JDialog d=new JDialog((JFrame)KnowledgeFlowApp.this.getTopLevelAncestor(),"Manage Perspectives",ModalityType.DOCUMENT_MODAL);
  d.setLayout(new BorderLayout());
  JPanel holder=new JPanel();
  holder.setLayout(new BorderLayout());
  holder.add(m_perspectiveConfigurer,BorderLayout.CENTER);
  JButton okBut=new JButton("OK");
  JButton cancelBut=new JButton("Cancel");
  JPanel butHolder=new JPanel();
  butHolder.setLayout(new GridLayout(1,2));
  butHolder.add(okBut);
  butHolder.add(cancelBut);
  holder.add(butHolder,BorderLayout.SOUTH);
  okBut.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      BeansProperties.VISIBLE_PERSPECTIVES=new TreeSet<String>();
      int[] selected=m_perspectiveConfigurer.getSelectedAttributes();
      for (      int element : selected) {
        String selectedClassName=pClasses.get(element);
        if (m_perspectiveCache.get(selectedClassName) == null) {
          try {
            Object p=Class.forName(selectedClassName).newInstance();
            if (p instanceof KFPerspective && p instanceof JPanel) {
              String title=((KFPerspective)p).getPerspectiveTitle();
              weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"[KnowledgeFlow] loaded perspective: " + title);
              ((KFPerspective)p).setLoaded(true);
              ((KFPerspective)p).setMainKFPerspective(m_mainKFPerspective);
              m_perspectiveCache.put(selectedClassName,(KFPerspective)p);
            }
          }
 catch (          Exception ex) {
            ex.printStackTrace();
          }
        }
        BeansProperties.VISIBLE_PERSPECTIVES.add(selectedClassName);
      }
      setupUserPerspectives();
      d.dispose();
    }
  }
);
  cancelBut.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      d.dispose();
    }
  }
);
  d.getContentPane().add(holder,BorderLayout.CENTER);
  d.pack();
  d.setVisible(true);
}

@Override public void actionPerformed(ActionEvent e){
  BeansProperties.VISIBLE_PERSPECTIVES=new TreeSet<String>();
  int[] selected=m_perspectiveConfigurer.getSelectedAttributes();
  for (  int element : selected) {
    String selectedClassName=pClasses.get(element);
    if (m_perspectiveCache.get(selectedClassName) == null) {
      try {
        Object p=Class.forName(selectedClassName).newInstance();
        if (p instanceof KFPerspective && p instanceof JPanel) {
          String title=((KFPerspective)p).getPerspectiveTitle();
          weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"[KnowledgeFlow] loaded perspective: " + title);
          ((KFPerspective)p).setLoaded(true);
          ((KFPerspective)p).setMainKFPerspective(m_mainKFPerspective);
          m_perspectiveCache.put(selectedClassName,(KFPerspective)p);
        }
      }
 catch (      Exception ex) {
        ex.printStackTrace();
      }
    }
    BeansProperties.VISIBLE_PERSPECTIVES.add(selectedClassName);
  }
  setupUserPerspectives();
  d.dispose();
}

@Override public void actionPerformed(ActionEvent e){
  d.dispose();
}

private void setupUserPerspectives(){
  for (int i=m_perspectiveToolBar.getComponentCount() - 1; i > 0; i--) {
    m_perspectiveToolBar.remove(i);
    m_perspectives.remove(i);
  }
  int index=1;
  for (  String c : BeansProperties.VISIBLE_PERSPECTIVES) {
    KFPerspective toAdd=m_perspectiveCache.get(c);
    if (toAdd instanceof JComponent) {
      toAdd.setLoaded(true);
      m_perspectives.add(toAdd);
      String titleM=toAdd.getPerspectiveTitle();
      Icon icon=toAdd.getPerspectiveIcon();
      JToggleButton tBut=null;
      if (icon != null) {
        tBut=new JToggleButton(titleM,icon,false);
      }
 else {
        tBut=new JToggleButton(titleM,false);
      }
      tBut.setToolTipText(toAdd.getPerspectiveTipText());
      final int theIndex=index;
      tBut.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          setActivePerspective(theIndex);
        }
      }
);
      m_perspectiveToolBar.add(tBut);
      m_perspectiveGroup.add(tBut);
      index++;
    }
  }
  KFPerspective current=(KFPerspective)m_perspectiveHolder.getComponent(0);
  if (current != m_mainKFPerspective) {
    current.setActive(false);
    m_perspectiveHolder.remove(0);
    m_perspectiveHolder.add(m_mainKFPerspective);
    ((JToggleButton)m_perspectiveToolBar.getComponent(0)).setSelected(true);
  }
  revalidate();
  repaint();
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  setActivePerspective(theIndex);
}

protected void setActivePerspective(int theIndex){
  if (theIndex < 0 || theIndex > m_perspectives.size() - 1) {
    return;
  }
  KFPerspective current=(KFPerspective)m_perspectiveHolder.getComponent(0);
  current.setActive(false);
  m_perspectiveHolder.remove(0);
  m_perspectiveHolder.add((JComponent)m_perspectives.get(theIndex),BorderLayout.CENTER);
  m_perspectives.get(theIndex).setActive(true);
  ((JToggleButton)m_perspectiveToolBar.getComponent(theIndex)).setSelected(true);
  KnowledgeFlowApp.this.revalidate();
  KnowledgeFlowApp.this.repaint();
  notifyIsDirty();
}

private void snapSelectedToGrid(){
  Vector<Object> v=m_mainKFPerspective.getSelectedBeans();
  if (v.size() > 0) {
    for (int i=0; i < v.size(); i++) {
      BeanInstance b=(BeanInstance)v.get(i);
      int x=b.getX();
      int y=b.getY();
      b.setXY(snapToGrid(x),snapToGrid(y));
    }
    revalidate();
    m_beanLayout.repaint();
    notifyIsDirty();
    m_mainKFPerspective.setEditedStatus(true);
  }
}

private int snapToGrid(int val){
  int r=val % m_gridSpacing;
  val/=m_gridSpacing;
  if (r > (m_gridSpacing / 2)) {
    val++;
  }
  val*=m_gridSpacing;
  return val;
}

private void configureBeanLayout(final BeanLayout layout){
  layout.setLayout(null);
  layout.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent me){
      layout.requestFocusInWindow();
      double z=m_layoutZoom / 100.0;
      double px=me.getX();
      double py=me.getY();
      py/=z;
      px/=z;
      if (m_toolBarBean == null) {
        if (((me.getModifiers() & InputEvent.BUTTON1_MASK) == InputEvent.BUTTON1_MASK) && m_mode == NONE) {
          BeanInstance bi=BeanInstance.findInstance(new Point((int)px,(int)py),m_mainKFPerspective.getCurrentTabIndex());
          JComponent bc=null;
          if (bi != null) {
            bc=(JComponent)(bi.getBean());
          }
          if (bc != null) {
            m_editElement=bi;
            m_oldX=(int)px;
            m_oldY=(int)py;
            m_mode=MOVING;
          }
          if (m_mode != MOVING) {
            m_mode=SELECTING;
            m_oldX=(int)px;
            m_oldY=(int)py;
            m_startX=m_oldX;
            m_startY=m_oldY;
            Graphics2D gx=(Graphics2D)layout.getGraphics();
            gx.setXORMode(java.awt.Color.white);
            gx.dispose();
            m_mode=SELECTING;
          }
        }
      }
    }
    @Override public void mouseReleased(    MouseEvent me){
      layout.requestFocusInWindow();
      if (m_editElement != null && m_mode == MOVING) {
        if (m_snapToGridB.isSelected()) {
          int x=snapToGrid(m_editElement.getX());
          int y=snapToGrid(m_editElement.getY());
          m_editElement.setXY(x,y);
          snapSelectedToGrid();
        }
        m_editElement=null;
        revalidate();
        layout.repaint();
        m_mode=NONE;
      }
      if (m_mode == SELECTING) {
        revalidate();
        layout.repaint();
        m_mode=NONE;
        double z=m_layoutZoom / 100.0;
        double px=me.getX();
        double py=me.getY();
        py/=z;
        px/=z;
        highlightSubFlow(m_startX,m_startY,(int)px,(int)py);
      }
    }
    @Override public void mouseClicked(    MouseEvent me){
      layout.requestFocusInWindow();
      Point p=me.getPoint();
      Point np=new Point();
      double z=m_layoutZoom / 100.0;
      np.setLocation(p.getX() / z,p.getY() / z);
      BeanInstance bi=BeanInstance.findInstance(np,m_mainKFPerspective.getCurrentTabIndex());
      if (m_mode == ADDING || m_mode == NONE) {
        if (bi != null) {
          JComponent bc=(JComponent)bi.getBean();
          if (me.getClickCount() == 2 && !(bc instanceof MetaBean)) {
            try {
              Class<?> custClass=Introspector.getBeanInfo(bc.getClass()).getBeanDescriptor().getCustomizerClass();
              if (custClass != null) {
                if (bc instanceof BeanCommon) {
                  if (!((BeanCommon)bc).isBusy() && !m_mainKFPerspective.getExecuting()) {
                    popupCustomizer(custClass,bc);
                  }
                }
 else {
                  popupCustomizer(custClass,bc);
                }
              }
            }
 catch (            IntrospectionException ex) {
              ex.printStackTrace();
            }
          }
 else           if (((me.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || me.isAltDown()) {
            doPopup(me.getPoint(),bi,(int)(p.getX() / z),(int)(p.getY() / z));
            return;
          }
 else {
            Vector<Object> v=m_mainKFPerspective.getSelectedBeans();
            if (me.isShiftDown()) {
            }
 else {
              v=new Vector<Object>();
            }
            v.add(bi);
            m_mainKFPerspective.setSelectedBeans(v);
            return;
          }
        }
 else {
          if (((me.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || me.isAltDown()) {
            double px=me.getX();
            double py=me.getY();
            py/=z;
            px/=z;
            if (!m_mainKFPerspective.getExecuting()) {
              rightClickCanvasPopup((int)px,(int)py);
              revalidate();
              repaint();
              notifyIsDirty();
            }
            return;
          }
 else           if (m_toolBarBean != null) {
            double x=me.getX();
            double y=me.getY();
            x/=z;
            y/=z;
            if (m_snapToGridB.isSelected()) {
              x=snapToGrid((int)x);
              y=snapToGrid((int)y);
            }
            addUndoPoint();
            if (m_toolBarBean instanceof StringBuffer) {
              pasteFromClipboard((int)x,(int)y,(StringBuffer)m_toolBarBean,false);
              m_mode=NONE;
              KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
              m_toolBarBean=null;
            }
 else {
              addComponent((int)x,(int)y);
            }
            m_componentTree.clearSelection();
            m_mainKFPerspective.setEditedStatus(true);
          }
        }
        revalidate();
        repaint();
        notifyIsDirty();
      }
      double px=me.getX();
      double py=me.getY();
      px/=z;
      py/=z;
      if (m_mode == PASTING && m_pasteBuffer.length() > 0) {
        pasteFromClipboard((int)px,(int)py,m_pasteBuffer,true);
        m_mode=NONE;
        KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
        return;
      }
      if (m_mode == CONNECTING) {
        layout.repaint();
        Vector<Object> beanInstances=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
        for (int i=0; i < beanInstances.size(); i++) {
          JComponent bean=(JComponent)((BeanInstance)beanInstances.elementAt(i)).getBean();
          if (bean instanceof Visible) {
            ((Visible)bean).getVisual().setDisplayConnectors(false);
          }
        }
        if (bi != null) {
          boolean doConnection=false;
          if (!(bi.getBean() instanceof BeanCommon)) {
            doConnection=true;
          }
 else {
            if (((BeanCommon)bi.getBean()).connectionAllowed(m_sourceEventSetDescriptor)) {
              doConnection=true;
            }
          }
          if (doConnection) {
            addUndoPoint();
            if (bi.getBean() instanceof MetaBean) {
              BeanConnection.doMetaConnection(m_editElement,bi,m_sourceEventSetDescriptor,layout,m_mainKFPerspective.getCurrentTabIndex());
            }
 else {
              new BeanConnection(m_editElement,bi,m_sourceEventSetDescriptor,m_mainKFPerspective.getCurrentTabIndex());
            }
            m_mainKFPerspective.setEditedStatus(true);
          }
          layout.repaint();
        }
        m_mode=NONE;
        m_editElement=null;
        m_sourceEventSetDescriptor=null;
      }
      if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
        m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
      }
    }
  }
);
  layout.addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseDragged(    MouseEvent me){
      double z=m_layoutZoom / 100.0;
      double px=me.getX();
      double py=me.getY();
      px/=z;
      py/=z;
      if (m_editElement != null && m_mode == MOVING) {
        int deltaX=(int)px - m_oldX;
        int deltaY=(int)py - m_oldY;
        m_editElement.setXY(m_editElement.getX() + deltaX,m_editElement.getY() + deltaY);
        if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
          Vector<Object> v=m_mainKFPerspective.getSelectedBeans();
          for (int i=0; i < v.size(); i++) {
            BeanInstance b=(BeanInstance)v.get(i);
            if (b != m_editElement) {
              b.setXY(b.getX() + deltaX,b.getY() + deltaY);
            }
          }
        }
        layout.repaint();
        m_oldX=(int)px;
        m_oldY=(int)py;
        m_mainKFPerspective.setEditedStatus(true);
      }
      if (m_mode == SELECTING) {
        layout.repaint();
        m_oldX=(int)px;
        m_oldY=(int)py;
      }
    }
    @Override public void mouseMoved(    MouseEvent e){
      double z=m_layoutZoom / 100.0;
      double px=e.getX();
      double py=e.getY();
      px/=z;
      py/=z;
      if (m_mode == CONNECTING) {
        layout.repaint();
        m_oldX=(int)px;
        m_oldY=(int)py;
      }
    }
  }
);
}

@Override public void mousePressed(MouseEvent me){
  layout.requestFocusInWindow();
  double z=m_layoutZoom / 100.0;
  double px=me.getX();
  double py=me.getY();
  py/=z;
  px/=z;
  if (m_toolBarBean == null) {
    if (((me.getModifiers() & InputEvent.BUTTON1_MASK) == InputEvent.BUTTON1_MASK) && m_mode == NONE) {
      BeanInstance bi=BeanInstance.findInstance(new Point((int)px,(int)py),m_mainKFPerspective.getCurrentTabIndex());
      JComponent bc=null;
      if (bi != null) {
        bc=(JComponent)(bi.getBean());
      }
      if (bc != null) {
        m_editElement=bi;
        m_oldX=(int)px;
        m_oldY=(int)py;
        m_mode=MOVING;
      }
      if (m_mode != MOVING) {
        m_mode=SELECTING;
        m_oldX=(int)px;
        m_oldY=(int)py;
        m_startX=m_oldX;
        m_startY=m_oldY;
        Graphics2D gx=(Graphics2D)layout.getGraphics();
        gx.setXORMode(java.awt.Color.white);
        gx.dispose();
        m_mode=SELECTING;
      }
    }
  }
}

@Override public void mouseReleased(MouseEvent me){
  layout.requestFocusInWindow();
  if (m_editElement != null && m_mode == MOVING) {
    if (m_snapToGridB.isSelected()) {
      int x=snapToGrid(m_editElement.getX());
      int y=snapToGrid(m_editElement.getY());
      m_editElement.setXY(x,y);
      snapSelectedToGrid();
    }
    m_editElement=null;
    revalidate();
    layout.repaint();
    m_mode=NONE;
  }
  if (m_mode == SELECTING) {
    revalidate();
    layout.repaint();
    m_mode=NONE;
    double z=m_layoutZoom / 100.0;
    double px=me.getX();
    double py=me.getY();
    py/=z;
    px/=z;
    highlightSubFlow(m_startX,m_startY,(int)px,(int)py);
  }
}

@Override public void mouseClicked(MouseEvent me){
  layout.requestFocusInWindow();
  Point p=me.getPoint();
  Point np=new Point();
  double z=m_layoutZoom / 100.0;
  np.setLocation(p.getX() / z,p.getY() / z);
  BeanInstance bi=BeanInstance.findInstance(np,m_mainKFPerspective.getCurrentTabIndex());
  if (m_mode == ADDING || m_mode == NONE) {
    if (bi != null) {
      JComponent bc=(JComponent)bi.getBean();
      if (me.getClickCount() == 2 && !(bc instanceof MetaBean)) {
        try {
          Class<?> custClass=Introspector.getBeanInfo(bc.getClass()).getBeanDescriptor().getCustomizerClass();
          if (custClass != null) {
            if (bc instanceof BeanCommon) {
              if (!((BeanCommon)bc).isBusy() && !m_mainKFPerspective.getExecuting()) {
                popupCustomizer(custClass,bc);
              }
            }
 else {
              popupCustomizer(custClass,bc);
            }
          }
        }
 catch (        IntrospectionException ex) {
          ex.printStackTrace();
        }
      }
 else       if (((me.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || me.isAltDown()) {
        doPopup(me.getPoint(),bi,(int)(p.getX() / z),(int)(p.getY() / z));
        return;
      }
 else {
        Vector<Object> v=m_mainKFPerspective.getSelectedBeans();
        if (me.isShiftDown()) {
        }
 else {
          v=new Vector<Object>();
        }
        v.add(bi);
        m_mainKFPerspective.setSelectedBeans(v);
        return;
      }
    }
 else {
      if (((me.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || me.isAltDown()) {
        double px=me.getX();
        double py=me.getY();
        py/=z;
        px/=z;
        if (!m_mainKFPerspective.getExecuting()) {
          rightClickCanvasPopup((int)px,(int)py);
          revalidate();
          repaint();
          notifyIsDirty();
        }
        return;
      }
 else       if (m_toolBarBean != null) {
        double x=me.getX();
        double y=me.getY();
        x/=z;
        y/=z;
        if (m_snapToGridB.isSelected()) {
          x=snapToGrid((int)x);
          y=snapToGrid((int)y);
        }
        addUndoPoint();
        if (m_toolBarBean instanceof StringBuffer) {
          pasteFromClipboard((int)x,(int)y,(StringBuffer)m_toolBarBean,false);
          m_mode=NONE;
          KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
          m_toolBarBean=null;
        }
 else {
          addComponent((int)x,(int)y);
        }
        m_componentTree.clearSelection();
        m_mainKFPerspective.setEditedStatus(true);
      }
    }
    revalidate();
    repaint();
    notifyIsDirty();
  }
  double px=me.getX();
  double py=me.getY();
  px/=z;
  py/=z;
  if (m_mode == PASTING && m_pasteBuffer.length() > 0) {
    pasteFromClipboard((int)px,(int)py,m_pasteBuffer,true);
    m_mode=NONE;
    KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    return;
  }
  if (m_mode == CONNECTING) {
    layout.repaint();
    Vector<Object> beanInstances=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
    for (int i=0; i < beanInstances.size(); i++) {
      JComponent bean=(JComponent)((BeanInstance)beanInstances.elementAt(i)).getBean();
      if (bean instanceof Visible) {
        ((Visible)bean).getVisual().setDisplayConnectors(false);
      }
    }
    if (bi != null) {
      boolean doConnection=false;
      if (!(bi.getBean() instanceof BeanCommon)) {
        doConnection=true;
      }
 else {
        if (((BeanCommon)bi.getBean()).connectionAllowed(m_sourceEventSetDescriptor)) {
          doConnection=true;
        }
      }
      if (doConnection) {
        addUndoPoint();
        if (bi.getBean() instanceof MetaBean) {
          BeanConnection.doMetaConnection(m_editElement,bi,m_sourceEventSetDescriptor,layout,m_mainKFPerspective.getCurrentTabIndex());
        }
 else {
          new BeanConnection(m_editElement,bi,m_sourceEventSetDescriptor,m_mainKFPerspective.getCurrentTabIndex());
        }
        m_mainKFPerspective.setEditedStatus(true);
      }
      layout.repaint();
    }
    m_mode=NONE;
    m_editElement=null;
    m_sourceEventSetDescriptor=null;
  }
  if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
    m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
  }
}

@Override public void mouseDragged(MouseEvent me){
  double z=m_layoutZoom / 100.0;
  double px=me.getX();
  double py=me.getY();
  px/=z;
  py/=z;
  if (m_editElement != null && m_mode == MOVING) {
    int deltaX=(int)px - m_oldX;
    int deltaY=(int)py - m_oldY;
    m_editElement.setXY(m_editElement.getX() + deltaX,m_editElement.getY() + deltaY);
    if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
      Vector<Object> v=m_mainKFPerspective.getSelectedBeans();
      for (int i=0; i < v.size(); i++) {
        BeanInstance b=(BeanInstance)v.get(i);
        if (b != m_editElement) {
          b.setXY(b.getX() + deltaX,b.getY() + deltaY);
        }
      }
    }
    layout.repaint();
    m_oldX=(int)px;
    m_oldY=(int)py;
    m_mainKFPerspective.setEditedStatus(true);
  }
  if (m_mode == SELECTING) {
    layout.repaint();
    m_oldX=(int)px;
    m_oldY=(int)py;
  }
}

@Override public void mouseMoved(MouseEvent e){
  double z=m_layoutZoom / 100.0;
  double px=e.getX();
  double py=e.getY();
  px/=z;
  py/=z;
  if (m_mode == CONNECTING) {
    layout.repaint();
    m_oldX=(int)px;
    m_oldY=(int)py;
  }
}

private void setUpLogPanel(final LogPanel logPanel){
  String date=(new SimpleDateFormat("EEEE, d MMMM yyyy")).format(new Date());
  logPanel.logMessage("Weka Knowledge Flow was written by Mark Hall");
  logPanel.logMessage("Weka Knowledge Flow");
  logPanel.logMessage("(c) 2002-" + Copyright.getToYear() + " "+ Copyright.getOwner()+ ", "+ Copyright.getAddress());
  logPanel.logMessage("web: " + Copyright.getURL());
  logPanel.logMessage(date);
  logPanel.statusMessage("@!@[KnowledgeFlow]|Welcome to the Weka Knowledge Flow");
  logPanel.getStatusTable().addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (logPanel.getStatusTable().rowAtPoint(e.getPoint()) == 0) {
        if (((e.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || e.isAltDown()) {
          System.gc();
          Runtime currR=Runtime.getRuntime();
          long freeM=currR.freeMemory();
          long totalM=currR.totalMemory();
          long maxM=currR.maxMemory();
          logPanel.logMessage("[KnowledgeFlow] Memory (free/total/max.) in bytes: " + String.format("%,d",freeM) + " / "+ String.format("%,d",totalM)+ " / "+ String.format("%,d",maxM));
          logPanel.statusMessage("@!@[KnowledgeFlow]|Memory (free/total/max.) in bytes: " + String.format("%,d",freeM) + " / "+ String.format("%,d",totalM)+ " / "+ String.format("%,d",maxM));
        }
      }
    }
  }
);
}

@Override public void mouseClicked(MouseEvent e){
  if (logPanel.getStatusTable().rowAtPoint(e.getPoint()) == 0) {
    if (((e.getModifiers() & InputEvent.BUTTON1_MASK) != InputEvent.BUTTON1_MASK) || e.isAltDown()) {
      System.gc();
      Runtime currR=Runtime.getRuntime();
      long freeM=currR.freeMemory();
      long totalM=currR.totalMemory();
      long maxM=currR.maxMemory();
      logPanel.logMessage("[KnowledgeFlow] Memory (free/total/max.) in bytes: " + String.format("%,d",freeM) + " / "+ String.format("%,d",totalM)+ " / "+ String.format("%,d",maxM));
      logPanel.statusMessage("@!@[KnowledgeFlow]|Memory (free/total/max.) in bytes: " + String.format("%,d",freeM) + " / "+ String.format("%,d",totalM)+ " / "+ String.format("%,d",maxM));
    }
  }
}

private Image loadImage(String path){
  Image pic=null;
  java.net.URL imageURL=this.getClass().getClassLoader().getResource(path);
  if (imageURL == null) {
    weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"Unable to load " + path);
  }
 else {
    pic=Toolkit.getDefaultToolkit().getImage(imageURL);
  }
  return pic;
}

public RunThread(boolean sequential){
  m_sequential=sequential;
}

@Override public void run(){
  m_flowIndex=m_mainKFPerspective.getCurrentTabIndex();
  String flowName=m_mainKFPerspective.getTabTitle(m_flowIndex);
  m_mainKFPerspective.setExecuting(true);
  m_mainKFPerspective.getLogPanel(m_flowIndex).clearStatus();
  m_mainKFPerspective.getLogPanel(m_flowIndex).statusMessage("@!@[KnowledgeFlow]|Executing...");
  FlowRunner runner=new FlowRunner(false,false);
  runner.setStartSequentially(m_sequential);
  runner.setEnvironment(m_flowEnvironment);
  runner.setLog(m_logPanel);
  Vector<Object> comps=BeanInstance.getBeanInstances(m_flowIndex);
  runner.setFlows(comps);
  try {
    runner.run();
    runner.waitUntilFinished();
  }
 catch (  InterruptedException ie) {
  }
catch (  Exception ex) {
    m_logPanel.logMessage("An error occurred while running the flow: " + ex.getMessage());
  }
 finally {
    if (m_flowIndex >= m_mainKFPerspective.getNumTabs() - 1 || !m_mainKFPerspective.getTabTitle(m_flowIndex).equals(flowName)) {
      for (int i=0; i < m_mainKFPerspective.getNumTabs(); i++) {
        String tabT=m_mainKFPerspective.getTabTitle(i);
        if (tabT != null && tabT.equals(flowName)) {
          m_flowIndex=i;
          break;
        }
      }
    }
    m_mainKFPerspective.setExecuting(m_flowIndex,false);
    m_mainKFPerspective.setExecutionThread(m_flowIndex,null);
    if (m_wasUserStopped) {
      KFLogPanel lp=m_mainKFPerspective.getLogPanel(m_flowIndex);
      lp.setMessageOnAll(false,"Stopped.");
    }
 else {
      m_mainKFPerspective.getLogPanel(m_flowIndex).statusMessage("@!@[KnowledgeFlow]|OK.");
    }
  }
}

public void stopAllFlows(){
  Vector<Object> components=BeanInstance.getBeanInstances(m_flowIndex);
  if (components != null) {
    for (int i=0; i < components.size(); i++) {
      Object temp=((BeanInstance)components.elementAt(i)).getBean();
      if (temp instanceof BeanCommon) {
        ((BeanCommon)temp).stop();
      }
    }
    m_wasUserStopped=true;
  }
}

/** 
 * Run all start-points in a layout in parallel or sequentially. Order of execution is arbitrary if the user has not prefixed the names of the start points with "<num> :" in order to specify the order. In both parallel and sequential mode, a start point can be ommitted from exectution by prefixing its name with "! :".
 * @param sequential true if the flow layout is to have its start points runsequentially rather than in parallel
 */
private void runFlow(final boolean sequential){
  if (m_mainKFPerspective.getNumTabs() > 0) {
    RunThread runThread=new RunThread(sequential);
    m_mainKFPerspective.setExecutionThread(runThread);
    runThread.start();
  }
}

private void stopFlow(){
  if (m_mainKFPerspective.getCurrentTabIndex() >= 0) {
    RunThread running=m_mainKFPerspective.getExecutionThread();
    if (running != null) {
      running.stopAllFlows();
    }
  }
}

private void processPackage(String tempBeanCompName,weka.gui.HierarchyPropertyParser hpp,DefaultMutableTreeNode parentNode,Map<String,DefaultMutableTreeNode> nodeTextIndex){
  if (hpp.isLeafReached()) {
    hpp.goToParent();
    return;
  }
  String[] children=hpp.childrenValues();
  for (  String element : children) {
    hpp.goToChild(element);
    DefaultMutableTreeNode child=null;
    if (hpp.isLeafReached()) {
      String algName=hpp.fullValue();
      Object visibleCheck=instantiateBean(true,tempBeanCompName,algName);
      if (visibleCheck != null) {
        if (visibleCheck instanceof BeanContextChild) {
          m_bcSupport.add(visibleCheck);
        }
        ImageIcon scaledForTree=null;
        if (visibleCheck instanceof Visible) {
          BeanVisual bv=((Visible)visibleCheck).getVisual();
          if (bv != null) {
            scaledForTree=new ImageIcon(bv.scale(0.33));
          }
        }
        String toolTip="";
        try {
          Object wrappedA=Class.forName(algName).newInstance();
          toolTip=getGlobalInfo(wrappedA);
        }
 catch (        Exception ex) {
        }
        JTreeLeafDetails leafData=new JTreeLeafDetails(tempBeanCompName,algName,scaledForTree);
        if (toolTip != null && toolTip.length() > 0) {
          leafData.setToolTipText(toolTip);
        }
        child=new InvisibleNode(leafData);
        nodeTextIndex.put(algName.toLowerCase() + " " + (toolTip != null ? toolTip.toLowerCase() : ""),child);
      }
    }
 else {
      child=new InvisibleNode(element);
    }
    if (child != null) {
      parentNode.add(child);
    }
    processPackage(tempBeanCompName,hpp,child,nodeTextIndex);
  }
  hpp.goToParent();
}

private Object instantiateBean(boolean wekawrapper,String tempBeanCompName,String algName){
  Object tempBean;
  if (wekawrapper) {
    try {
      tempBean=Beans.instantiate(this.getClass().getClassLoader(),tempBeanCompName);
    }
 catch (    Exception ex) {
      weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Failed to instantiate :" + tempBeanCompName + "KnowledgeFlowApp.instantiateBean()");
      return null;
    }
    if (tempBean instanceof WekaWrapper) {
      Class<?> c=null;
      try {
        c=Class.forName(algName);
        for (        Annotation a : c.getAnnotations()) {
          if (a instanceof KFIgnore) {
            return null;
          }
        }
      }
 catch (      Exception ex) {
        weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Can't find class called: " + algName);
        return null;
      }
      try {
        Object o=c.newInstance();
        ((WekaWrapper)tempBean).setWrappedAlgorithm(o);
      }
 catch (      Exception ex) {
        weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Failed to configure " + tempBeanCompName + " with "+ algName);
        return null;
      }
    }
  }
 else {
    try {
      tempBean=Beans.instantiate(this.getClass().getClassLoader(),tempBeanCompName);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
      weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Failed to instantiate :" + tempBeanCompName + "KnowledgeFlowApp.instantiateBean()");
      return null;
    }
  }
  return tempBean;
}

/** 
 * Pop up a help window
 */
private void popupHelp(){
  final JButton tempB=m_helpB;
  try {
    tempB.setEnabled(false);
    InputStream inR=this.getClass().getClassLoader().getResourceAsStream("weka/gui/beans/README_KnowledgeFlow");
    StringBuffer helpHolder=new StringBuffer();
    LineNumberReader lnr=new LineNumberReader(new InputStreamReader(inR));
    String line;
    while ((line=lnr.readLine()) != null) {
      helpHolder.append(line + "\n");
    }
    lnr.close();
    final javax.swing.JFrame jf=new javax.swing.JFrame();
    jf.getContentPane().setLayout(new java.awt.BorderLayout());
    final JTextArea ta=new JTextArea(helpHolder.toString());
    ta.setFont(new Font("Monospaced",Font.PLAIN,12));
    ta.setEditable(false);
    final JScrollPane sp=new JScrollPane(ta);
    jf.getContentPane().add(sp,java.awt.BorderLayout.CENTER);
    jf.addWindowListener(new java.awt.event.WindowAdapter(){
      @Override public void windowClosing(      java.awt.event.WindowEvent e){
        tempB.setEnabled(true);
        jf.dispose();
      }
    }
);
    jf.setSize(600,600);
    jf.setVisible(true);
  }
 catch (  Exception ex) {
    tempB.setEnabled(true);
  }
}

@Override public void windowClosing(java.awt.event.WindowEvent e){
  tempB.setEnabled(true);
  jf.dispose();
}

public void closeAllTabs(){
  for (int i=m_mainKFPerspective.getNumTabs() - 1; i >= 0; i--) {
    m_mainKFPerspective.removeTab(i);
  }
}

public void clearLayout(){
  stopFlow();
  if (m_mainKFPerspective.getNumTabs() == 0 || getAllowMultipleTabs()) {
    m_mainKFPerspective.addTab("Untitled" + m_untitledCount++);
  }
  if (!getAllowMultipleTabs()) {
    BeanConnection.setConnections(new Vector<BeanConnection>(),m_mainKFPerspective.getCurrentTabIndex());
    BeanInstance.setBeanInstances(new Vector<Object>(),m_mainKFPerspective.getBeanLayout(m_mainKFPerspective.getCurrentTabIndex()),m_mainKFPerspective.getCurrentTabIndex());
  }
}

/** 
 * Pops up the menu for selecting template layouts
 */
private void createTemplateMenuPopup(){
  PopupMenu templatesMenu=new PopupMenu();
  for (int i=0; i < BeansProperties.TEMPLATE_PATHS.size(); i++) {
    String mE=BeansProperties.TEMPLATE_DESCRIPTIONS.get(i);
    final String path=BeansProperties.TEMPLATE_PATHS.get(i);
    MenuItem m=new MenuItem(mE);
    m.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent ee){
        try {
          InputStream inR=this.getClass().getClassLoader().getResourceAsStream(path);
          m_mainKFPerspective.addTab("Untitled" + m_untitledCount++);
          XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,m_mainKFPerspective.getCurrentTabIndex());
          InputStreamReader isr=new InputStreamReader(inR);
          @SuppressWarnings("unchecked") Vector<Vector<?>> v=(Vector<Vector<?>>)xml.read(isr);
          @SuppressWarnings("unchecked") Vector<Object> beans=(Vector<Object>)v.get(XMLBeans.INDEX_BEANINSTANCES);
          @SuppressWarnings("unchecked") Vector<BeanConnection> connections=(Vector<BeanConnection>)v.get(XMLBeans.INDEX_BEANCONNECTIONS);
          isr.close();
          integrateFlow(beans,connections,false,false);
          notifyIsDirty();
          revalidate();
        }
 catch (        Exception ex) {
          m_mainKFPerspective.getCurrentLogPanel().logMessage("Problem loading template: " + ex.getMessage());
        }
      }
    }
);
    templatesMenu.add(m);
  }
  m_templatesB.add(templatesMenu);
  templatesMenu.show(m_templatesB,0,0);
}

@Override public void actionPerformed(ActionEvent ee){
  try {
    InputStream inR=this.getClass().getClassLoader().getResourceAsStream(path);
    m_mainKFPerspective.addTab("Untitled" + m_untitledCount++);
    XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,m_mainKFPerspective.getCurrentTabIndex());
    InputStreamReader isr=new InputStreamReader(inR);
    @SuppressWarnings("unchecked") Vector<Vector<?>> v=(Vector<Vector<?>>)xml.read(isr);
    @SuppressWarnings("unchecked") Vector<Object> beans=(Vector<Object>)v.get(XMLBeans.INDEX_BEANINSTANCES);
    @SuppressWarnings("unchecked") Vector<BeanConnection> connections=(Vector<BeanConnection>)v.get(XMLBeans.INDEX_BEANCONNECTIONS);
    isr.close();
    integrateFlow(beans,connections,false,false);
    notifyIsDirty();
    revalidate();
  }
 catch (  Exception ex) {
    m_mainKFPerspective.getCurrentLogPanel().logMessage("Problem loading template: " + ex.getMessage());
  }
}

/** 
 * Popup a context sensitive menu for the bean component
 * @param pt holds the panel coordinates for the component
 * @param bi the bean component over which the user right clicked the mouse
 * @param x the x coordinate at which to popup the menu
 * @param y the y coordinate at which to popup the menuModified by Zerbetto: javax.swing.JPopupMenu transformed into java.awt.PopupMenu
 */
private void doPopup(Point pt,final BeanInstance bi,int x,int y){
  final JComponent bc=(JComponent)bi.getBean();
  final int xx=x;
  final int yy=y;
  int menuItemCount=0;
  PopupMenu beanContextMenu=new PopupMenu();
  boolean executing=m_mainKFPerspective.getExecuting();
  MenuItem edit=new MenuItem("Edit:");
  edit.setEnabled(false);
  beanContextMenu.insert(edit,menuItemCount);
  menuItemCount++;
  if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
    MenuItem copyItem=new MenuItem("Copy");
    copyItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        copyToClipboard();
        m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
      }
    }
);
    beanContextMenu.add(copyItem);
    copyItem.setEnabled(!executing);
    menuItemCount++;
  }
  if (bc instanceof MetaBean) {
    MenuItem ungroupItem=new MenuItem("Ungroup");
    ungroupItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        bi.removeBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
        Vector<Object> group=((MetaBean)bc).getBeansInSubFlow();
        Vector<BeanConnection> associatedConnections=((MetaBean)bc).getAssociatedConnections();
        ((MetaBean)bc).restoreBeans(xx,yy);
        for (int i=0; i < group.size(); i++) {
          BeanInstance tbi=(BeanInstance)group.elementAt(i);
          addComponent(tbi,false);
          tbi.addBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
        }
        for (int i=0; i < associatedConnections.size(); i++) {
          BeanConnection tbc=associatedConnections.elementAt(i);
          tbc.setHidden(false);
        }
        m_beanLayout.repaint();
        m_mainKFPerspective.setEditedStatus(true);
        notifyIsDirty();
      }
    }
);
    ungroupItem.setEnabled(!executing);
    beanContextMenu.add(ungroupItem);
    menuItemCount++;
    MenuItem addToUserTabItem=new MenuItem("Add to user tab");
    addToUserTabItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        addToUserTreeNode(bi,true);
        notifyIsDirty();
      }
    }
);
    addToUserTabItem.setEnabled(!executing);
    beanContextMenu.add(addToUserTabItem);
    menuItemCount++;
  }
  MenuItem deleteItem=new MenuItem("Delete");
  deleteItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      BeanConnection.removeConnections(bi,m_mainKFPerspective.getCurrentTabIndex());
      bi.removeBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
      if (bc instanceof BeanCommon) {
        String key=((BeanCommon)bc).getCustomName() + "$" + bc.hashCode();
        m_logPanel.statusMessage(key + "|remove");
      }
      if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
        deleteSelectedBeans();
      }
      revalidate();
      m_mainKFPerspective.setEditedStatus(true);
      notifyIsDirty();
      m_selectAllB.setEnabled(BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0);
    }
  }
);
  deleteItem.setEnabled(!executing);
  if (bc instanceof BeanCommon) {
    if (((BeanCommon)bc).isBusy()) {
      deleteItem.setEnabled(false);
    }
  }
  beanContextMenu.add(deleteItem);
  menuItemCount++;
  if (bc instanceof BeanCommon) {
    MenuItem nameItem=new MenuItem("Set name");
    nameItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        String oldName=((BeanCommon)bc).getCustomName();
        String name=JOptionPane.showInputDialog(KnowledgeFlowApp.this,"Enter a name for this component",oldName);
        if (name != null) {
          ((BeanCommon)bc).setCustomName(name);
          m_mainKFPerspective.setEditedStatus(true);
        }
      }
    }
);
    if (bc instanceof BeanCommon) {
      if (((BeanCommon)bc).isBusy()) {
        nameItem.setEnabled(false);
      }
    }
    nameItem.setEnabled(!executing);
    beanContextMenu.add(nameItem);
    menuItemCount++;
  }
  try {
    Vector<BeanInfo> compInfo=new Vector<BeanInfo>(1);
    Vector<Object> associatedBeans=null;
    if (bc instanceof MetaBean) {
      compInfo=((MetaBean)bc).getBeanInfoSubFlow();
      associatedBeans=((MetaBean)bc).getBeansInSubFlow();
      ((MetaBean)bc).getBeansInOutputs();
      ((MetaBean)bc).getBeanInfoOutputs();
    }
 else {
      compInfo.add(Introspector.getBeanInfo(bc.getClass()));
    }
    final Vector<Object> tempAssociatedBeans=associatedBeans;
    if (compInfo == null) {
      weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Error in doPopup()");
    }
 else {
      for (int zz=0; zz < compInfo.size(); zz++) {
        final int tt=zz;
        final Class<?> custClass=compInfo.elementAt(zz).getBeanDescriptor().getCustomizerClass();
        if (custClass != null) {
          MenuItem custItem=null;
          boolean customizationEnabled=!executing;
          if (!(bc instanceof MetaBean)) {
            custItem=new MenuItem("Configure...");
            if (bc instanceof BeanCommon) {
              customizationEnabled=(!executing && !((BeanCommon)bc).isBusy());
            }
          }
 else {
            String custName=custClass.getName();
            BeanInstance tbi=(BeanInstance)associatedBeans.elementAt(zz);
            if (tbi.getBean() instanceof BeanCommon) {
              custName=((BeanCommon)tbi.getBean()).getCustomName();
            }
 else {
              if (tbi.getBean() instanceof WekaWrapper) {
                custName=((WekaWrapper)tbi.getBean()).getWrappedAlgorithm().getClass().getName();
              }
 else {
                custName=custName.substring(0,custName.indexOf("Customizer"));
              }
              custName=custName.substring(custName.lastIndexOf('.') + 1,custName.length());
            }
            custItem=new MenuItem("Configure: " + custName);
            if (tbi.getBean() instanceof BeanCommon) {
              customizationEnabled=(!executing && !((BeanCommon)tbi.getBean()).isBusy());
            }
          }
          custItem.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              if (bc instanceof MetaBean) {
                popupCustomizer(custClass,(JComponent)((BeanInstance)tempAssociatedBeans.elementAt(tt)).getBean());
              }
 else {
                popupCustomizer(custClass,bc);
              }
              notifyIsDirty();
            }
          }
);
          custItem.setEnabled(customizationEnabled);
          beanContextMenu.add(custItem);
          menuItemCount++;
        }
 else {
          weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"[KnowledgeFlow] No customizer class");
        }
      }
      Vector<EventSetDescriptor[]> esdV=new Vector<EventSetDescriptor[]>();
      for (int i=0; i < compInfo.size(); i++) {
        EventSetDescriptor[] temp=compInfo.elementAt(i).getEventSetDescriptors();
        if ((temp != null) && (temp.length > 0)) {
          esdV.add(temp);
        }
      }
      if (esdV.size() > 0) {
        MenuItem connections=new MenuItem("Connections:");
        connections.setEnabled(false);
        beanContextMenu.insert(connections,menuItemCount);
        menuItemCount++;
      }
      final Vector<Object> finalOutputs=associatedBeans;
      for (int j=0; j < esdV.size(); j++) {
        final int fj=j;
        String sourceBeanName="";
        if (bc instanceof MetaBean) {
          Object sourceBean=((BeanInstance)associatedBeans.elementAt(j)).getBean();
          if (sourceBean instanceof BeanCommon) {
            sourceBeanName=((BeanCommon)sourceBean).getCustomName();
          }
 else {
            if (sourceBean instanceof WekaWrapper) {
              sourceBeanName=((WekaWrapper)sourceBean).getWrappedAlgorithm().getClass().getName();
            }
 else {
              sourceBeanName=sourceBean.getClass().getName();
            }
            sourceBeanName=sourceBeanName.substring(sourceBeanName.lastIndexOf('.') + 1,sourceBeanName.length());
          }
          sourceBeanName+=": ";
        }
        EventSetDescriptor[] esds=esdV.elementAt(j);
        for (        final EventSetDescriptor esd : esds) {
          MenuItem evntItem=new MenuItem(sourceBeanName + esd.getName());
          boolean ok=true;
          evntItem.setEnabled(!executing);
          if (bc instanceof EventConstraints) {
            ok=((EventConstraints)bc).eventGeneratable(esd.getName());
          }
          if (ok) {
            evntItem.addActionListener(new ActionListener(){
              @Override public void actionPerformed(              ActionEvent e){
                connectComponents(esd,(bc instanceof MetaBean) ? ((BeanInstance)finalOutputs.elementAt(fj)) : bi,xx,yy);
                notifyIsDirty();
              }
            }
);
          }
 else {
            evntItem.setEnabled(false);
          }
          beanContextMenu.add(evntItem);
          menuItemCount++;
        }
      }
    }
  }
 catch (  IntrospectionException ie) {
    ie.printStackTrace();
  }
  if (bc instanceof UserRequestAcceptor || bc instanceof Startable) {
    Enumeration<String> req=null;
    if (bc instanceof UserRequestAcceptor) {
      req=((UserRequestAcceptor)bc).enumerateRequests();
    }
    if ((req != null && req.hasMoreElements())) {
      MenuItem actions=new MenuItem("Actions:");
      actions.setEnabled(false);
      beanContextMenu.insert(actions,menuItemCount);
      menuItemCount++;
    }
    while (req != null && req.hasMoreElements()) {
      String tempS=req.nextElement();
      insertUserOrStartableMenuItem(bc,false,tempS,beanContextMenu);
      menuItemCount++;
    }
  }
  if (bc instanceof weka.gui.beans.Loader && m_perspectives.size() > 1 && m_perspectiveDataLoadThread == null) {
    final weka.core.converters.Loader theLoader=((weka.gui.beans.Loader)bc).getLoader();
    boolean ok=true;
    if (theLoader instanceof FileSourcedConverter) {
      String fileName=((FileSourcedConverter)theLoader).retrieveFile().getPath();
      Environment env=m_mainKFPerspective.getEnvironmentSettings();
      try {
        fileName=env.substitute(fileName);
      }
 catch (      Exception ex) {
      }
      File tempF=new File(fileName);
      String fileNameFixedPathSep=fileName.replace(File.separatorChar,'/');
      if (!tempF.isFile() && this.getClass().getClassLoader().getResource(fileNameFixedPathSep) == null) {
        ok=false;
      }
    }
    if (ok) {
      beanContextMenu.addSeparator();
      menuItemCount++;
      if (m_perspectives.size() > 2) {
        MenuItem sendToAllPerspectives=new MenuItem("Send to all perspectives");
        menuItemCount++;
        sendToAllPerspectives.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            loadDataAndSendToPerspective(theLoader,0,true);
          }
        }
);
        beanContextMenu.add(sendToAllPerspectives);
      }
      Menu sendToPerspective=new Menu("Send to perspective...");
      beanContextMenu.add(sendToPerspective);
      menuItemCount++;
      for (int i=1; i < m_perspectives.size(); i++) {
        final int pIndex=i;
        if (m_perspectives.get(i).acceptsInstances()) {
          String pName=m_perspectives.get(i).getPerspectiveTitle();
          MenuItem pI=new MenuItem(pName);
          pI.addActionListener(new ActionListener(){
            @Override public void actionPerformed(            ActionEvent e){
              loadDataAndSendToPerspective(theLoader,pIndex,false);
            }
          }
);
          sendToPerspective.add(pI);
        }
      }
    }
  }
  if (menuItemCount > 0) {
    double z=m_layoutZoom / 100.0;
    double px=x * z;
    double py=y * z;
    m_beanLayout.add(beanContextMenu);
    beanContextMenu.show(m_beanLayout,(int)px,(int)py);
  }
}

@Override public void actionPerformed(ActionEvent e){
  copyToClipboard();
  m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
}

@Override public void actionPerformed(ActionEvent e){
  bi.removeBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
  Vector<Object> group=((MetaBean)bc).getBeansInSubFlow();
  Vector<BeanConnection> associatedConnections=((MetaBean)bc).getAssociatedConnections();
  ((MetaBean)bc).restoreBeans(xx,yy);
  for (int i=0; i < group.size(); i++) {
    BeanInstance tbi=(BeanInstance)group.elementAt(i);
    addComponent(tbi,false);
    tbi.addBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
  }
  for (int i=0; i < associatedConnections.size(); i++) {
    BeanConnection tbc=associatedConnections.elementAt(i);
    tbc.setHidden(false);
  }
  m_beanLayout.repaint();
  m_mainKFPerspective.setEditedStatus(true);
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  addToUserTreeNode(bi,true);
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  BeanConnection.removeConnections(bi,m_mainKFPerspective.getCurrentTabIndex());
  bi.removeBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
  if (bc instanceof BeanCommon) {
    String key=((BeanCommon)bc).getCustomName() + "$" + bc.hashCode();
    m_logPanel.statusMessage(key + "|remove");
  }
  if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
    deleteSelectedBeans();
  }
  revalidate();
  m_mainKFPerspective.setEditedStatus(true);
  notifyIsDirty();
  m_selectAllB.setEnabled(BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0);
}

@Override public void actionPerformed(ActionEvent e){
  String oldName=((BeanCommon)bc).getCustomName();
  String name=JOptionPane.showInputDialog(KnowledgeFlowApp.this,"Enter a name for this component",oldName);
  if (name != null) {
    ((BeanCommon)bc).setCustomName(name);
    m_mainKFPerspective.setEditedStatus(true);
  }
}

@Override public void actionPerformed(ActionEvent e){
  if (bc instanceof MetaBean) {
    popupCustomizer(custClass,(JComponent)((BeanInstance)tempAssociatedBeans.elementAt(tt)).getBean());
  }
 else {
    popupCustomizer(custClass,bc);
  }
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  connectComponents(esd,(bc instanceof MetaBean) ? ((BeanInstance)finalOutputs.elementAt(fj)) : bi,xx,yy);
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  loadDataAndSendToPerspective(theLoader,0,true);
}

@Override public void actionPerformed(ActionEvent e){
  loadDataAndSendToPerspective(theLoader,pIndex,false);
}

private synchronized void loadDataAndSendToPerspective(final weka.core.converters.Loader loader,final int perspectiveIndex,final boolean sendToAll){
  if (m_perspectiveDataLoadThread == null) {
    m_perspectiveDataLoadThread=new Thread(){
      @Override public void run(){
        try {
          Environment env=m_mainKFPerspective.getEnvironmentSettings();
          if (loader instanceof EnvironmentHandler) {
            ((EnvironmentHandler)loader).setEnvironment(env);
          }
          loader.reset();
          m_logPanel.statusMessage("@!@[KnowledgeFlow]|Sending data to perspective(s)...");
          Instances data=loader.getDataSet();
          if (data != null) {
            if (!m_configAndPerspectivesVisible) {
              KnowledgeFlowApp.this.add(m_configAndPerspectives,BorderLayout.NORTH);
              m_configAndPerspectivesVisible=true;
            }
            for (int i=0; i < m_perspectives.size(); i++) {
              m_perspectiveToolBar.getComponent(i).setEnabled(false);
            }
            if (sendToAll) {
              for (int i=1; i < m_perspectives.size(); i++) {
                if (m_perspectives.get(i).acceptsInstances()) {
                  m_perspectives.get(i).setInstances(data);
                }
              }
            }
 else {
              KFPerspective currentP=(KFPerspective)m_perspectiveHolder.getComponent(0);
              if (currentP != m_perspectives.get(perspectiveIndex)) {
                m_perspectives.get(perspectiveIndex).setInstances(data);
                currentP.setActive(false);
                m_perspectiveHolder.remove(0);
                m_perspectiveHolder.add((JComponent)m_perspectives.get(perspectiveIndex),BorderLayout.CENTER);
                m_perspectives.get(perspectiveIndex).setActive(true);
                ((JToggleButton)m_perspectiveToolBar.getComponent(perspectiveIndex)).setSelected(true);
                KnowledgeFlowApp.this.revalidate();
                KnowledgeFlowApp.this.repaint();
                notifyIsDirty();
              }
            }
          }
        }
 catch (        Exception ex) {
          weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] problem loading data for " + "perspective(s) : " + ex.getMessage());
          ex.printStackTrace();
        }
 finally {
          for (int i=0; i < m_perspectives.size(); i++) {
            m_perspectiveToolBar.getComponent(i).setEnabled(true);
          }
          m_perspectiveDataLoadThread=null;
          m_logPanel.statusMessage("@!@[KnowledgeFlow]|OK");
        }
      }
    }
;
    m_perspectiveDataLoadThread.setPriority(Thread.MIN_PRIORITY);
    m_perspectiveDataLoadThread.start();
  }
}

@Override public void run(){
  try {
    Environment env=m_mainKFPerspective.getEnvironmentSettings();
    if (loader instanceof EnvironmentHandler) {
      ((EnvironmentHandler)loader).setEnvironment(env);
    }
    loader.reset();
    m_logPanel.statusMessage("@!@[KnowledgeFlow]|Sending data to perspective(s)...");
    Instances data=loader.getDataSet();
    if (data != null) {
      if (!m_configAndPerspectivesVisible) {
        KnowledgeFlowApp.this.add(m_configAndPerspectives,BorderLayout.NORTH);
        m_configAndPerspectivesVisible=true;
      }
      for (int i=0; i < m_perspectives.size(); i++) {
        m_perspectiveToolBar.getComponent(i).setEnabled(false);
      }
      if (sendToAll) {
        for (int i=1; i < m_perspectives.size(); i++) {
          if (m_perspectives.get(i).acceptsInstances()) {
            m_perspectives.get(i).setInstances(data);
          }
        }
      }
 else {
        KFPerspective currentP=(KFPerspective)m_perspectiveHolder.getComponent(0);
        if (currentP != m_perspectives.get(perspectiveIndex)) {
          m_perspectives.get(perspectiveIndex).setInstances(data);
          currentP.setActive(false);
          m_perspectiveHolder.remove(0);
          m_perspectiveHolder.add((JComponent)m_perspectives.get(perspectiveIndex),BorderLayout.CENTER);
          m_perspectives.get(perspectiveIndex).setActive(true);
          ((JToggleButton)m_perspectiveToolBar.getComponent(perspectiveIndex)).setSelected(true);
          KnowledgeFlowApp.this.revalidate();
          KnowledgeFlowApp.this.repaint();
          notifyIsDirty();
        }
      }
    }
  }
 catch (  Exception ex) {
    weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] problem loading data for " + "perspective(s) : " + ex.getMessage());
    ex.printStackTrace();
  }
 finally {
    for (int i=0; i < m_perspectives.size(); i++) {
      m_perspectiveToolBar.getComponent(i).setEnabled(true);
    }
    m_perspectiveDataLoadThread=null;
    m_logPanel.statusMessage("@!@[KnowledgeFlow]|OK");
  }
}

private void insertUserOrStartableMenuItem(final JComponent bc,final boolean startable,String tempS,PopupMenu beanContextMenu){
  boolean disabled=false;
  boolean confirmRequest=false;
  if (tempS.charAt(0) == '$') {
    tempS=tempS.substring(1,tempS.length());
    disabled=true;
  }
  if (tempS.charAt(0) == '?') {
    tempS=tempS.substring(1,tempS.length());
    confirmRequest=true;
  }
  final String tempS2=tempS;
  MenuItem custItem=new MenuItem(tempS2);
  if (confirmRequest) {
    custItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        int result=JOptionPane.showConfirmDialog(KnowledgeFlowApp.this,tempS2,"Confirm action",JOptionPane.YES_NO_OPTION);
        if (result == JOptionPane.YES_OPTION) {
          Thread startPointThread=new Thread(){
            @Override public void run(){
              try {
                if (startable) {
                  ((Startable)bc).start();
                }
 else                 if (bc instanceof UserRequestAcceptor) {
                  ((UserRequestAcceptor)bc).performRequest(tempS2);
                }
                notifyIsDirty();
              }
 catch (              Exception ex) {
                ex.printStackTrace();
              }
            }
          }
;
          startPointThread.setPriority(Thread.MIN_PRIORITY);
          startPointThread.start();
        }
      }
    }
);
  }
 else {
    custItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        Thread startPointThread=new Thread(){
          @Override public void run(){
            try {
              if (startable) {
                ((Startable)bc).start();
              }
 else               if (bc instanceof UserRequestAcceptor) {
                ((UserRequestAcceptor)bc).performRequest(tempS2);
              }
              notifyIsDirty();
            }
 catch (            Exception ex) {
              ex.printStackTrace();
            }
          }
        }
;
        startPointThread.setPriority(Thread.MIN_PRIORITY);
        startPointThread.start();
      }
    }
);
  }
  if (disabled) {
    custItem.setEnabled(false);
  }
  beanContextMenu.add(custItem);
}

@Override public void actionPerformed(ActionEvent e){
  int result=JOptionPane.showConfirmDialog(KnowledgeFlowApp.this,tempS2,"Confirm action",JOptionPane.YES_NO_OPTION);
  if (result == JOptionPane.YES_OPTION) {
    Thread startPointThread=new Thread(){
      @Override public void run(){
        try {
          if (startable) {
            ((Startable)bc).start();
          }
 else           if (bc instanceof UserRequestAcceptor) {
            ((UserRequestAcceptor)bc).performRequest(tempS2);
          }
          notifyIsDirty();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
;
    startPointThread.setPriority(Thread.MIN_PRIORITY);
    startPointThread.start();
  }
}

@Override public void run(){
  try {
    if (startable) {
      ((Startable)bc).start();
    }
 else     if (bc instanceof UserRequestAcceptor) {
      ((UserRequestAcceptor)bc).performRequest(tempS2);
    }
    notifyIsDirty();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}

@Override public void actionPerformed(ActionEvent e){
  Thread startPointThread=new Thread(){
    @Override public void run(){
      try {
        if (startable) {
          ((Startable)bc).start();
        }
 else         if (bc instanceof UserRequestAcceptor) {
          ((UserRequestAcceptor)bc).performRequest(tempS2);
        }
        notifyIsDirty();
      }
 catch (      Exception ex) {
        ex.printStackTrace();
      }
    }
  }
;
  startPointThread.setPriority(Thread.MIN_PRIORITY);
  startPointThread.start();
}

@Override public void run(){
  try {
    if (startable) {
      ((Startable)bc).start();
    }
 else     if (bc instanceof UserRequestAcceptor) {
      ((UserRequestAcceptor)bc).performRequest(tempS2);
    }
    notifyIsDirty();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}

/** 
 * Tells us about the modified status of a particular object - typically a customizer that is editing a flow component. Allows us to set the modified flag for the current flow.
 */
@Override public void setModifiedStatus(Object source,boolean modified){
  if (source instanceof BeanCustomizer && modified) {
    m_mainKFPerspective.setEditedStatus(modified);
  }
}

/** 
 * Popup the customizer for this bean
 * @param custClass the class of the customizer
 * @param bc the bean to be customized
 */
private void popupCustomizer(Class<?> custClass,JComponent bc){
  try {
    final Object customizer=custClass.newInstance();
    if (customizer instanceof EnvironmentHandler) {
      ((EnvironmentHandler)customizer).setEnvironment(m_flowEnvironment);
    }
    if (customizer instanceof BeanCustomizer) {
      ((BeanCustomizer)customizer).setModifiedListener(this);
    }
    ((Customizer)customizer).setObject(bc);
    final JDialog d=new JDialog((java.awt.Frame)KnowledgeFlowApp.this.getTopLevelAncestor(),ModalityType.DOCUMENT_MODAL);
    d.setLayout(new BorderLayout());
    d.getContentPane().add((JComponent)customizer,BorderLayout.CENTER);
    if (customizer instanceof CustomizerCloseRequester) {
      ((CustomizerCloseRequester)customizer).setParentWindow(d);
    }
    d.addWindowListener(new java.awt.event.WindowAdapter(){
      @Override public void windowClosing(      java.awt.event.WindowEvent e){
        if (customizer instanceof CustomizerClosingListener) {
          ((CustomizerClosingListener)customizer).customizerClosing();
        }
        d.dispose();
      }
    }
);
    d.pack();
    d.setLocationRelativeTo(KnowledgeFlowApp.this);
    d.setVisible(true);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}

@Override public void windowClosing(java.awt.event.WindowEvent e){
  if (customizer instanceof CustomizerClosingListener) {
    ((CustomizerClosingListener)customizer).customizerClosing();
  }
  d.dispose();
}

private void addToUserTreeNode(BeanInstance meta,boolean installListener){
  DefaultTreeModel model=(DefaultTreeModel)m_componentTree.getModel();
  DefaultMutableTreeNode root=(DefaultMutableTreeNode)model.getRoot();
  if (m_userCompNode == null) {
    m_userCompNode=new InvisibleNode("User");
    model.insertNodeInto(m_userCompNode,root,0);
  }
  Vector<Object> beanHolder=new Vector<Object>();
  beanHolder.add(meta);
  try {
    StringBuffer serialized=copyToBuffer(beanHolder);
    String displayName="";
    ImageIcon scaledIcon=null;
    if (meta.getBean() instanceof Visible) {
      scaledIcon=new ImageIcon(((Visible)meta.getBean()).getVisual().scale(0.33));
      displayName=((Visible)meta.getBean()).getVisual().getText();
    }
    Vector<Object> metaDetails=new Vector<Object>();
    metaDetails.add(displayName);
    metaDetails.add(serialized);
    metaDetails.add(scaledIcon);
    SerializedObject so=new SerializedObject(metaDetails);
    @SuppressWarnings("unchecked") Vector<Object> copy=(Vector<Object>)so.getObject();
    JTreeLeafDetails metaLeaf=new JTreeLeafDetails(displayName,copy,scaledIcon);
    DefaultMutableTreeNode newUserComp=new InvisibleNode(metaLeaf);
    model.insertNodeInto(newUserComp,m_userCompNode,0);
    m_userComponents.add(copy);
    if (installListener && m_firstUserComponentOpp) {
      try {
        installWindowListenerForSavingUserStuff();
        m_firstUserComponentOpp=false;
      }
 catch (      Exception ex) {
        ex.printStackTrace();
      }
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}

/** 
 * Set the contents of the "paste" buffer and enable the paste from cliboard toolbar button
 * @param b the buffer to use
 */
public void setPasteBuffer(StringBuffer b){
  m_pasteBuffer=b;
  if (m_pasteBuffer != null && m_pasteBuffer.length() > 0) {
    m_pasteB.setEnabled(true);
  }
}

/** 
 * Get the contents of the paste buffer
 * @return the contents of the paste buffer
 */
public StringBuffer getPasteBuffer(){
  return m_pasteBuffer;
}

/** 
 * Utility routine that serializes the supplied Vector of BeanInstances to XML
 * @param selectedBeans the vector of BeanInstances to serialize
 * @return a StringBuffer containing the serialized vector
 * @throws Exception if a problem occurs
 */
public StringBuffer copyToBuffer(Vector<Object> selectedBeans) throws Exception {
  Vector<BeanConnection> associatedConnections=BeanConnection.getConnections(m_mainKFPerspective.getCurrentTabIndex());
  Vector<Vector<?>> v=new Vector<Vector<?>>();
  v.setSize(2);
  v.set(XMLBeans.INDEX_BEANINSTANCES,selectedBeans);
  v.set(XMLBeans.INDEX_BEANCONNECTIONS,associatedConnections);
  XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,m_mainKFPerspective.getCurrentTabIndex());
  java.io.StringWriter sw=new java.io.StringWriter();
  xml.write(sw,v);
  return sw.getBuffer();
}

private boolean copyToClipboard(){
  Vector<Object> selectedBeans=m_mainKFPerspective.getSelectedBeans();
  if (selectedBeans == null || selectedBeans.size() == 0) {
    return false;
  }
  try {
    m_pasteBuffer=copyToBuffer(selectedBeans);
  }
 catch (  Exception ex) {
    m_logPanel.logMessage("[KnowledgeFlow] problem copying beans: " + ex.getMessage());
    ex.printStackTrace();
    return false;
  }
  m_pasteB.setEnabled(true);
  revalidate();
  repaint();
  notifyIsDirty();
  return true;
}

protected boolean pasteFromBuffer(int x,int y,StringBuffer pasteBuffer,boolean addUndoPoint){
  if (addUndoPoint) {
    addUndoPoint();
  }
  java.io.StringReader sr=new java.io.StringReader(pasteBuffer.toString());
  try {
    XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,m_mainKFPerspective.getCurrentTabIndex());
    @SuppressWarnings("unchecked") Vector<Vector<?>> v=(Vector<Vector<?>>)xml.read(sr);
    @SuppressWarnings("unchecked") Vector<Object> beans=(Vector<Object>)v.get(XMLBeans.INDEX_BEANINSTANCES);
    @SuppressWarnings("unchecked") Vector<BeanConnection> connections=(Vector<BeanConnection>)v.get(XMLBeans.INDEX_BEANCONNECTIONS);
    for (int i=0; i < beans.size(); i++) {
      BeanInstance b=(BeanInstance)beans.get(i);
      if (b.getBean() instanceof MetaBean) {
        Vector<Object> subFlow=((MetaBean)b.getBean()).getSubFlow();
        for (int j=0; j < subFlow.size(); j++) {
          BeanInstance subB=(BeanInstance)subFlow.get(j);
          subB.removeBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
          if (subB.getBean() instanceof Visible) {
            ((Visible)subB.getBean()).getVisual().removePropertyChangeListener(this);
          }
        }
      }
    }
    int minX=Integer.MAX_VALUE;
    int minY=Integer.MAX_VALUE;
    boolean adjust=false;
    for (int i=0; i < beans.size(); i++) {
      BeanInstance b=(BeanInstance)beans.get(i);
      if (b.getX() < minX) {
        minX=b.getX();
        adjust=true;
      }
      if (b.getY() < minY) {
        minY=b.getY();
        adjust=true;
      }
    }
    if (adjust) {
      int deltaX=x - minX;
      int deltaY=y - minY;
      for (int i=0; i < beans.size(); i++) {
        BeanInstance b=(BeanInstance)beans.get(i);
        b.setXY(b.getX() + deltaX,b.getY() + deltaY);
      }
    }
    integrateFlow(beans,connections,false,false);
    for (int i=0; i < beans.size(); i++) {
      checkForDuplicateName((BeanInstance)beans.get(i));
    }
    setEnvironment();
    notifyIsDirty();
    m_mainKFPerspective.setSelectedBeans(beans);
  }
 catch (  Exception e) {
    m_logPanel.logMessage("[KnowledgeFlow] problem pasting beans: " + e.getMessage());
    e.printStackTrace();
  }
  revalidate();
  notifyIsDirty();
  return true;
}

private boolean pasteFromClipboard(int x,int y,StringBuffer pasteBuffer,boolean addUndoPoint){
  return pasteFromBuffer(x,y,pasteBuffer,addUndoPoint);
}

private void deleteSelectedBeans(){
  Vector<Object> v=m_mainKFPerspective.getSelectedBeans();
  if (v.size() > 0) {
    m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
  }
  addUndoPoint();
  for (int i=0; i < v.size(); i++) {
    BeanInstance b=(BeanInstance)v.get(i);
    BeanConnection.removeConnections(b,m_mainKFPerspective.getCurrentTabIndex());
    b.removeBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
    if (b instanceof BeanCommon) {
      String key=((BeanCommon)b).getCustomName() + "$" + b.hashCode();
      m_logPanel.statusMessage(key + "|remove");
    }
  }
  m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
  revalidate();
  notifyIsDirty();
  m_selectAllB.setEnabled(BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0);
}

private void addUndoPoint(){
  try {
    Stack<File> undo=m_mainKFPerspective.getUndoBuffer();
    File tempFile=File.createTempFile("knowledgeFlow",FILE_EXTENSION_XML);
    tempFile.deleteOnExit();
    if (saveLayout(tempFile,m_mainKFPerspective.getCurrentTabIndex(),true)) {
      undo.push(tempFile);
      if (undo.size() > 20) {
        undo.remove(0);
      }
      m_undoB.setEnabled(true);
    }
  }
 catch (  Exception ex) {
    m_logPanel.logMessage("[KnowledgeFlow] a problem occurred while trying to " + "create a undo point : " + ex.getMessage());
  }
}

private boolean groupable(Vector<Object> selected,Vector<Object> inputs,Vector<Object> outputs){
  boolean groupable=true;
  if (inputs.size() == 0 || outputs.size() == 0) {
    return false;
  }
  for (int i=0; i < selected.size(); i++) {
    BeanInstance temp=(BeanInstance)selected.elementAt(i);
    if (temp.getBean() instanceof MetaBean) {
      groupable=false;
      return false;
    }
  }
  for (int i=0; i < inputs.size(); i++) {
    BeanInstance temp=(BeanInstance)inputs.elementAt(i);
    if (temp.getBean() instanceof Visible) {
      ((Visible)temp.getBean()).getVisual().setDisplayConnectors(true,java.awt.Color.red);
    }
  }
  for (int i=0; i < outputs.size(); i++) {
    BeanInstance temp=(BeanInstance)outputs.elementAt(i);
    if (temp.getBean() instanceof Visible) {
      ((Visible)temp.getBean()).getVisual().setDisplayConnectors(true,java.awt.Color.green);
    }
  }
  return groupable;
}

private void rightClickCanvasPopup(final int x,final int y){
  Vector<BeanConnection> closestConnections=BeanConnection.getClosestConnections(new Point(x,y),10,m_mainKFPerspective.getCurrentTabIndex());
  PopupMenu rightClickMenu=new PopupMenu();
  int menuItemCount=0;
  if (m_mainKFPerspective.getSelectedBeans().size() > 0 || closestConnections.size() > 0 || (m_pasteBuffer != null && m_pasteBuffer.length() > 0)) {
    if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
      MenuItem snapItem=new MenuItem("Snap selected to grid");
      snapItem.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          snapSelectedToGrid();
        }
      }
);
      rightClickMenu.add(snapItem);
      menuItemCount++;
      MenuItem copyItem=new MenuItem("Copy selected");
      copyItem.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          copyToClipboard();
          m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
        }
      }
);
      rightClickMenu.add(copyItem);
      menuItemCount++;
      MenuItem cutItem=new MenuItem("Cut selected");
      cutItem.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          if (copyToClipboard()) {
            deleteSelectedBeans();
          }
        }
      }
);
      rightClickMenu.add(cutItem);
      menuItemCount++;
      MenuItem deleteSelected=new MenuItem("Delete selected");
      deleteSelected.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          deleteSelectedBeans();
        }
      }
);
      rightClickMenu.add(deleteSelected);
      menuItemCount++;
      final Vector<Object> selected=m_mainKFPerspective.getSelectedBeans();
      final Vector<Object> inputs=BeanConnection.inputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      final Vector<Object> outputs=BeanConnection.outputs(selected,m_mainKFPerspective.getCurrentTabIndex());
      boolean groupable=groupable(selected,inputs,outputs);
      if (groupable) {
        MenuItem groupItem=new MenuItem("Group selected");
        groupItem.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            groupSubFlow(selected,inputs,outputs);
          }
        }
);
        rightClickMenu.add(groupItem);
        menuItemCount++;
      }
    }
    if (m_pasteBuffer != null && m_pasteBuffer.length() > 0) {
      rightClickMenu.addSeparator();
      menuItemCount++;
      MenuItem pasteItem=new MenuItem("Paste");
      pasteItem.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          pasteFromClipboard(x,y,m_pasteBuffer,true);
        }
      }
);
      rightClickMenu.add(pasteItem);
      menuItemCount++;
    }
    if (closestConnections.size() > 0) {
      rightClickMenu.addSeparator();
      menuItemCount++;
      MenuItem deleteConnection=new MenuItem("Delete Connection:");
      deleteConnection.setEnabled(false);
      rightClickMenu.insert(deleteConnection,menuItemCount);
      menuItemCount++;
      for (int i=0; i < closestConnections.size(); i++) {
        final BeanConnection bc=closestConnections.elementAt(i);
        String connName=bc.getSourceEventSetDescriptor().getName();
        String targetName="";
        if (bc.getTarget().getBean() instanceof BeanCommon) {
          targetName=((BeanCommon)bc.getTarget().getBean()).getCustomName();
        }
 else {
          targetName=bc.getTarget().getBean().getClass().getName();
          targetName=targetName.substring(targetName.lastIndexOf('.') + 1,targetName.length());
        }
        MenuItem deleteItem=new MenuItem(connName + "-->" + targetName);
        deleteItem.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent e){
            addUndoPoint();
            bc.remove(m_mainKFPerspective.getCurrentTabIndex());
            m_beanLayout.revalidate();
            m_beanLayout.repaint();
            m_mainKFPerspective.setEditedStatus(true);
            if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
              m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
            }
            notifyIsDirty();
          }
        }
);
        rightClickMenu.add(deleteItem);
        menuItemCount++;
      }
    }
  }
  if (menuItemCount > 0) {
    rightClickMenu.addSeparator();
    menuItemCount++;
  }
  MenuItem noteItem=new MenuItem("New note");
  noteItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Note n=new Note();
      m_toolBarBean=n;
      KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
      m_mode=ADDING;
    }
  }
);
  rightClickMenu.add(noteItem);
  menuItemCount++;
  m_beanLayout.add(rightClickMenu);
  double z=m_layoutZoom / 100.0;
  double px=x * z;
  double py=y * z;
  rightClickMenu.show(m_beanLayout,(int)px,(int)py);
}

@Override public void actionPerformed(ActionEvent e){
  snapSelectedToGrid();
}

@Override public void actionPerformed(ActionEvent e){
  copyToClipboard();
  m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
}

@Override public void actionPerformed(ActionEvent e){
  if (copyToClipboard()) {
    deleteSelectedBeans();
  }
}

@Override public void actionPerformed(ActionEvent e){
  deleteSelectedBeans();
}

@Override public void actionPerformed(ActionEvent e){
  groupSubFlow(selected,inputs,outputs);
}

@Override public void actionPerformed(ActionEvent e){
  pasteFromClipboard(x,y,m_pasteBuffer,true);
}

@Override public void actionPerformed(ActionEvent e){
  addUndoPoint();
  bc.remove(m_mainKFPerspective.getCurrentTabIndex());
  m_beanLayout.revalidate();
  m_beanLayout.repaint();
  m_mainKFPerspective.setEditedStatus(true);
  if (m_mainKFPerspective.getSelectedBeans().size() > 0) {
    m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
  }
  notifyIsDirty();
}

@Override public void actionPerformed(ActionEvent e){
  Note n=new Note();
  m_toolBarBean=n;
  KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
  m_mode=ADDING;
}

/** 
 * Initiates the connection process for two beans
 * @param esd the EventSetDescriptor for the source bean
 * @param bi the source bean
 * @param x the x coordinate to start connecting from
 * @param y the y coordinate to start connecting from
 */
private void connectComponents(EventSetDescriptor esd,BeanInstance bi,int x,int y){
  if (m_mainKFPerspective.getSelectedBeans(m_mainKFPerspective.getCurrentTabIndex()).size() > 0) {
    m_mainKFPerspective.setSelectedBeans(m_mainKFPerspective.getCurrentTabIndex(),new Vector<Object>());
  }
  m_sourceEventSetDescriptor=esd;
  Class<?> listenerClass=esd.getListenerType();
  JComponent source=(JComponent)bi.getBean();
  int targetCount=0;
  Vector<Object> beanInstances=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
  for (int i=0; i < beanInstances.size(); i++) {
    JComponent bean=(JComponent)((BeanInstance)beanInstances.elementAt(i)).getBean();
    boolean connectable=false;
    boolean canContinue=false;
    if (bean != source) {
      if (bean instanceof MetaBean) {
        if (((MetaBean)bean).canAcceptConnection(listenerClass)) {
          canContinue=true;
        }
      }
 else       if (listenerClass.isInstance(bean) && bean != source) {
        canContinue=true;
      }
    }
    if (canContinue) {
      if (!(bean instanceof BeanCommon)) {
        connectable=true;
      }
 else {
        if (((BeanCommon)bean).connectionAllowed(esd)) {
          connectable=true;
        }
      }
      if (connectable) {
        if (bean instanceof Visible) {
          targetCount++;
          ((Visible)bean).getVisual().setDisplayConnectors(true);
        }
      }
    }
  }
  if (targetCount > 0) {
    if (source instanceof Visible) {
      ((Visible)source).getVisual().setDisplayConnectors(true);
      m_editElement=bi;
      Point closest=((Visible)source).getVisual().getClosestConnectorPoint(new Point(x,y));
      m_startX=(int)closest.getX();
      m_startY=(int)closest.getY();
      m_oldX=m_startX;
      m_oldY=m_startY;
      Graphics2D gx=(Graphics2D)m_beanLayout.getGraphics();
      gx.setXORMode(java.awt.Color.white);
      gx.drawLine(m_startX,m_startY,m_startX,m_startY);
      gx.dispose();
      m_mode=CONNECTING;
    }
  }
  revalidate();
  repaint();
  notifyIsDirty();
}

private void checkForDuplicateName(BeanInstance comp){
  if (comp.getBean() instanceof BeanCommon) {
    String currentName=((BeanCommon)comp.getBean()).getCustomName();
    if (currentName != null && currentName.length() > 0) {
      Vector<Object> layoutBeans=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
      boolean exactMatch=false;
      int maxCopyNum=1;
      for (int i=0; i < layoutBeans.size(); i++) {
        BeanInstance b=(BeanInstance)layoutBeans.get(i);
        if (b.getBean() instanceof BeanCommon) {
          String compName=((BeanCommon)b.getBean()).getCustomName();
          if (currentName.equals(compName) && (b.getBean() != comp.getBean())) {
            exactMatch=true;
          }
 else {
            if (compName.startsWith(currentName)) {
              String num=compName.replace(currentName,"");
              try {
                int compNum=Integer.parseInt(num);
                if (compNum > maxCopyNum) {
                  maxCopyNum=compNum;
                }
              }
 catch (              NumberFormatException e) {
              }
            }
          }
        }
      }
      if (exactMatch) {
        maxCopyNum++;
        currentName+="" + maxCopyNum;
        ((BeanCommon)comp.getBean()).setCustomName(currentName);
      }
    }
  }
}

private void addComponent(BeanInstance comp,boolean repaint){
  if (comp.getBean() instanceof Visible) {
    ((Visible)comp.getBean()).getVisual().addPropertyChangeListener(this);
  }
  if (comp.getBean() instanceof BeanCommon) {
    ((BeanCommon)comp.getBean()).setLog(m_logPanel);
  }
  if (comp.getBean() instanceof MetaBean) {
    Vector<Object> list;
    list=((MetaBean)comp.getBean()).getInputs();
    for (int i=0; i < list.size(); i++) {
      ((BeanInstance)list.get(i)).setX(comp.getX());
      ((BeanInstance)list.get(i)).setY(comp.getY());
    }
    list=((MetaBean)comp.getBean()).getOutputs();
    for (int i=0; i < list.size(); i++) {
      ((BeanInstance)list.get(i)).setX(comp.getX());
      ((BeanInstance)list.get(i)).setY(comp.getY());
    }
  }
  if (comp.getBean() instanceof EnvironmentHandler) {
    ((EnvironmentHandler)comp.getBean()).setEnvironment(m_flowEnvironment);
  }
  checkForDuplicateName(comp);
  KnowledgeFlowApp.this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
  if (repaint) {
    m_beanLayout.repaint();
  }
  m_pointerB.setSelected(true);
  m_mode=NONE;
  m_selectAllB.setEnabled(BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0);
}

private void addComponent(int x,int y){
  if (m_toolBarBean instanceof MetaBean) {
    Vector<BeanConnection> associatedConnections=((MetaBean)m_toolBarBean).getAssociatedConnections();
    BeanConnection.getConnections(m_mainKFPerspective.getCurrentTabIndex()).addAll(associatedConnections);
    ((MetaBean)m_toolBarBean).addPropertyChangeListenersSubFlow(KnowledgeFlowApp.this);
  }
  if (m_toolBarBean instanceof BeanContextChild) {
    m_bcSupport.add(m_toolBarBean);
  }
  BeanInstance bi=new BeanInstance(m_beanLayout,m_toolBarBean,x,y,m_mainKFPerspective.getCurrentTabIndex());
  m_toolBarBean=null;
  addComponent(bi,true);
}

private void highlightSubFlow(int startX,int startY,int endX,int endY){
  java.awt.Rectangle r=new java.awt.Rectangle((startX < endX) ? startX : endX,(startY < endY) ? startY : endY,Math.abs(startX - endX),Math.abs(startY - endY));
  Vector<Object> selected=BeanInstance.findInstances(r,m_mainKFPerspective.getCurrentTabIndex());
  m_mainKFPerspective.setSelectedBeans(selected);
}

private void groupSubFlow(Vector<Object> selected,Vector<Object> inputs,Vector<Object> outputs){
  int upperLeftX=Integer.MAX_VALUE;
  int upperLeftY=Integer.MAX_VALUE;
  int lowerRightX=Integer.MIN_VALUE;
  int lowerRightY=Integer.MIN_VALUE;
  for (int i=0; i < selected.size(); i++) {
    BeanInstance b=(BeanInstance)selected.get(i);
    if (b.getX() < upperLeftX) {
      upperLeftX=b.getX();
    }
    if (b.getY() < upperLeftY) {
      upperLeftY=b.getY();
    }
    if (b.getX() > lowerRightX) {
      lowerRightX=b.getX();
    }
    if (b.getY() > lowerRightY) {
      lowerRightY=b.getY();
    }
  }
  int bx=upperLeftX + ((lowerRightX - upperLeftX) / 2);
  int by=upperLeftY + ((lowerRightY - upperLeftY) / 2);
  new java.awt.Rectangle(upperLeftX,upperLeftY,lowerRightX,lowerRightY);
  int result=JOptionPane.showConfirmDialog(KnowledgeFlowApp.this,"Group this sub-flow?","Group Components",JOptionPane.YES_NO_OPTION);
  if (result == JOptionPane.YES_OPTION) {
    Vector<BeanConnection> associatedConnections=BeanConnection.associatedConnections(selected,m_mainKFPerspective.getCurrentTabIndex());
    String name=JOptionPane.showInputDialog(KnowledgeFlowApp.this,"Enter a name for this group","MyGroup");
    if (name != null) {
      MetaBean group=new MetaBean();
      group.setSubFlow(selected);
      group.setAssociatedConnections(associatedConnections);
      group.setInputs(inputs);
      group.setOutputs(outputs);
      if (name.length() > 0) {
        group.setCustomName(name);
      }
      if (group instanceof BeanContextChild) {
        m_bcSupport.add(group);
      }
      Dimension d=group.getPreferredSize();
      ;
      int dx=(int)(d.getWidth() / 2);
      int dy=(int)(d.getHeight() / 2);
      BeanInstance bi=new BeanInstance(m_beanLayout,group,bx + dx,by + dy,m_mainKFPerspective.getCurrentTabIndex());
      for (int i=0; i < selected.size(); i++) {
        BeanInstance temp=(BeanInstance)selected.elementAt(i);
        temp.removeBean(m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
        if (temp.getBean() instanceof Visible) {
          ((Visible)temp.getBean()).getVisual().removePropertyChangeListener(this);
        }
      }
      for (int i=0; i < associatedConnections.size(); i++) {
        BeanConnection temp=associatedConnections.elementAt(i);
        temp.setHidden(true);
      }
      group.shiftBeans(bi,true);
      addComponent(bi,true);
    }
  }
  for (int i=0; i < selected.size(); i++) {
    BeanInstance temp=(BeanInstance)selected.elementAt(i);
    if (temp.getBean() instanceof Visible) {
      ((Visible)temp.getBean()).getVisual().setDisplayConnectors(false);
    }
  }
  m_mainKFPerspective.setSelectedBeans(new Vector<Object>());
  revalidate();
  notifyIsDirty();
}

/** 
 * Accept property change events
 * @param e a <code>PropertyChangeEvent</code> value
 */
@Override public void propertyChange(PropertyChangeEvent e){
  revalidate();
  m_beanLayout.repaint();
}

/** 
 * Load a pre-saved layout
 */
private void loadLayout(){
  m_loadB.setEnabled(false);
  m_saveB.setEnabled(false);
  m_playB.setEnabled(false);
  m_playBB.setEnabled(false);
  int returnVal=m_FileChooser.showOpenDialog(this);
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    File oFile=m_FileChooser.getSelectedFile();
    if (m_FileChooser.getFileFilter() == m_KfFilter) {
      if (!oFile.getName().toLowerCase().endsWith(FILE_EXTENSION)) {
        oFile=new File(oFile.getParent(),oFile.getName() + FILE_EXTENSION);
      }
    }
 else     if (m_FileChooser.getFileFilter() == m_KOMLFilter) {
      if (!oFile.getName().toLowerCase().endsWith(KOML.FILE_EXTENSION + "kf")) {
        oFile=new File(oFile.getParent(),oFile.getName() + KOML.FILE_EXTENSION + "kf");
      }
    }
 else     if (m_FileChooser.getFileFilter() == m_XMLFilter) {
      if (!oFile.getName().toLowerCase().endsWith(FILE_EXTENSION_XML)) {
        oFile=new File(oFile.getParent(),oFile.getName() + FILE_EXTENSION_XML);
      }
    }
 else     if (m_FileChooser.getFileFilter() == m_XStreamFilter) {
      if (!oFile.getName().toLowerCase().endsWith(XStream.FILE_EXTENSION + "kf")) {
        oFile=new File(oFile.getParent(),oFile.getName() + XStream.FILE_EXTENSION + "kf");
      }
    }
    String flowName=oFile.getName();
    if (flowName.lastIndexOf('.') > 0) {
      flowName=flowName.substring(0,flowName.lastIndexOf('.'));
    }
    loadLayout(oFile,getAllowMultipleTabs());
  }
  m_loadB.setEnabled(true);
  m_playB.setEnabled(true);
  m_playBB.setEnabled(true);
  m_saveB.setEnabled(true);
}

/** 
 * Load a layout from a file. Supports loading binary and XML serialized flow files
 * @param oFile the file to load from
 * @param newTab true if the loaded layout should be displayed in a new tab
 */
public void loadLayout(File oFile,boolean newTab){
  loadLayout(oFile,newTab,false);
}

/** 
 * Load a layout from a file
 * @param oFile the file to load from
 * @param newTab true if the loaded layout should be displayed in a new tab
 * @param isUndo is this file an "undo" file?
 */
@SuppressWarnings("unchecked") protected void loadLayout(File oFile,boolean newTab,boolean isUndo){
  if (!newTab) {
    stopFlow();
  }
  m_loadB.setEnabled(false);
  m_saveB.setEnabled(false);
  m_playB.setEnabled(false);
  m_playBB.setEnabled(false);
  if (newTab) {
    String flowName=oFile.getName();
    if (flowName.lastIndexOf('.') > 0) {
      flowName=flowName.substring(0,flowName.lastIndexOf('.'));
    }
    m_mainKFPerspective.addTab(flowName);
    m_mainKFPerspective.setFlowFile(oFile);
    m_mainKFPerspective.setEditedStatus(false);
  }
  if (!isUndo) {
    File absolute=new File(oFile.getAbsolutePath());
    m_mainKFPerspective.getEnvironmentSettings().addVariable("Internal.knowledgeflow.directory",absolute.getParent());
  }
  try {
    Vector<Object> beans=new Vector<Object>();
    Vector<BeanConnection> connections=new Vector<BeanConnection>();
    if ((KOML.isPresent()) && (oFile.getAbsolutePath().toLowerCase().endsWith(KOML.FILE_EXTENSION + "kf"))) {
      Vector<Vector<?>> v=(Vector<Vector<?>>)KOML.read(oFile.getAbsolutePath());
      beans=(Vector<Object>)v.get(XMLBeans.INDEX_BEANINSTANCES);
      connections=(Vector<BeanConnection>)v.get(XMLBeans.INDEX_BEANCONNECTIONS);
    }
 else     if ((XStream.isPresent()) && (oFile.getAbsolutePath().toLowerCase().endsWith(XStream.FILE_EXTENSION + "kf"))) {
      Vector<Vector<?>> v=(Vector<Vector<?>>)XStream.read(oFile.getAbsolutePath());
      beans=(Vector<Object>)v.get(XMLBeans.INDEX_BEANINSTANCES);
      connections=(Vector<BeanConnection>)v.get(XMLBeans.INDEX_BEANCONNECTIONS);
    }
 else     if (oFile.getAbsolutePath().toLowerCase().endsWith(FILE_EXTENSION_XML)) {
      XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,m_mainKFPerspective.getCurrentTabIndex());
      Vector<Vector<?>> v=(Vector<Vector<?>>)xml.read(oFile);
      beans=(Vector<Object>)v.get(XMLBeans.INDEX_BEANINSTANCES);
      connections=(Vector<BeanConnection>)v.get(XMLBeans.INDEX_BEANCONNECTIONS);
    }
 else {
      InputStream is=new FileInputStream(oFile);
      ObjectInputStream ois=new ObjectInputStream(is);
      beans=(Vector<Object>)ois.readObject();
      connections=(Vector<BeanConnection>)ois.readObject();
      ois.close();
    }
    integrateFlow(beans,connections,true,false);
    setEnvironment();
    if (newTab) {
      m_logPanel.clearStatus();
      m_logPanel.statusMessage("@!@[KnowledgeFlow]|Flow loaded.");
    }
  }
 catch (  Exception ex) {
    m_logPanel.statusMessage("@!@[KnowledgeFlow]|Unable to load flow (see log).");
    m_logPanel.logMessage("[KnowledgeFlow] Unable to load flow (" + ex.getMessage() + ").");
    ex.printStackTrace();
  }
  m_loadB.setEnabled(true);
  m_saveB.setEnabled(true);
  m_playB.setEnabled(true);
  m_playBB.setEnabled(true);
}

/** 
 * Load a flow file from an input stream. Only supports XML serialized flows.
 * @param is the input stream to laod from
 * @param newTab whether to open a new tab in the UI for the flow
 * @param flowName the name of the flow
 * @throws Exception if a problem occurs during de-serialization
 */
public void loadLayout(InputStream is,boolean newTab,String flowName) throws Exception {
  InputStreamReader isr=new InputStreamReader(is);
  loadLayout(isr,newTab,flowName);
}

/** 
 * Load a flow file from a reader. Only supports XML serialized flows.
 * @param reader the reader to load from
 * @param newTab whether to open a new tab in the UI for the flow
 * @param flowName the name of the flow
 * @throws Exception if a problem occurs during de-serialization
 */
@SuppressWarnings("unchecked") public void loadLayout(Reader reader,boolean newTab,String flowName) throws Exception {
  if (!newTab) {
    stopFlow();
  }
  m_loadB.setEnabled(false);
  m_saveB.setEnabled(false);
  m_playB.setEnabled(false);
  m_playBB.setEnabled(false);
  if (newTab) {
    m_mainKFPerspective.addTab(flowName);
    m_mainKFPerspective.setEditedStatus(false);
  }
  XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,m_mainKFPerspective.getCurrentTabIndex());
  Vector<Vector<?>> v=(Vector<Vector<?>>)xml.read(reader);
  Vector<Object> beans=(Vector<Object>)v.get(XMLBeans.INDEX_BEANINSTANCES);
  Vector<BeanConnection> connections=(Vector<BeanConnection>)v.get(XMLBeans.INDEX_BEANCONNECTIONS);
  integrateFlow(beans,connections,true,false);
  setEnvironment();
  if (newTab) {
    m_logPanel.clearStatus();
    m_logPanel.statusMessage("@!@[KnowledgeFlow]|Flow loaded.");
  }
  m_loadB.setEnabled(true);
  m_saveB.setEnabled(true);
  m_playB.setEnabled(true);
  m_playBB.setEnabled(true);
}

protected void integrateFlow(Vector<Object> beans,Vector<BeanConnection> connections,boolean replace,boolean notReplaceAndSourcedFromBinary){
  java.awt.Color bckC=getBackground();
  m_bcSupport=new BeanContextSupport();
  m_bcSupport.setDesignTime(true);
  for (int i=0; i < beans.size(); i++) {
    BeanInstance tempB=(BeanInstance)beans.elementAt(i);
    if (tempB.getBean() instanceof Visible) {
      ((Visible)(tempB.getBean())).getVisual().addPropertyChangeListener(this);
      ((Visible)(tempB.getBean())).getVisual().setBackground(bckC);
      ((JComponent)(tempB.getBean())).setBackground(bckC);
    }
    if (tempB.getBean() instanceof BeanCommon) {
      ((BeanCommon)(tempB.getBean())).setLog(m_logPanel);
    }
    if (tempB.getBean() instanceof BeanContextChild) {
      m_bcSupport.add(tempB.getBean());
    }
  }
  if (replace) {
    BeanInstance.setBeanInstances(beans,m_beanLayout,m_mainKFPerspective.getCurrentTabIndex());
    BeanConnection.setConnections(connections,m_mainKFPerspective.getCurrentTabIndex());
  }
 else   if (notReplaceAndSourcedFromBinary) {
    BeanInstance.appendBeans(m_beanLayout,beans,m_mainKFPerspective.getCurrentTabIndex());
    BeanConnection.appendConnections(connections,m_mainKFPerspective.getCurrentTabIndex());
  }
  revalidate();
  m_beanLayout.revalidate();
  m_beanLayout.repaint();
  notifyIsDirty();
  m_selectAllB.setEnabled(BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex()).size() > 0);
}

/** 
 * Set the flow for the KnowledgeFlow to edit. Assumes that client has loaded a Vector of beans and a Vector of connections. the supplied beans and connections are deep-copied via serialization before being set in the layout. The beans get added to the flow at position 0.
 * @param v a Vector containing a Vector of beans and a Vector of connections
 * @exception Exception if something goes wrong
 */
@SuppressWarnings("unchecked") public void setFlow(Vector<Vector<?>> v) throws Exception {
  if (getAllowMultipleTabs()) {
    throw new Exception("[KnowledgeFlow] setFlow() - can only set a flow in " + "singe tab only mode");
  }
  m_beanLayout.removeAll();
  BeanInstance.init();
  BeanConnection.init();
  SerializedObject so=new SerializedObject(v);
  Vector<Vector<?>> copy=(Vector<Vector<?>>)so.getObject();
  Vector<Object> beans=(Vector<Object>)copy.elementAt(0);
  Vector<BeanConnection> connections=(Vector<BeanConnection>)copy.elementAt(1);
  m_flowEnvironment=new Environment();
  integrateFlow(beans,connections,true,false);
  revalidate();
  notifyIsDirty();
}

/** 
 * Gets the current flow being edited. The flow is returned as a single Vector containing two other Vectors: the beans and the connections. These two vectors are deep-copied via serialization before being returned.
 * @return the current flow being edited
 * @throws Exception if a problem occurs
 */
public Vector<Vector<?>> getFlow() throws Exception {
  Vector<Vector<?>> v=new Vector<Vector<?>>();
  Vector<Object> beans=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
  Vector<BeanConnection> connections=BeanConnection.getConnections(m_mainKFPerspective.getCurrentTabIndex());
  detachFromLayout(beans);
  v.add(beans);
  v.add(connections);
  SerializedObject so=new SerializedObject(v);
  @SuppressWarnings("unchecked") Vector<Vector<?>> copy=(Vector<Vector<?>>)so.getObject();
  integrateFlow(beans,connections,true,false);
  return copy;
}

/** 
 * Returns the current flow being edited in XML format.
 * @return the current flow as an XML string
 * @throws Exception if a problem occurs
 */
public String getFlowXML() throws Exception {
  Vector<Object> beans=BeanInstance.getBeanInstances(m_mainKFPerspective.getCurrentTabIndex());
  StringBuffer buff=copyToBuffer(beans);
  return buff.toString();
}

/** 
 * Utility method to create an image of a region of the given component
 * @param component the component to create an image of
 * @param region the region of the component to put into the image
 * @return the image
 * @throws IOException
 */
protected static BufferedImage createImage(JComponent component,Rectangle region) throws IOException {
  boolean opaqueValue=component.isOpaque();
  component.setOpaque(true);
  BufferedImage image=new BufferedImage(region.width,region.height,BufferedImage.TYPE_INT_RGB);
  Graphics2D g2d=image.createGraphics();
  g2d.translate(-region.getX(),-region.getY());
  component.paint(g2d);
  g2d.dispose();
  component.setOpaque(opaqueValue);
  return image;
}

private void detachFromLayout(Vector<Object> beans){
  for (int i=0; i < beans.size(); i++) {
    BeanInstance tempB=(BeanInstance)beans.elementAt(i);
    if (tempB.getBean() instanceof Visible) {
      ((Visible)(tempB.getBean())).getVisual().removePropertyChangeListener(this);
      if (tempB.getBean() instanceof MetaBean) {
        ((MetaBean)tempB.getBean()).removePropertyChangeListenersSubFlow(this);
      }
      ((Visible)(tempB.getBean())).getVisual().setBackground(java.awt.Color.white);
      ((JComponent)(tempB.getBean())).setBackground(java.awt.Color.white);
    }
  }
}

public void saveLayout(File toFile,int tabIndex){
  saveLayout(toFile,tabIndex,false);
}

protected boolean saveLayout(File sFile,int tabIndex,boolean isUndoPoint){
  java.awt.Color bckC=getBackground();
  Vector<Object> beans=BeanInstance.getBeanInstances(tabIndex);
  detachFromLayout(beans);
  detachFromLayout(beans);
  try {
    if ((KOML.isPresent()) && (sFile.getAbsolutePath().toLowerCase().endsWith(KOML.FILE_EXTENSION + "kf"))) {
      Vector<Vector<?>> v=new Vector<Vector<?>>();
      v.setSize(2);
      v.set(XMLBeans.INDEX_BEANINSTANCES,beans);
      v.set(XMLBeans.INDEX_BEANCONNECTIONS,BeanConnection.getConnections(tabIndex));
      KOML.write(sFile.getAbsolutePath(),v);
    }
 else     if ((XStream.isPresent()) && (sFile.getAbsolutePath().toLowerCase().endsWith(XStream.FILE_EXTENSION + "kf"))) {
      Vector<Vector<?>> v=new Vector<Vector<?>>();
      v.setSize(2);
      v.set(XMLBeans.INDEX_BEANINSTANCES,beans);
      v.set(XMLBeans.INDEX_BEANCONNECTIONS,BeanConnection.getConnections(tabIndex));
      XStream.write(sFile.getAbsolutePath(),v);
    }
 else     if (sFile.getAbsolutePath().toLowerCase().endsWith(FILE_EXTENSION_XML)) {
      Vector<Vector<?>> v=new Vector<Vector<?>>();
      v.setSize(2);
      v.set(XMLBeans.INDEX_BEANINSTANCES,beans);
      v.set(XMLBeans.INDEX_BEANCONNECTIONS,BeanConnection.getConnections(tabIndex));
      XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,tabIndex);
      BufferedWriter br=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(sFile),"UTF-8"));
      xml.write(br,v);
    }
 else {
      OutputStream os=new FileOutputStream(sFile);
      ObjectOutputStream oos=new ObjectOutputStream(os);
      oos.writeObject(beans);
      oos.writeObject(BeanConnection.getConnections(tabIndex));
      oos.flush();
      oos.close();
    }
  }
 catch (  Exception ex) {
    m_logPanel.statusMessage("@!@[KnowledgeFlow]|Unable to save flow (see log).");
    m_logPanel.logMessage("[KnowledgeFlow] Unable to save flow (" + ex.getMessage() + ").");
    ex.printStackTrace();
    return false;
  }
 finally {
    for (int i=0; i < beans.size(); i++) {
      BeanInstance tempB=(BeanInstance)beans.elementAt(i);
      if (tempB.getBean() instanceof Visible) {
        ((Visible)(tempB.getBean())).getVisual().addPropertyChangeListener(this);
        if (tempB.getBean() instanceof MetaBean) {
          ((MetaBean)tempB.getBean()).addPropertyChangeListenersSubFlow(this);
        }
        ((Visible)(tempB.getBean())).getVisual().setBackground(bckC);
        ((JComponent)(tempB.getBean())).setBackground(bckC);
      }
    }
    if (!isUndoPoint) {
      Environment e=m_mainKFPerspective.getEnvironmentSettings(tabIndex);
      e.addVariable("Internal.knowledgeflow.directory",new File(sFile.getAbsolutePath()).getParent());
      m_mainKFPerspective.setEditedStatus(tabIndex,false);
      String tabTitle=sFile.getName();
      tabTitle=tabTitle.substring(0,tabTitle.lastIndexOf('.'));
      m_mainKFPerspective.setTabTitle(tabIndex,tabTitle);
    }
  }
  return true;
}

/** 
 * Serialize the layout to a file
 */
private void saveLayout(int tabIndex,boolean showDialog){
  getBackground();
  File sFile=m_mainKFPerspective.getFlowFile(tabIndex);
  int returnVal=JFileChooser.APPROVE_OPTION;
  boolean shownDialog=false;
  if (showDialog || sFile.getName().equals("-NONE-")) {
    returnVal=m_FileChooser.showSaveDialog(this);
    shownDialog=true;
  }
  if (returnVal == JFileChooser.APPROVE_OPTION) {
    Vector<Object> beans=BeanInstance.getBeanInstances(tabIndex);
    detachFromLayout(beans);
    if (shownDialog) {
      sFile=m_FileChooser.getSelectedFile();
    }
    if (m_FileChooser.getFileFilter() == m_KfFilter) {
      if (!sFile.getName().toLowerCase().endsWith(FILE_EXTENSION)) {
        sFile=new File(sFile.getParent(),sFile.getName() + FILE_EXTENSION);
      }
    }
 else     if (m_FileChooser.getFileFilter() == m_KOMLFilter) {
      if (!sFile.getName().toLowerCase().endsWith(KOML.FILE_EXTENSION + "kf")) {
        sFile=new File(sFile.getParent(),sFile.getName() + KOML.FILE_EXTENSION + "kf");
      }
    }
 else     if (m_FileChooser.getFileFilter() == m_XStreamFilter) {
      if (!sFile.getName().toLowerCase().endsWith(XStream.FILE_EXTENSION + "kf")) {
        sFile=new File(sFile.getParent(),sFile.getName() + XStream.FILE_EXTENSION + "kf");
      }
    }
 else     if (m_FileChooser.getFileFilter() == m_XMLFilter) {
      if (!sFile.getName().toLowerCase().endsWith(FILE_EXTENSION_XML)) {
        sFile=new File(sFile.getParent(),sFile.getName() + FILE_EXTENSION_XML);
      }
    }
    saveLayout(sFile,m_mainKFPerspective.getCurrentTabIndex(),false);
    m_mainKFPerspective.setFlowFile(tabIndex,sFile);
  }
}

/** 
 * Save the knowledge flow into the OutputStream passed at input. Only supports saving the layout data (no trained models) to XML.
 * @param out the output stream to save the layout in
 */
public void saveLayout(OutputStream out,int tabIndex){
  Vector<Object> beans=BeanInstance.getBeanInstances(tabIndex);
  for (int i=0; i < beans.size(); i++) {
    BeanInstance tempB=(BeanInstance)beans.elementAt(i);
    if (tempB.getBean() instanceof Visible) {
      ((Visible)(tempB.getBean())).getVisual().removePropertyChangeListener(this);
      if (tempB.getBean() instanceof MetaBean) {
        ((MetaBean)tempB.getBean()).removePropertyChangeListenersSubFlow(this);
      }
    }
  }
  try {
    Vector<Vector<?>> v=new Vector<Vector<?>>();
    v.setSize(2);
    v.set(XMLBeans.INDEX_BEANINSTANCES,beans);
    v.set(XMLBeans.INDEX_BEANCONNECTIONS,BeanConnection.getConnections(tabIndex));
    XMLBeans xml=new XMLBeans(m_beanLayout,m_bcSupport,tabIndex);
    xml.write(out,v);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
 finally {
    for (int i=0; i < beans.size(); i++) {
      BeanInstance tempB=(BeanInstance)beans.elementAt(i);
      if (tempB.getBean() instanceof Visible) {
        ((Visible)(tempB.getBean())).getVisual().addPropertyChangeListener(this);
        if (tempB.getBean() instanceof MetaBean) {
          ((MetaBean)tempB.getBean()).addPropertyChangeListenersSubFlow(this);
        }
      }
    }
  }
}

@SuppressWarnings("unchecked") private void loadUserComponents(){
  Vector<Vector<Object>> tempV=null;
  File sFile=new File(weka.core.WekaPackageManager.WEKA_HOME.getPath() + File.separator + "knowledgeFlow"+ File.separator+ "userComponents");
  if (sFile.exists()) {
    try {
      InputStream is=new FileInputStream(sFile);
      ObjectInputStream ois=new ObjectInputStream(is);
      tempV=(Vector<Vector<Object>>)ois.readObject();
      ois.close();
    }
 catch (    Exception ex) {
      weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Problem reading user components.");
      ex.printStackTrace();
      return;
    }
    if (tempV.size() > 0) {
      DefaultTreeModel model=(DefaultTreeModel)m_componentTree.getModel();
      DefaultMutableTreeNode root=(DefaultMutableTreeNode)model.getRoot();
      if (m_userCompNode == null) {
        m_userCompNode=new InvisibleNode("User");
        model.insertNodeInto(m_userCompNode,root,0);
      }
      for (int i=0; i < tempV.size(); i++) {
        Vector<Object> tempB=tempV.elementAt(i);
        String displayName=(String)tempB.get(0);
        tempB.get(1);
        ImageIcon scaledIcon=(ImageIcon)tempB.get(2);
        JTreeLeafDetails treeLeaf=new JTreeLeafDetails(displayName,tempB,scaledIcon);
        DefaultMutableTreeNode newUserComp=new InvisibleNode(treeLeaf);
        model.insertNodeInto(newUserComp,m_userCompNode,0);
        m_userComponents.add(tempB);
      }
    }
  }
}

private void installWindowListenerForSavingUserStuff(){
  ((java.awt.Window)getTopLevelAncestor()).addWindowListener(new java.awt.event.WindowAdapter(){
    @Override public void windowClosing(    java.awt.event.WindowEvent e){
      weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"[KnowledgeFlow] Saving user components....");
      File sFile=new File(WekaPackageManager.WEKA_HOME.getPath() + File.separator + "knowledgeFlow");
      if (!sFile.exists()) {
        if (!sFile.mkdir()) {
          weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Unable to create \"" + sFile.getPath() + "\" directory");
        }
      }
      try {
        String ext="";
        File sFile2=new File(sFile.getAbsolutePath() + File.separator + "userComponents"+ ext);
        OutputStream os=new FileOutputStream(sFile2);
        ObjectOutputStream oos=new ObjectOutputStream(os);
        oos.writeObject(m_userComponents);
        oos.flush();
        oos.close();
      }
 catch (      Exception ex) {
        weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Unable to save user components");
        ex.printStackTrace();
      }
      weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"Saving preferences for selected perspectives...");
      sFile=new File(weka.core.WekaPackageManager.PROPERTIES_DIR.toString() + File.separator + "VisiblePerspectives.props");
      try {
        FileWriter f=new FileWriter(sFile);
        f.write("weka.gui.beans.KnowledgeFlow.SelectedPerspectives=");
        int i=0;
        for (        String p : BeansProperties.VISIBLE_PERSPECTIVES) {
          if (i > 0) {
            f.write(",");
          }
          f.write(p);
          i++;
        }
        f.write("\n");
        f.write("weka.gui.beans.KnowledgeFlow.PerspectiveToolBarVisisble=" + ((m_configAndPerspectivesVisible) ? "yes" : "no"));
        f.write("\n");
        f.close();
      }
 catch (      Exception ex) {
        weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Unable to save user perspectives preferences");
        ex.printStackTrace();
      }
    }
  }
);
}

@Override public void windowClosing(java.awt.event.WindowEvent e){
  weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"[KnowledgeFlow] Saving user components....");
  File sFile=new File(WekaPackageManager.WEKA_HOME.getPath() + File.separator + "knowledgeFlow");
  if (!sFile.exists()) {
    if (!sFile.mkdir()) {
      weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Unable to create \"" + sFile.getPath() + "\" directory");
    }
  }
  try {
    String ext="";
    File sFile2=new File(sFile.getAbsolutePath() + File.separator + "userComponents"+ ext);
    OutputStream os=new FileOutputStream(sFile2);
    ObjectOutputStream oos=new ObjectOutputStream(os);
    oos.writeObject(m_userComponents);
    oos.flush();
    oos.close();
  }
 catch (  Exception ex) {
    weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Unable to save user components");
    ex.printStackTrace();
  }
  weka.core.logging.Logger.log(weka.core.logging.Logger.Level.INFO,"Saving preferences for selected perspectives...");
  sFile=new File(weka.core.WekaPackageManager.PROPERTIES_DIR.toString() + File.separator + "VisiblePerspectives.props");
  try {
    FileWriter f=new FileWriter(sFile);
    f.write("weka.gui.beans.KnowledgeFlow.SelectedPerspectives=");
    int i=0;
    for (    String p : BeansProperties.VISIBLE_PERSPECTIVES) {
      if (i > 0) {
        f.write(",");
      }
      f.write(p);
      i++;
    }
    f.write("\n");
    f.write("weka.gui.beans.KnowledgeFlow.PerspectiveToolBarVisisble=" + ((m_configAndPerspectivesVisible) ? "yes" : "no"));
    f.write("\n");
    f.close();
  }
 catch (  Exception ex) {
    weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] Unable to save user perspectives preferences");
    ex.printStackTrace();
  }
}

/** 
 * Utility method for grabbing the global info help (if it exists) from an arbitrary object
 * @param tempBean the object to grab global info from
 * @return the global help info or null if global info does not exist
 */
public static String getGlobalInfo(Object tempBean){
  return Utils.getGlobalInfo(tempBean,true);
}

/** 
 * Create the singleton instance of the KnowledgeFlow
 * @param args can contain a file argument for loading a flow layout (format:"file=[path to layout file]") Modified by Zerbetto: you can specify the path of a knowledge flow layout file at input
 */
public static void createSingleton(String[] args){
  String fileName=null;
  boolean showFileMenu=true;
  if ((args != null) && (args.length > 0)) {
    for (    String arg : args) {
      if (arg.startsWith("file=")) {
        fileName=arg.substring("file=".length());
      }
 else       if (arg.startsWith("showFileMenu=")) {
        showFileMenu=Boolean.parseBoolean(arg.substring("showFileMenu=".length()));
      }
    }
  }
  if (m_knowledgeFlow == null) {
    m_knowledgeFlow=new KnowledgeFlowApp(showFileMenu);
  }
  for (int i=0; i < s_startupListeners.size(); i++) {
    s_startupListeners.elementAt(i).startUpComplete();
  }
  if (fileName != null) {
    m_knowledgeFlow.loadInitialLayout(fileName);
  }
}

public static void disposeSingleton(){
  m_knowledgeFlow=null;
}

/** 
 * Return the singleton instance of the KnowledgeFlow
 * @return the singleton instance
 */
public static KnowledgeFlowApp getSingleton(){
  return m_knowledgeFlow;
}

/** 
 * Add a listener to be notified when startup is complete
 * @param s a listener to add
 */
public static void addStartupListener(StartUpListener s){
  s_startupListeners.add(s);
}

/** 
 * Loads the specified file at input Added by Zerbetto
 */
private void loadInitialLayout(String fileName){
  File oFile=new File(fileName);
  if (oFile.exists() && oFile.isFile()) {
    m_FileChooser.setSelectedFile(oFile);
    int index=fileName.lastIndexOf('.');
    if (index != -1) {
      String extension=fileName.substring(index);
      if (FILE_EXTENSION_XML.equalsIgnoreCase(extension)) {
        m_FileChooser.setFileFilter(m_knowledgeFlow.m_XMLFilter);
      }
 else       if (FILE_EXTENSION.equalsIgnoreCase(extension)) {
        m_FileChooser.setFileFilter(m_knowledgeFlow.m_KfFilter);
      }
    }
  }
 else {
    weka.core.logging.Logger.log(weka.core.logging.Logger.Level.WARNING,"[KnowledgeFlow] File '" + fileName + "' does not exists.");
  }
  loadLayout(oFile,true);
}

public void setAllowMultipleTabs(boolean multiple){
  m_allowMultipleTabs=multiple;
  if (!multiple) {
    m_newB.setEnabled(false);
    if (m_configAndPerspectives != null) {
      remove(m_configAndPerspectives);
    }
  }
}

public boolean getAllowMultipleTabs(){
  return m_allowMultipleTabs;
}

/** 
 * Notifies to the parent swt that the layout is dirty Added by Zerbetto
 */
private void notifyIsDirty(){
  this.firePropertyChange("PROP_DIRTY",null,null);
}

/** 
 * Main method.
 * @param args a <code>String[]</code> value
 */
public static void main(String[] args){
  LookAndFeel.setLookAndFeel();
  try {
    final javax.swing.JFrame jf=new javax.swing.JFrame();
    jf.getContentPane().setLayout(new java.awt.BorderLayout());
    for (int i=0; i < args.length; i++) {
      if (args[i].toLowerCase().endsWith(".kf") || args[i].toLowerCase().endsWith(".kfml")) {
        args[i]="file=" + args[i];
      }
    }
    KnowledgeFlowApp.createSingleton(args);
    Image icon=Toolkit.getDefaultToolkit().getImage(m_knowledgeFlow.getClass().getClassLoader().getResource("weka/gui/weka_icon_new_48.png"));
    jf.setIconImage(icon);
    jf.getContentPane().add(m_knowledgeFlow,java.awt.BorderLayout.CENTER);
    jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    jf.setSize(1024,768);
    jf.setVisible(true);
    Thread memMonitor=new Thread(){
      @SuppressWarnings("static-access") @Override public void run(){
        while (true) {
          if (m_Memory.isOutOfMemory()) {
            jf.dispose();
            m_knowledgeFlow=null;
            System.gc();
            System.err.println("\n[KnowledgeFlow] displayed message:");
            m_Memory.showOutOfMemory();
            System.err.println("\nexiting");
            System.exit(-1);
          }
        }
      }
    }
;
    memMonitor.setPriority(Thread.NORM_PRIORITY);
    memMonitor.start();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    System.err.println(ex.getMessage());
  }
}

@SuppressWarnings("static-access") @Override public void run(){
  while (true) {
    if (m_Memory.isOutOfMemory()) {
      jf.dispose();
      m_knowledgeFlow=null;
      System.gc();
      System.err.println("\n[KnowledgeFlow] displayed message:");
      m_Memory.showOutOfMemory();
      System.err.println("\nexiting");
      System.exit(-1);
    }
  }
}
}
