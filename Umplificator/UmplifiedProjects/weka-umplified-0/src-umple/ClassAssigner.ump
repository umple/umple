namespace weka.gui.beans;

class ClassAssigner
{
  isA Visible,DataSourceListener,TrainingSetListener,TestSetListener,DataSource,TrainingSetProducer,TestSetProducer,BeanCommon,EventConstraints,Serializable,InstanceListener,StructureProducer;
  isA JPanel;
 depend java.awt.BorderLayout;
 depend java.beans.EventSetDescriptor;
 depend java.io.Serializable;
 depend java.util.Vector;
 depend javax.swing.JPanel;
 depend weka.core.Attribute;
 depend weka.core.Instances;
/** 
 * for serialization 
 */
private static final long serialVersionUID=4011131665025817924L;

private String m_classColumn="last";

/** 
 * format of instances for current incoming connection (if any) 
 */
private Instances m_connectedFormat;

private Object m_trainingProvider;

private Object m_testProvider;

private Object m_dataProvider;

private Object m_instanceProvider;

private final Vector<TrainingSetListener> m_trainingListeners=new Vector<TrainingSetListener>();

private final Vector<TestSetListener> m_testListeners=new Vector<TestSetListener>();

private final Vector<DataSourceListener> m_dataListeners=new Vector<DataSourceListener>();

private final Vector<InstanceListener> m_instanceListeners=new Vector<InstanceListener>();

private final Vector<DataFormatListener> m_dataFormatListeners=new Vector<DataFormatListener>();

protected transient weka.gui.Logger m_logger=null;

protected BeanVisual m_visual=new BeanVisual("ClassAssigner",BeanVisual.ICON_PATH + "ClassAssigner.gif",BeanVisual.ICON_PATH + "ClassAssigner_animated.gif");

/** 
 * Global info for this bean
 * @return a <code>String</code> value
 */
public String globalInfo(){
  return "Designate which column is to be considered the class column " + "in incoming data.";
}

public ClassAssigner(){
  setLayout(new BorderLayout());
  add(m_visual,BorderLayout.CENTER);
}

/** 
 * Set a custom (descriptive) name for this bean
 * @param name the name to use
 */
@Override public void setCustomName(String name){
  m_visual.setText(name);
}

/** 
 * Get the custom (descriptive) name for this bean (if one has been set)
 * @return the custom name (or the default name)
 */
@Override public String getCustomName(){
  return m_visual.getText();
}

/** 
 * Tool tip text for this property
 * @return a <code>String</code> value
 */
public String classColumnTipText(){
  return "Specify the number of the column that contains the class attribute";
}

private Instances getUpstreamStructure(){
  if (m_dataProvider != null && m_dataProvider instanceof StructureProducer) {
    return ((StructureProducer)m_dataProvider).getStructure("dataSet");
  }
  if (m_trainingProvider != null && m_trainingProvider instanceof StructureProducer) {
    return ((StructureProducer)m_trainingProvider).getStructure("trainingSet");
  }
  if (m_testProvider != null && m_testProvider instanceof StructureProducer) {
    return ((StructureProducer)m_testProvider).getStructure("testSet");
  }
  if (m_instanceProvider != null && m_instanceProvider instanceof StructureProducer) {
    return ((StructureProducer)m_instanceProvider).getStructure("instance");
  }
  return null;
}

/** 
 * Get the structure of the output encapsulated in the named event. If the structure can't be determined in advance of seeing input, or this StructureProducer does not generate the named event, null should be returned.
 * @param eventName the name of the output event that encapsulates therequested output.
 * @return the structure of the output encapsulated in the named event or nullif it can't be determined in advance of seeing input or the named event is not generated by this StructureProduce.
 */
@Override public Instances getStructure(String eventName){
  if (!eventName.equals("trainingSet") && !eventName.equals("testSet") && !eventName.equals("dataSet")&& !eventName.equals("instance")) {
    return null;
  }
  if (m_trainingProvider == null && m_testProvider == null && m_dataProvider == null && m_instanceProvider == null) {
    return null;
  }
  if (eventName.equals("dataSet") && m_dataListeners.size() == 0) {
    return null;
  }
  if (eventName.equals("trainingSet") && m_trainingListeners.size() == 0) {
    return null;
  }
  if (eventName.equals("testSet") && m_testListeners.size() == 0) {
    return null;
  }
  if (eventName.equals("instance") && m_instanceListeners.size() == 0) {
    return null;
  }
  if (m_connectedFormat == null) {
    m_connectedFormat=getUpstreamStructure();
  }
  if (m_connectedFormat != null) {
    assignClass(m_connectedFormat);
  }
  return m_connectedFormat;
}

/** 
 * Returns the structure of the incoming instances (if any)
 * @return an <code>Instances</code> value
 */
public Instances getConnectedFormat(){
  if (m_connectedFormat == null) {
    m_connectedFormat=getUpstreamStructure();
  }
  return m_connectedFormat;
}

public void setClassColumn(String col){
  m_classColumn=col;
  if (m_connectedFormat != null) {
    assignClass(m_connectedFormat);
  }
}

public String getClassColumn(){
  return m_classColumn;
}

@Override public void acceptDataSet(DataSetEvent e){
  Instances dataSet=e.getDataSet();
  assignClass(dataSet);
  notifyDataListeners(e);
  if (e.isStructureOnly()) {
    m_connectedFormat=e.getDataSet();
    notifyDataFormatListeners();
  }
}

@Override public void acceptTrainingSet(TrainingSetEvent e){
  Instances trainingSet=e.getTrainingSet();
  assignClass(trainingSet);
  notifyTrainingListeners(e);
  if (e.isStructureOnly()) {
    m_connectedFormat=e.getTrainingSet();
    notifyDataFormatListeners();
  }
}

@Override public void acceptTestSet(TestSetEvent e){
  Instances testSet=e.getTestSet();
  assignClass(testSet);
  notifyTestListeners(e);
  if (e.isStructureOnly()) {
    m_connectedFormat=e.getTestSet();
    notifyDataFormatListeners();
  }
}

@Override public void acceptInstance(InstanceEvent e){
  if (e.getStatus() == InstanceEvent.FORMAT_AVAILABLE) {
    m_connectedFormat=e.getStructure();
    assignClass(m_connectedFormat);
    notifyInstanceListeners(e);
    System.err.println("Notifying customizer...");
    notifyDataFormatListeners();
  }
 else {
    notifyInstanceListeners(e);
  }
}

private void assignClass(Instances dataSet){
  int classCol=-1;
  if (m_classColumn.trim().toLowerCase().compareTo("last") == 0 || m_classColumn.equalsIgnoreCase("/last")) {
    dataSet.setClassIndex(dataSet.numAttributes() - 1);
  }
 else   if (m_classColumn.trim().toLowerCase().compareTo("first") == 0 || m_classColumn.equalsIgnoreCase("/first")) {
    dataSet.setClassIndex(0);
  }
 else {
    Attribute classAtt=dataSet.attribute(m_classColumn.trim());
    if (classAtt != null) {
      dataSet.setClass(classAtt);
    }
 else {
      try {
        classCol=Integer.parseInt(m_classColumn.trim()) - 1;
      }
 catch (      NumberFormatException ex) {
        if (m_logger != null) {
          m_logger.logMessage("Warning : can't parse '" + m_classColumn.trim() + "' as a number "+ " or find it as an attribute in the incoming data (ClassAssigner)");
        }
      }
      if (classCol > dataSet.numAttributes() - 1) {
        if (m_logger != null) {
          m_logger.logMessage("Class column outside range of data " + "(ClassAssigner)");
        }
      }
 else {
        dataSet.setClassIndex(classCol);
      }
    }
  }
}

@SuppressWarnings("unchecked") protected void notifyTestListeners(TestSetEvent tse){
  Vector<TestSetListener> l;
synchronized (this) {
    l=(Vector<TestSetListener>)m_testListeners.clone();
  }
  if (l.size() > 0) {
    for (int i=0; i < l.size(); i++) {
      System.err.println("Notifying test listeners " + "(ClassAssigner)");
      l.elementAt(i).acceptTestSet(tse);
    }
  }
}

@SuppressWarnings("unchecked") protected void notifyTrainingListeners(TrainingSetEvent tse){
  Vector<TrainingSetListener> l;
synchronized (this) {
    l=(Vector<TrainingSetListener>)m_trainingListeners.clone();
  }
  if (l.size() > 0) {
    for (int i=0; i < l.size(); i++) {
      System.err.println("Notifying training listeners " + "(ClassAssigner)");
      l.elementAt(i).acceptTrainingSet(tse);
    }
  }
}

@SuppressWarnings("unchecked") protected void notifyDataListeners(DataSetEvent tse){
  Vector<DataSourceListener> l;
synchronized (this) {
    l=(Vector<DataSourceListener>)m_dataListeners.clone();
  }
  if (l.size() > 0) {
    for (int i=0; i < l.size(); i++) {
      System.err.println("Notifying data listeners " + "(ClassAssigner)");
      l.elementAt(i).acceptDataSet(tse);
    }
  }
}

@SuppressWarnings("unchecked") protected void notifyInstanceListeners(InstanceEvent tse){
  Vector<InstanceListener> l;
synchronized (this) {
    l=(Vector<InstanceListener>)m_instanceListeners.clone();
  }
  if (l.size() > 0) {
    for (int i=0; i < l.size(); i++) {
      l.elementAt(i).acceptInstance(tse);
    }
  }
}

@SuppressWarnings("unchecked") protected void notifyDataFormatListeners(){
  Vector<DataFormatListener> l;
synchronized (this) {
    l=(Vector<DataFormatListener>)m_dataFormatListeners.clone();
  }
  if (l.size() > 0) {
    DataSetEvent dse=new DataSetEvent(this,m_connectedFormat);
    for (int i=0; i < l.size(); i++) {
      l.elementAt(i).newDataFormat(dse);
    }
  }
}

@Override public synchronized void addInstanceListener(InstanceListener tsl){
  m_instanceListeners.addElement(tsl);
  if (m_connectedFormat != null) {
    InstanceEvent e=new InstanceEvent(this,m_connectedFormat);
    tsl.acceptInstance(e);
  }
}

@Override public synchronized void removeInstanceListener(InstanceListener tsl){
  m_instanceListeners.removeElement(tsl);
}

@Override public synchronized void addDataSourceListener(DataSourceListener tsl){
  m_dataListeners.addElement(tsl);
  if (m_connectedFormat != null) {
    DataSetEvent e=new DataSetEvent(this,m_connectedFormat);
    tsl.acceptDataSet(e);
  }
}

@Override public synchronized void removeDataSourceListener(DataSourceListener tsl){
  m_dataListeners.removeElement(tsl);
}

@Override public synchronized void addTrainingSetListener(TrainingSetListener tsl){
  m_trainingListeners.addElement(tsl);
  if (m_connectedFormat != null) {
    TrainingSetEvent e=new TrainingSetEvent(this,m_connectedFormat);
    tsl.acceptTrainingSet(e);
  }
}

@Override public synchronized void removeTrainingSetListener(TrainingSetListener tsl){
  m_trainingListeners.removeElement(tsl);
}

@Override public synchronized void addTestSetListener(TestSetListener tsl){
  m_testListeners.addElement(tsl);
  if (m_connectedFormat != null) {
    TestSetEvent e=new TestSetEvent(this,m_connectedFormat);
    tsl.acceptTestSet(e);
  }
}

@Override public synchronized void removeTestSetListener(TestSetListener tsl){
  m_testListeners.removeElement(tsl);
}

public synchronized void addDataFormatListener(DataFormatListener dfl){
  m_dataFormatListeners.addElement(dfl);
}

public synchronized void removeDataFormatListener(DataFormatListener dfl){
  m_dataFormatListeners.removeElement(dfl);
}

@Override public void setVisual(BeanVisual newVisual){
  m_visual=newVisual;
}

@Override public BeanVisual getVisual(){
  return m_visual;
}

@Override public void useDefaultVisual(){
  m_visual.loadIcons(BeanVisual.ICON_PATH + "ClassAssigner.gif",BeanVisual.ICON_PATH + "ClassAssigner_animated.gif");
}

/** 
 * Returns true if, at this time, the object will accept a connection according to the supplied event name
 * @param eventName the event
 * @return true if the object will accept a connection
 */
@Override public boolean connectionAllowed(String eventName){
  if (eventName.compareTo("trainingSet") == 0 && (m_trainingProvider != null || m_dataProvider != null || m_instanceProvider != null)) {
    return false;
  }
  if (eventName.compareTo("testSet") == 0 && m_testProvider != null) {
    return false;
  }
  if (eventName.compareTo("instance") == 0 && m_instanceProvider != null || m_trainingProvider != null || m_dataProvider != null) {
    return false;
  }
  return true;
}

/** 
 * Returns true if, at this time, the object will accept a connection according to the supplied EventSetDescriptor
 * @param esd the EventSetDescriptor
 * @return true if the object will accept a connection
 */
@Override public boolean connectionAllowed(EventSetDescriptor esd){
  return connectionAllowed(esd.getName());
}

/** 
 * Notify this object that it has been registered as a listener with a source with respect to the supplied event name
 * @param eventName the event
 * @param source the source with which this object has been registered as alistener
 */
@Override public synchronized void connectionNotification(String eventName,Object source){
  if (connectionAllowed(eventName)) {
    if (eventName.compareTo("trainingSet") == 0) {
      m_trainingProvider=source;
    }
 else     if (eventName.compareTo("testSet") == 0) {
      m_testProvider=source;
    }
 else     if (eventName.compareTo("dataSet") == 0) {
      m_dataProvider=source;
    }
 else     if (eventName.compareTo("instance") == 0) {
      m_instanceProvider=source;
    }
    m_connectedFormat=null;
  }
}

/** 
 * Notify this object that it has been deregistered as a listener with a source with respect to the supplied event name
 * @param eventName the event
 * @param source the source with which this object has been registered as alistener
 */
@Override public synchronized void disconnectionNotification(String eventName,Object source){
  if (eventName.compareTo("trainingSet") == 0) {
    if (m_trainingProvider == source) {
      m_trainingProvider=null;
    }
  }
  if (eventName.compareTo("testSet") == 0) {
    if (m_testProvider == source) {
      m_testProvider=null;
    }
  }
  if (eventName.compareTo("dataSet") == 0) {
    if (m_dataProvider == source) {
      m_dataProvider=null;
    }
  }
  if (eventName.compareTo("instance") == 0) {
    if (m_instanceProvider == source) {
      m_instanceProvider=null;
    }
  }
  m_connectedFormat=null;
}

@Override public void setLog(weka.gui.Logger logger){
  m_logger=logger;
}

@Override public void stop(){
  if (m_trainingProvider != null && m_trainingProvider instanceof BeanCommon) {
    ((BeanCommon)m_trainingProvider).stop();
  }
  if (m_testProvider != null && m_testProvider instanceof BeanCommon) {
    ((BeanCommon)m_testProvider).stop();
  }
  if (m_dataProvider != null && m_dataProvider instanceof BeanCommon) {
    ((BeanCommon)m_dataProvider).stop();
  }
  if (m_instanceProvider != null && m_instanceProvider instanceof BeanCommon) {
    ((BeanCommon)m_instanceProvider).stop();
  }
}

/** 
 * Returns true if. at this time, the bean is busy with some (i.e. perhaps a worker thread is performing some calculation).
 * @return true if the bean is busy.
 */
@Override public boolean isBusy(){
  return false;
}

/** 
 * Returns true, if at the current time, the named event could be generated. Assumes that the supplied event name is an event that could be generated by this bean
 * @param eventName the name of the event in question
 * @return true if the named event could be generated at this point in time
 */
@Override public boolean eventGeneratable(String eventName){
  if (eventName.compareTo("trainingSet") == 0) {
    if (m_trainingProvider == null) {
      return false;
    }
 else {
      if (m_trainingProvider instanceof EventConstraints) {
        if (!((EventConstraints)m_trainingProvider).eventGeneratable("trainingSet")) {
          return false;
        }
      }
    }
  }
  if (eventName.compareTo("dataSet") == 0) {
    if (m_dataProvider == null) {
      if (m_instanceProvider == null) {
        m_connectedFormat=null;
        notifyDataFormatListeners();
      }
      return false;
    }
 else {
      if (m_dataProvider instanceof EventConstraints) {
        if (!((EventConstraints)m_dataProvider).eventGeneratable("dataSet")) {
          m_connectedFormat=null;
          notifyDataFormatListeners();
          return false;
        }
      }
    }
  }
  if (eventName.compareTo("instance") == 0) {
    if (m_instanceProvider == null) {
      if (m_dataProvider == null) {
        m_connectedFormat=null;
        notifyDataFormatListeners();
      }
      return false;
    }
 else {
      if (m_instanceProvider instanceof EventConstraints) {
        if (!((EventConstraints)m_instanceProvider).eventGeneratable("instance")) {
          m_connectedFormat=null;
          notifyDataFormatListeners();
          return false;
        }
      }
    }
  }
  if (eventName.compareTo("testSet") == 0) {
    if (m_testProvider == null) {
      return false;
    }
 else {
      if (m_testProvider instanceof EventConstraints) {
        if (!((EventConstraints)m_testProvider).eventGeneratable("testSet")) {
          return false;
        }
      }
    }
  }
  return true;
}
}
