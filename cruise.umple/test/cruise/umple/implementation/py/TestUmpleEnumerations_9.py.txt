#PLEASE DO NOT EDIT THIS CODE
#This code was generated using the UMPLE 1.35.0.7523.c616a4dce modeling language!
# line 7 "mydoc.ump"

class Bar():
    #------------------------
    # MEMBER VARIABLES
    #------------------------
    #Bar Associations
    #------------------------
    # CONSTRUCTOR
    #------------------------
    def __init__(self):
        self._foos = None
        self._foos = []

    #------------------------
    # INTERFACE
    #------------------------
    # Code from template association_GetMany 
    def getFoo(self, index):
        aFoo = self._foos[index]
        return aFoo

    def getFoos(self):
        newFoos = tuple(self._foos)
        return newFoos

    def numberOfFoos(self):
        number = len(self._foos)
        return number

    def hasFoos(self):
        has = len(self._foos) > 0
        return has

    def indexOfFoo(self, aFoo):
        index = (-1 if not aFoo in self._foos else self._foos.index(aFoo))
        return index

    # Code from template association_MinimumNumberOfMethod 
    @staticmethod
    def minimumNumberOfFoos():
        return 0

    # Code from template association_AddManyToOne 
    def addFoo1(self, aMyBaz, aMyStr):
        from Foo import Foo
        return Foo(aMyBaz, aMyStr, self)

    def addFoo2(self, aFoo):
        wasAdded = False
        if (aFoo) in self._foos :
            return False
        existingBar = aFoo.getBar()
        isNewBar = not (existingBar is None) and not self == existingBar
        if isNewBar :
            aFoo.setBar(self)
        else :
            self._foos.append(aFoo)
        wasAdded = True
        return wasAdded

    def removeFoo(self, aFoo):
        wasRemoved = False
        #Unable to remove aFoo, as it must always have a bar
        if not self == aFoo.getBar() :
            self._foos.remove(aFoo)
            wasRemoved = True
        return wasRemoved

    # Code from template association_AddIndexControlFunctions 
    def addFooAt(self, aFoo, index):
        wasAdded = False
        if self.addFoo(aFoo) :
            if index < 0 :
                index = 0
            if index > self.numberOfFoos() :
                index = self.numberOfFoos() - 1
            self._foos.remove(aFoo)
            self._foos.insert(index, aFoo)
            wasAdded = True
        return wasAdded

    def addOrMoveFooAt(self, aFoo, index):
        wasAdded = False
        if (aFoo) in self._foos :
            if index < 0 :
                index = 0
            if index > self.numberOfFoos() :
                index = self.numberOfFoos() - 1
            self._foos.remove(aFoo)
            self._foos.insert(index, aFoo)
            wasAdded = True
        else :
            wasAdded = self.addFooAt(aFoo, index)
        return wasAdded

    def delete(self):
        i = len(self._foos)
        while i > 0 :
            aFoo = self._foos[i - 1]
            aFoo.delete()
            i -= 1

    def addFoo(self, *argv):
        from Foo import Foo
        if len(argv) == 2 and isinstance(argv[0], Foo.Baz) and isinstance(argv[1], str) :
            return self.addFoo1(argv[0], argv[1])
        if len(argv) == 1 and isinstance(argv[0], Foo) :
            return self.addFoo2(argv[0])
        raise TypeError("No method matches provided parameters")
