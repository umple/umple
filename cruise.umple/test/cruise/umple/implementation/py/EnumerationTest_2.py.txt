#PLEASE DO NOT EDIT THIS CODE
#This code was generated using the UMPLE 1.35.0.7523.c616a4dce modeling language!

from enum import Enum, auto

class X():
    MY_CONST = 100
    xsByMyName = dict()
    #------------------------
    # ENUMERATIONS
    #------------------------
    class Colour(Enum):
        def _generate_next_value_(name, start, count, last_values):
            return name
        def __str__(self):
            return str(self.value)
        Red = auto()
        Blue = auto()
        Green = auto()

    #------------------------
    # STATIC VARIABLES
    #------------------------
    #------------------------
    # MEMBER VARIABLES
    #------------------------
    #X Attributes
    #X State Machines
    class Sm(Enum):
        def _generate_next_value_(name, start, count, last_values):
            return name
        def __str__(self):
            return str(self.value)
        s1 = auto()
        s2 = auto()

    #------------------------
    # CONSTRUCTOR
    #------------------------
    def __init__(self, aDefaultAttr):
        self._sm = None
        self._defaultAttr = None
        self._myName = None
        self._defaultAttr = aDefaultAttr
        if not self.setMyName(aMyName) :
            raise RuntimeError ("Cannot create due to duplicate myName. See https://manual.umple.org?RE003ViolationofUniqueness.html")
        self.setSm(X.Sm.s1)

    #------------------------
    # INTERFACE
    #------------------------
    def setMyName(self, aMyName):
        wasSet = False
        anOldMyName = self.getMyName()
        if not (anOldMyName is None) and anOldMyName == aMyName :
            return True
        if X.hasWithMyName(aMyName) :
            return wasSet
        self._myName = aMyName
        wasSet = True
        if not (anOldMyName is None) :
            X.xsByMyName.pop(anOldMyName, None)
        X.xsByMyName[aMyName] = self
        return wasSet

    def setDefaultAttr(self, aDefaultAttr):
        wasSet = False
        self._defaultAttr = aDefaultAttr
        wasSet = True
        return wasSet

    def getMyName(self):
        return self._myName

    # Code from template attribute_GetUnique 
    @staticmethod
    def getWithMyName(aMyName):
        return X.xsByMyName.get(aMyName)

    # Code from template attribute_HasUnique 
    @staticmethod
    def hasWithMyName(aMyName):
        return not (X.getWithMyName(aMyName) is None)

    def getDefaultAttr(self):
        return self._defaultAttr

    def getSmFullName(self):
        answer = self._sm.__str__()
        return answer

    def getSm(self):
        return self._sm

    def goToS2(self):
        wasEventProcessed = False
        aSm = self._sm
        if aSm == X.Sm.s1 :
            self.setSm(X.Sm.s2)
            wasEventProcessed = True
        else :
            # Other states do respond to this event
            pass
        return wasEventProcessed

    def setSm(self, aSm):
        self._sm = aSm

    def delete(self):
        X.xsByMyName.pop(self.getMyName(), None)

    def __str__(self):
        return str(super().__str__()) + "[" + "myName" + ":" + str(self.getMyName()) + "," + "defaultAttr" + ":" + str(self.getDefaultAttr()) + "]"
