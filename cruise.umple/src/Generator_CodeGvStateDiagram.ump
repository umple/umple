/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This file generates .gv files for use by Graphviz, representing all state machines
encountered in the Umple model. To generate for this format, use 
  generate GvStateDiagram;
in your umple file, or the command line option
  -g GvStateDiagram

GraphViz documentation is here: http://www.graphviz.org/Documentation.php

To turn the gv state diagram into a png, run this:
  dot -Tpng umplefile.gv -o umplefile.png

See examples others have done: 
  http://www.ffnn.nl/pages/articles/media/uml-diagrams-using-graphviz-dot.php
  http://martin-thoma.com/how-to-draw-a-finite-state-machine/
 */

namespace cruise.umple.compiler;

class GvStateDiagramGenerator
{
  Boolean hideActions = false;
  Boolean hideGuards = false;
 
  internal Map<Transition,String> internalBoundaryTrans
    = new HashMap<Transition,String>();
  internal int nodeNumber=0;
  
  // Basic templates for GV elements to output
  
  // Template for what will appear at the start of each graph file
  graphStart(umpleVersion) <<!// Code generated by Umple <<=<<=umpleVersion>>>>

digraph "<<=filename>>" {
  compound = true;
  size="80,10"
!>>
  emit graphStart(String filename)(graphStart(UmpleModel.VERSION_NUMBER));

  // Template for what will appear at the end of each graph file
  graphEnd <<!
  // All transitions
  <<=transitions>>
}
!>>  
  emit graphEnd(StringBuilder transitions)(graphEnd);  

  // Template for what is output if there is no state machine
  nosm <<!  node [shape=box, penwidth=0];
  message [label ="No state machine found in the input Umple file"];
!>>
  emit nosm()(nosm);


  // CENTRAL GENERATE METHOD

  public void generate()
  {
    StringBuilder code = new StringBuilder();
    StringBuilder transitions = new StringBuilder();
    String className;
    
    hideActions = hasSuboption("hideactions");
    hideGuards = hasSuboption("hideguards");
    
    // Output basic gv file header
    _graphStart(0,code,model.getUmpleFile().getSimpleFileName());

    // Determine if there are multiple classes with state machines
    // or multiple state machines in any class
    // If so, we will need to put boxes around the state machines
    int smCount = 0;
    for (UmpleClass uClass : model.getUmpleClasses()) 
    {
      for (StateMachine sm : uClass.getStateMachines()) 
      {
        smCount++;
      }
    }
    if(smCount == 0) 
    {
      // Special case. No state machine.
      _nosm(0,code);
      terminateCode(code, transitions);
      return;
    }

    // We now know we have to output one or more state machines
    // Iterate through each class. 
    for (UmpleClass uClass : model.getUmpleClasses())
    {
      className = uClass.getName();
      code.append("\n  // Class: "+className+"\n");
      
      // Process the top level state machines in a class
      for (StateMachine sm : uClass.getStateMachines())
      {
        if(sm.getParentState() == null) 
        { // This check shouldn't be needed
          appendStateMachineRecursively(code, transitions, sm, uClass, className, true, smCount, 4);
        }
      } // End iteration through state machines of a class
    } // End iteration through classes
    terminateCode(code, transitions);
  }
  
  private void terminateCode(StringBuilder code, StringBuilder transitions) {
    _graphEnd(0,code,transitions);

    model.setCode(code.toString());
    writeModel();
  } 

  // Template for start state
  startState <<!
// Start states are shown as a black circle
node [shape = point, fillcolor="black", width=0.2 ];
start_<<=clSmName>> [ tooltip = "<<=tooltip>>" ];

!>>
  emit startState(String clSmName, String tooltip)(startState);

  // Template for a normal node
  normalStateFormat <<!
// Format for normal states
node [shape = rectangle, width=1,style=rounded];
!>>
  emit normalStateFormat()(normalStateFormat);

  // Template for a pseudostate such as history or deep history
  pseudoStateFormat <<!
// Format for normal states
node [shape = circle, fixedsize = true, width=.3];
!>>
  emit pseudoStateFormat()(pseudoStateFormat);

  // Used to indent code
  private void appendSpaces(StringBuilder code, int numSpaces) 
  {
    for(int i=0; i<numSpaces; i++) 
    {
      code.append(" ");
    }
  }

  // The state qualified name incorporates the classname, the state machine name
  // and the hierarchy of state names
  // This is used as the internal graphviz label, and is not displayed.  
  private String getStateQualifiedName(State s, UmpleClass c) 
  {
    StateMachine sm = s.getStateMachine();
    String prepend = s.hasNestedStateMachines() ? "cluster" : "";
    return prepend+c.getName()+"_"+sm.getFullName()+"_"+s.getName();
  }

  // Return the name for the state to be used in transitions
  private String getTransitionNameForState(State s, UmpleClass c, boolean isOrigin) 
  {
    State firstNonSuperstate = getFirstNestedNonClusterState(s);
    return getStateQualifiedName(firstNonSuperstate, c);
  }
  
  // return self if it does not have nested state, otherwise the first
  // nested state that does not itself have a nested state
  private State getFirstNestedNonClusterState(State s) 
  {
    if(!s.hasNestedStateMachines()) 
    {
      return s;
    }
    else 
    {
      return getFirstNestedNonClusterState(s.getNestedStateMachine(0).getState(0));
    }
  }

  private String getTransitionHeadOrTailForState(State s, UmpleClass c, boolean isOrigin) 
  {
    if(s.hasNestedStateMachines()) 
    {
      // Use lhead or ltail
      return (isOrigin? "ltail" : "lhead")+"="+getStateQualifiedName(s, c)+",";
    }
    else 
    {
      return "";
    }
  }  


  // TEMPLATES FOR TRANSITIONS //
  
  // Template for a transition
  transition <<!<<=start>> <<=arrow>> <<=dest>> [ <<=attributes>> ] ;
!>>
  emit transition(String start,String arrow,String dest, String attributes)(transition);

  // Template for transition attributes
  transitionAttributes <<!<<#if(lheadtail.length()>0) {#>> <<=lheadtail>> <<#
  }
  if(label.length()>0) {#>> label = "<<=label>>",<<#
  }
  #>> tooltip = "<<=tooltip>>"!>>
  emit transitionAttributes(String lheadtail, String label, String readableStart, String readableEnd, String tooltip)(transitionAttributes);
  //"<<=readableStart>> <<=label>> -> <<=readableEnd>>"!>>
  // TEMPLATES FOR STATES

  topLevelBorder <<!
 subgraph cluster<<=clSmName>> {
  label = "sm <<=className>> <<=smName>>";
  penwidth=0.5;
!>>
  emit topLevelBorder(String clSmName, String className, String smName)(topLevelBorder); 

  private void appendStateMachineRecursively(StringBuilder code, StringBuilder transitions, StateMachine sm,
      UmpleClass uClass, String className, boolean isTopLevel,
      int smCount, int indentLevel) 
  {

    String smName, clSmName, sLabel, sName, tooltip;
    boolean isPseudo = false;    
    Event event;
    Action action;
    String transitionLabel, guardString, actionCode, transitionAction, blah = "blah";
    Guard guard;
    List<StateMachine> allNestedStateMachines = sm.getImmediateNestedStateMachines();

    // We haven't processed any states yet in this statemachine
    Boolean isFirstState = true;

    // Determine whether bottom level
    Boolean isBottomLevel = allNestedStateMachines.isEmpty();
    String levelPhrase = "";
    if(isTopLevel) 
    {
      if(isBottomLevel) levelPhrase ="Top and Bottom Level ";
      else levelPhrase = "Top Level ";
    }
    else if(isBottomLevel) levelPhrase = "Bottom Level ";
      
    smName = sm.getName();
    clSmName = className+"_"+smName;
    code.append("\n");
    appendSpaces(code,  indentLevel);
    code.append("// "+levelPhrase+"StateMachine: "+smName+"\n");        

    // If there are multiple state machines in the model
    // And this is a top level state machine
    // Then we need to put the state machine in a border
    if(smCount > 1 && isTopLevel) 
    {
      _topLevelBorder(indentLevel, code, clSmName, className, smName);
    }

    // Every state machine has a start state
    String [] stateInfo = getStatePath(sm, "start");
    tooltip = "Class "+className+", SM "+stateInfo[0]+", State "+stateInfo[1];
    _startState(indentLevel,code,clSmName, tooltip);
    _normalStateFormat(indentLevel, code);
 
    // Iterate through the states of this state machine
    for (State s : sm.getStates())
    {
      sLabel=s.getName();  // This is what is displayed
      if(sLabel.equals("HStar")) sLabel="\"H*\"";
      isPseudo = sLabel.equals("H") || sLabel.equals("\"H*\"");
      sName=getStateQualifiedName(s,uClass);  // Internal gv identifier
      
      code.append("\n");      
      appendSpaces(code,  indentLevel+2);
      code.append("// State: "+sLabel+"\n\n");   

      // WORKING ON
      // If state will have transitions that start from or end at boundary
      // and go or come from other states further inside
      // then we need to add a dummy connector state

      if(!isBottomLevel) 
      { // s is not bottom level
        Map<Transition,String> newInternalBoundaryTrans = new HashMap<Transition,String>();
      
        Set<Transition> allT = new HashSet<Transition>();
        allT.addAll(s.getTransitions());
        allT.addAll(s.getNextTransition());

        for (Transition t: allT) 
        {
          if(!internalBoundaryTrans.containsKey(t) && (
            (t.getFromState()==s && t.getNextState().isSubstateOf(s)) ||
            (t.getNextState()==s && t.getFromState().isSubstateOf(s)) ) ) 
          {

            nodeNumber++;
            String dummyName="dummyNode"+nodeNumber+"_"+
              t.getFromState().getName()+"_"+t.getNextState().getName();
            internalBoundaryTrans.put(t,dummyName);
            newInternalBoundaryTrans.put(t,dummyName);
          }
        }
        if(!newInternalBoundaryTrans.isEmpty()) 
        {
          appendSpaces(code, indentLevel+2);
          code.append("// Dummy notes for transitions to/from internals to boundary\n");
          appendSpaces(code, indentLevel+2);
          code.append("node [shape = point, width = 0.005];\n");

          for (String nodeName : newInternalBoundaryTrans.values()) 
          {
            appendSpaces(code, indentLevel+2);
            code.append(nodeName+" [label=\"\"];\n");
          }
          
          // Reinstate normal format
          _normalStateFormat(indentLevel+2, code);
        }
      }

      // Output the state (and possibly state machine) id
      if(!s.hasNestedStateMachines()) 
      {
        // Simple state node
        if(isPseudo) _pseudoStateFormat(indentLevel, code);
        appendSpaces(code,  indentLevel+2);
		
        tooltip = getStateTooltip(sm, s, className);
        code.append(sName+" [label = "+sLabel+", tooltip = \""+tooltip+"\"];\n");
        if(isPseudo) _normalStateFormat(indentLevel, code);        
      }
      else 
      {
        // Start of a subgraph
        appendSpaces(code,  indentLevel+1);
        code.append("subgraph "+sName+" {\n");
        appendSpaces(code,  indentLevel+2);
        code.append("label = \""+sLabel+"\";\n");
        appendSpaces(code,  indentLevel+2);
        code.append("style = rounded;\n");
      }

      if(isFirstState) 
      {
         // Output transition to first state
         isFirstState = false;
        String dest=getTransitionNameForState(s,uClass,false);
        String head=getTransitionHeadOrTailForState(s, uClass,false);
        stateInfo = getStatePath(sm, s.getName());
        tooltip = "start to "+stateInfo[1]; 
        
        _transition(2,transitions,"start_"+clSmName,"->", dest,
          transitionAttributes(head,"","start",s.getName(), tooltip)); 
      }
          
      // Output all the other transitions
      for (Transition t : s.getNextTransition()) 
      {
        event = t.getEvent();
        action = t.getAction();
        
        if(event.isAutoTransition()) 
        {
          transitionLabel = "";
        } 
        else {
          if (event.getIsTimer()) 
          {
            transitionLabel = "after("+event.getTimerInSeconds()+")";
          }
          else 
          {
            if(event.getArgs() == null || event.getArgs() == "") 
            {
              transitionLabel = event.getName();
            }
            else 
            {
              transitionLabel = event.getName()+"("+event.getArgs()+")";
            }
          }
        }
        
        if (action == null || action.getActionCode() == "" || hideActions) 
        {
          transitionAction = "";
        }
        else 
        {
          actionCode = action.getActionCode();
          if (actionCode.length() > 15) transitionAction = " / {...}";
          else transitionAction = " / "+actionCode.replaceAll("\"","&quot;");
        }
      
        guard = t.getGuard();
        if (guard == null || hideGuards) guardString = "";
        else 
        {
          JavaGenerator gen = new JavaGenerator();
          gen.setModel(getModel());
          
          if(event.isAutoTransition()) guardString = "[";
          else guardString = " [";

          guardString += guard.getCondition(gen).replaceAll("\"","&quot;") + "]";
        }
        
        String orig = getTransitionNameForState(t.getFromState(),uClass,true);
        String dest = getTransitionNameForState(t.getNextState(),uClass,false);
        String origlh = getTransitionHeadOrTailForState(t.getFromState(),uClass,true);
        String destlt = getTransitionHeadOrTailForState(t.getNextState(),uClass,false);
        tooltip = getTransitionTooltip(t, guardString); 

        // WORKING ON
        // If we have to go through a dummy external state
        // we have to add two transitions
        if(internalBoundaryTrans.containsKey(t)) 
        {
          _transition(2,transitions,orig,"->", internalBoundaryTrans.get(t)+":e",
            transitionAttributes("dir=none, "+origlh,
            transitionLabel + guardString + transitionAction,
            t.getFromState().getName(),t.getNextState().getName(), tooltip));        

          _transition(2,transitions,internalBoundaryTrans.get(t)+":w","->", dest,
            transitionAttributes(destlt,
            "",
            t.getFromState().getName(),t.getNextState().getName(), tooltip));        
        }
        else 
        {
          // Normal transition
          _transition(2,transitions,orig,"->", dest,
            transitionAttributes(origlh+destlt,
            transitionLabel + guardString + transitionAction,
            t.getFromState().getName(),t.getNextState().getName(), tooltip));
        }
        transitions.append("\n");
      }  // End iteration through the transitions

      // Process nested state machines of this state
      allNestedStateMachines = s.getNestedStateMachines();
      for(StateMachine nestedSm: allNestedStateMachines) 
      {
        appendStateMachineRecursively(code, transitions, nestedSm, uClass, className, false, smCount, indentLevel+2);
      } // End iteration through nested state machines

      // Mark end of subgraph
      if(s.hasNestedStateMachines()) 
      {
        appendSpaces(code,  indentLevel+1);
        code.append("}\n");
      }

      appendSpaces(code,  indentLevel+2);
      code.append("// End State: "+sLabel+"\n"); 
     
    } // End iteration through states of a state machine

    appendSpaces(code,  indentLevel);
    code.append("// End "+levelPhrase+"StateMachine: "+smName+"\n");  

    // If there are multiple state machines in the model
    // And this is the top level state machine
    // Then we need to end the cluster border started earlier
    if(smCount > 1 && isTopLevel) 
    {
      code.append("  }\n");
    }
  }

  // Get the path for nested states 
  private String[] getStatePath(StateMachine sm_in, String stateName)
  {
    StateMachine sm = sm_in;
    State cur = sm.getParentState();
    String smName = sm.getName();
    String statePath = stateName;
	
    while (cur != null)
    {
      statePath = smName+"."+statePath;
      sm = cur.getStateMachine();
      cur = sm.getParentState();
      smName = sm.getName();
    }

    return new String[] {smName, statePath};
  }


  private String getTransitionTooltip(Transition t, String guardString)
  {
    // Find the state machine path the transition is coming from
    String [] fromStateInfo = getStatePath(t.getFromState().getStateMachine(), t.getFromState().getName());
    String tooltipFromState = fromStateInfo[1];
	
    // Find the state machine path the transition is going to
    String [] toStateInfo = getStatePath(t.getNextState().getStateMachine(), t.getNextState().getName());
    String tooltipToState = toStateInfo[1];
	
    // Get the condition on which transitioning
    Event event = t.getEvent();
	
    // Set transition event information
    String tooltip = "From "+tooltipFromState+" to "+tooltipToState;
    if (!event.isAutoTransition()) 
    {
      if (event.getIsTimer()) // Timed transition
        tooltip = tooltip+" after("+event.getTimerInSeconds()+")";
      else if(event.getArgs() == null || event.getArgs() == "") 
        tooltip = tooltip+" on "+event.getName();
      else 
        tooltip = tooltip+" on "+event.getName()+"("+event.getArgs()+")";
    }
    else
    {
      tooltip = tooltip+" automatically";
	}
	
    // Get guard code for transition
    if (guardString != "" && !hideGuards)
    {
      tooltip = tooltip+"&#13;"+"Guard: "+guardString;
    }
	
    // Get action code for transition	
    Action action = t.getAction();
    String transitionAction = "";
    if (action != null)
    {
      transitionAction = action.getActionCode();
    }
    if (transitionAction != "" && !hideActions)
    {	
      transitionAction = transitionAction.replaceAll("\"","&quot;");
      tooltip = tooltip+"&#13;"+"Transition Action:\n"+retFiveLines(transitionAction);
    }
	
    return tooltip;
  }

  private String getStateTooltip(StateMachine sm, State st, String className)
  {
    // Find the state machine path
    String [] stateInfo = getStatePath(sm, st.getName());
	
    String tooltip = "Class "+className+", SM "+stateInfo[0]+", State "+stateInfo[1];
		
    // Get the state actions
    if (!hideActions)
    {
      for (Action action : st.getActions())
      {
        String actionType = action.getActionType();
        String actionCode = retFiveLines(action.getActionCode().replaceAll("\"","&quot;"));
        if ("entry".equals(actionType))
        {
          tooltip = tooltip+"&#13;"+"Entry:\n"+actionCode;
        }
        else if ("exit".equals(actionType))
        {
          tooltip = tooltip+"&#13;"+"Exit:\n"+actionCode;
        }
        else
        {
          tooltip = tooltip+"&#13;"+"Action:\n"+actionCode;
        }
      }
    }
	
    // Get the activities
    for (Activity activity : st.getActivities())
    {
      String activityCode = activity.getCodeblock().toString().replaceAll("\"","&quot;");
      tooltip = tooltip+"&#13;"+"Activity:\n"+retFiveLines(activityCode);
    }
	
    return tooltip;
  }
  
  // Get the smallest space indent in the code
  private int getMinSpace(String[] parts)
  {
    int lines = parts.length < 5 ? parts.length : 5;
    int minSpaceCount = 1000;
    
    // The first part doesn't have whitespace in front of it
    for (int i = 1; i < lines; i++)
    {
      String part = parts[i];
      int j = 0, spaceCount = 0;
  	  
      while(j < part.length()){
        if(Character.isWhitespace(part.charAt(j))) { spaceCount++; }
        else { break; } // only want to count leading spaces
        j++;
      }
      
      if (spaceCount < minSpaceCount)
        minSpaceCount = spaceCount;
    }
  	
    return minSpaceCount;
  }
  
  // Return only the first 5 lines of code 
  // Used for displaying code in the tooltip as to not overwhelm the tooltip
  private String retFiveLines(String code)
  {
    String trimmedCode = "";
  	
    // Check if the code has multiple lines
    // TODO: Get this working with Unix AND Windows line endings
    if (code.contains(System.getProperty("line.separator")) || code.contains("\n"))
    {
      String[] parts = code.split("\\r?\\n");
  	  
      int minSpace = getMinSpace(parts);
      int substringIdx = minSpace; 
      int lines = parts.length < 5 ? parts.length : 5;
 	    
      // Only go through the first 5 lines
      for (int i = 0; i < lines; i++)
      {
        String part = "   "+parts[i]; // Always have at least an indent of 3
  		  
        // Get rid of excess indentation or add indentation for first line
        part = (i > 0) ? part.substring(substringIdx) : part;
  		
        trimmedCode = trimmedCode+part;
        if (i < lines-1)
          trimmedCode += "\n";
      }
  	    
      if (parts.length > 5)
        trimmedCode = trimmedCode+"\n   ...";
  	  
      return trimmedCode;
    }
  	
    return "   "+code;
  }

  // Output the graphviz file to a file with the .gv suffix
  private void writeModel()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + ".gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz State Machine code." + e, e);
    }
  } 
}

