/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
https://umple.org/license

This file generates a randomized instance diagram and the resulting objects
for every class in the model. The results of these instances is output
to a GV Diagram.

Command line action for this is
  -g InstanceDiagram

 */
namespace cruise.umple.compiler;

class InstanceDiagramGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.util.*;
  depend cruise.umple.compiler.exceptions.*;

  protected String generatorType()
  {
    return "cid";
  }

  // Template for what will appear at the start of each graphviz file
  graphStart(umpleVersion) <<! /*This code was generated using the UMPLE <<=umpleVersion>> modeling language! */
  
  digraph FeatureModel { 
    node [shape=rectangle]  
    edge [arrowhead=none] 
  !>>

  emit graphStart()(graphStart(UmpleModel.VERSION_NUMBER));

  protected void terminateCode(StringBuilder code, StringBuilder associations) {

    code.append("\n  // All associations\n");
    code.append(associations);

    code.append("}\n");

    model.setCode(code.toString());
    writeModel();
  }

  // Output the graphviz file to a file with the .gv suffix
  protected void writeModel()
  {
    try
    {
      String outputDir = getModel().getUmpleFile().getPath();
      String path = StringFormatter.addPathOrAbsolute(outputDir, "");
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName()
          + generatorType() + ".gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz Diagram code." + e, e);
    }
  } 

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  String outputCode = "";


  public void generate()
  {

    // TODO: Handle reflexive associations with non-zero links

    // TODO: Handling inheritance/polymorphism
    // Superclasses are sums of instances itself and its children
      // extendsClass (single), parentInterface (list), subclasses (list); are relevant UmpleClass attributes
      // Side Note: Verify if chain inheritances subclasses are in the list, or if they are chained...
    // Potential algorithm: 
      // When you need more instances of superclass, increase their instance count (including abstract/interface)
      // When you need more instances of subclass, try to "promote" instances of superclass, otherwise create new instances
      // At the end of algorithm if abstract/interface have >0 instance count, forcefully distribute them among the subclasses, and continue algorithm
        // How do I ensure this does not expand the model and create an infinite loop when not needed?
        // If subclass has associations that eventually link back to the superclass with product multiplicity >1, then its an infinite loop...
        // So in the last step we could create a function that searches each subclass for infinite loops and eliminates them from the options

    
    ClassInstanceCountSet classInstanceResult = new ClassInstanceCountSet(model);
    classInstanceResult.initializeClassCountsConstant(1);
    // Chances of the minimum instance values
    //Map<Integer, Double> minimumInstanceProbabilities = new HashMap<>();
    //minimumInstanceProbabilities.put(1, 0.33);
    //minimumInstanceProbabilities.put(2, 0.33);
    //minimumInstanceProbabilities.put(3, 0.33);
    //classInstanceResult.getInstanceCounts(100, 500, classInstanceResult.getRandomInitialClassCounts(minimumInstanceProbabilities));
    classInstanceResult.getInstanceCounts(100, 500);
    
    // TODO: Output errors
    if (classInstanceResult.statusCode == 1) {
      outputCode += "Reached maximum iterations. Ensure that the system is instantiable and non-infinite";
      model.setCode(outputCode);
      writeModelToFile();
      return;
    } else if (classInstanceResult.statusCode == 2) {
      outputCode += "Reached maximum class count. Ensure that the system is instantiable and non-infinite";
      model.setCode(outputCode);
      writeModelToFile();
      return;
    }
    
    // Get class count result
    Map<String, Integer> minInstance = classInstanceResult.getInstanceCountMap();
    // Get associations from the class count
    ArrayList<AssociationLinkSet> actualLinks = classInstanceResult.distributeAssociations(true);


    StringBuilder code = new StringBuilder();           // part of the gv file with the node/classes
    StringBuilder associations = new StringBuilder();   // part of the gv file with all the associations

    // Output basic gv file header
    _graphStart(0,code);

    //gets the desired separator value. Graphviz default is 0.5 but for Umple we use 1.0 for 'normal'
    double sepVal = getSuboptionValue("gvseparator", 1.0); 
    //checks if the separator value is not 1.0 (Umple default which will be 0.5 in Graphviz).
    // If it isn't it applies the desired separator value to nodesep and ranksep
    if (sepVal != 1.0){
      Double graphVizSepVal = sepVal/2.0;
      code.append("nodesep =" + graphVizSepVal +";"); //injects sepVal(desired separator value) into nodesep
      code.append("ranksep =" + graphVizSepVal +";"); //injects sepVal(desired separator value) into ranksep
    }

    for (UmpleClass umpClass : model.getUmpleClasses()) { // looping through the model. need to extract the attribute information.
      if (umpClass.getIsAbstract()){                      // we do not consider abstract classes in instance diagrams
          continue;
      }
      String currentInstanceName = umpClass.getName();
      Integer numberOfInstaces = minInstance.get(currentInstanceName);    // minInstance may change at a later date
      for (int i = 0; i < numberOfInstaces; i++) {
        createInstance(umpClass, code, i + 1);
      }
    }

    for (int k = 0; k < actualLinks.size(); k++) {
      AssociationLinkSet assocLinkSet = actualLinks.get(k);

      Association uAssoc = assocLinkSet.getAssociation();
      AssociationEnd leftEnd = uAssoc.getEnd(0);
      AssociationEnd rightEnd = uAssoc.getEnd(1);
      String leftClass = leftEnd.getClassName();
      String rightClass = rightEnd.getClassName();
      for (int i = 0; i < assocLinkSet.links.length; i++) {
        for (int j = 0; j < assocLinkSet.links[0].length; j++) {
          if (assocLinkSet.links[i][j]){
            int iplus1 = i + 1;
            int jplus1 = j + 1;
            String leftInstance = leftClass + iplus1;
            String rightInstance = rightClass + jplus1;
            AssociationCreate(uAssoc, associations, leftInstance, rightInstance);  // creates the association
          }
        }
      }
    }

    terminateCode(code, associations);


    // TODO: Remove printing the output to a text file
    /*
    for (Map.Entry<String, Integer> entry : minInstance.entrySet()) {
      outputCode += entry.getKey() + " - " + entry.getValue() + "\n";
    }
    for (AssociationLinkSet link : actualLinks) {
      outputCode += "\n" + link.toString();
    }
    model.setCode(outputCode);
    writeModelToFile();
    */
  }

  public void createInstance(UmpleClass umpClass, StringBuilder code, int iteration){

    boolean manyClass = getModel().getUmpleClasses().size() >= 200 ? true : false;

    String className = umpClass.getName();
    String instanceName = className + iteration + ": " + className;
    String classColor = umpClass.getDisplayColor();
    if (!classColor.equals("")) classColor=" style=filled, fillcolor="+classColor+" ";
    code.append("\n  // Instance: "+className + iteration+"\n");
    
    if (manyClass) {
      code.append("  \""+className + iteration+"\" ["+classColor+"shape=record, label=\"{"+instanceName);
    } 
    else {
      code.append("  \""+className + iteration+"\" ["+classColor+"shape=plaintext margin=0 label=");
	    
      // Different cellpadding for if the class has nothing but the
      // name because of a glitch in graphviz's graphics
      if (umpClass.getAttributes().size() == 0 || hasSuboption("hideattributes")) {
	    code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"10\">"
		   			+"<tr><td>    "+instanceName+"    </td></tr>");
      }
      else {
        code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"2\">"
                    +"<tr><td cellpadding=\"4\">    "+instanceName+"    </td></tr>");
		  }
    }

    attributeCreation(umpClass, code, manyClass);  // creates the attributes for the particular instance

    // Terminate outputting the class attributes
    if(manyClass) code.append("}\"");
   	else code.append("</table>>"); 
    
    
    // Output the tooltip : Class name followed by any comment
    code.append(",\n   tooltip=\"instance "+className + iteration+"\n");
    code.append(SuperGvGenerator.appendTooltipComment(umpClass.getComments(), false));
    code.append("\"");

    // Terminate the class as a whole
    code.append("];\n");
  }

  private void attributeCreation(UmpleClass uClass, StringBuilder code, boolean manyClass){
    // Iterate through attributes of the class
    boolean isFirst = true;

    if (!hasSuboption("hideattributes")) { 
      for (Attribute uAttribute : uClass.getAttributes()) {
        if (!uAttribute.isConstant()) 
        {
          String instanceAttribute = createRandomAttributeValue(uAttribute);  // this will take into account if the attribute is a list or not
          
          if (manyClass) {
            if (isFirst) code.append("|"); // attribute block starter
            else code.append("\\\n"); // separator between attributes
          }
          else {
            if (isFirst) code.append("<hr/>"); // attribute block starter
          }

          String isList = uAttribute.getIsList() ? "[]" : "";
          String type = uAttribute.getType().replace("<","&lt;").replace(">","&gt;");
          
          if (manyClass) {
            code.append(""+uAttribute.getName()+"\\:\\ "+instanceAttribute+"\\l");
          }
          else {
            StringBuilder attrTooltip = new StringBuilder();
            attrTooltip.append(type+isList+" "+uAttribute.getName()+"&#13;");
            attrTooltip.append(SuperGvGenerator.appendTooltipComment(uAttribute.getComments(), true));        
            code.append("<tr><td align=\"left\" href=\"\" title=\""+attrTooltip+"\">"
                +"  "+uAttribute.getName()+": "
                +instanceAttribute+"  </td></tr>");
          }
        } else { //attribute is constant
          // Not sure if this is needed. in the Class diagram constant variables are ignored.
          // could just leave this empty
        }
          isFirst = false;
      }
    }
  }

  private String createRandomAttributeValue(Attribute uAttribute){ //TODO Make this function better
    if (uAttribute.getIsList()){
      return "[A,B,C]";
    }
    return "A";
  }

  public void AssociationCreate(Association uAssoc, StringBuilder associations, String left, String right){
    String[] arrows = SuperGvGenerator.retArrows(uAssoc);
    String toolTip = "testToolTip";
    associations.append(SuperGvGenerator.twoLabelAssociation(left, right, arrows[0], "", "", toolTip));
  }

  // Output the instance diagram to a text file
  private void writeModelToFile()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + 
        model.getUmpleFile().getSimpleFileName() + ".txt";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException(
        "There was a problem generating the Instance Diagram." + e, e);
    }
  }

}

/*
 Data class to hold the number of class instances
*/
class ClassInstanceCount {
  depend java.util.*;

  public Integer instanceCount;
  // Set of subclasses (unordered and unique)
  public Set<String> subClasses;
  public Boolean instanceCountCanChange;
}

/*
  Class to hold the number of class instances for a given umple model
*/
class ClassInstanceCountSet {
  depend java.util.*;

  // Status of the ClassInstanceCountSet object 
  // -1 is invalid, 0 is valid, 1 is maxIter reached, 2 is maxInstances reached
  public int statusCode = -1;

  internal UmpleModel umpleModel;

  // Map with each class and it's instance counts (not an arraylist since classes are unordered and unique)
  public Map<String, ClassInstanceCount> instances;

  public Map<String, Integer> getInstanceCountMap() {
    Map<String, Integer> result = new HashMap<>();
    for (Map.Entry<String, ClassInstanceCount> entry  : this.instances.entrySet()) {
      result.put(entry.getKey(), entry.getValue().instanceCount);
    }
    return result;
  }

  /*
    We can represent the system as a graph problem. 
    Each class is a node, and each association is 2 directed links between the nodes.
    For every link, the class count at the start multiplied by the multiplicity must be smaller/equal to the class count at the end.
    
    If you have the link A 2..4 -> 3..6 B, for every 2..4 As, there must be 3..6 Bs.
    Thus, we have the following tightest inequality; for every 4 or less As, there must be at at least 3 Bs
    There can be less As, or more Bs, but this equality must hold true.
    So for A = 1-4 there are >3 Bs, for A = 5-8 there are >6 Bs
    
    Algorithm:
    Initialize all class counts to their initial value
    Loop through every association
      End = max(End, lowerEnd*ceil(Start/UpperStart))
    Repeat until no more changes appear
  
    Creates a Map of classnames and their minimum class counts
  */
  public void getInstanceCounts(int maxIter, int maxClasses) {
    int loopStatus = -1;
    boolean noChange = false;
    int iteration = -1;
    // Run infinite loop
    while (true) {
      iteration++;

      // Check if the system has stabilized (all associations are satisfied)
      if (noChange) {
        loopStatus = 0;
        break;
      }
      noChange = true;

      // Check if we've reached max iterations
      if (iteration >= maxIter) {
        loopStatus = 1;
        break;
      }

      // Check if we've reached max class counts
      int sum = 0;
      for (ClassInstanceCount n: this.instances.values()) {
        sum += n.instanceCount;
      }
      if (sum > maxClasses) {
        loopStatus = 2;
        break;
      }

      for (Association assoc : umpleModel.getAssociations()) {
        int lowerLeft = assoc.getEnd(0).getMultiplicity().getLowerBound();
        int upperLeft = assoc.getEnd(0).getMultiplicity().getUpperBound();
        int lowerRight = assoc.getEnd(1).getMultiplicity().getLowerBound();
        int upperRight = assoc.getEnd(1).getMultiplicity().getUpperBound();

        // For directional associations, there are 3 situations for the multiplicity on the unmanaged side:
        // - 0..1: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... no changes required
        // - *: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... convert it to 0..1
        // - 2, 2..4, anything: The user has ignored Warning036...
        //                      We will assume the user wishes to enforce that multiplicity; so pretend its bidirectional... no changes required
        if (!assoc.getIsLeftNavigable() && upperLeft==-1) {
          lowerLeft = 0;
          upperLeft = 1;
        }
        if (!assoc.getIsRightNavigable() && upperRight==-1) {
          lowerRight = 0;
          upperRight = 1;
        }

        // Get the current count for the classes
        Integer oldInstanceLeft = this.instances.get(assoc.getEnd(0).getClassName()).instanceCount;
        Integer oldInstanceRight = this.instances.get(assoc.getEnd(1).getClassName()).instanceCount;

        // How many left instances do we need? 
        // LinksPerRight*ceil(Right/HowManyLinksCanEachLeftHold)
        Integer newInstanceLeft;
        if (upperRight!=-1) {
          newInstanceLeft = Integer.valueOf((int)(lowerLeft*Math.ceil(oldInstanceRight/upperRight)));
        } else {
          // Ceiling of (?/*) will always be 1 since * is an extremely large constant
          newInstanceLeft = Integer.valueOf((int)(lowerLeft));
        }
        // If the new required instance is higher, replace the old instance count
        if (newInstanceLeft > oldInstanceLeft) {
          noChange = false;
          this.instances.get(assoc.getEnd(0).getClassName()).instanceCount = newInstanceLeft;
        }

        // How many right instances do we need?
        // LinksPerLeft*ceil(Left/HowManyLinksCanEachRightHold)
        Integer newInstanceRight;
        if (upperLeft!=-1) {
          newInstanceRight = Integer.valueOf((int)(lowerRight*Math.ceil(oldInstanceLeft/upperLeft)));
        } else {
          // Ceiling of (?/*) will always be 1 since * is an extremely large constant
          newInstanceRight = Integer.valueOf((int)(lowerRight));
        }
        // If the new required instance is higher, replace the old instance count
        if (newInstanceRight > oldInstanceRight) {
          noChange = false;
          this.instances.get(assoc.getEnd(1).getClassName()).instanceCount = newInstanceRight;
        }

      }
    }

    // Set the resulting status code
    this.statusCode = loopStatus;
    return;
  }

  private void initializeClassCount(UmpleClass umpleClass, Integer classCount) {
    ClassInstanceCount newClassCount = new ClassInstanceCount();
    
    // Set subclasses
    newClassCount.subClasses = new HashSet<String>();
    for (UmpleClass subclass : umpleClass.getSubclasses()) {
      newClassCount.subClasses.add(subclass.getName());
    }
    
    // Set instance count and canChange flag
    if (umpleClass.getIsAbstract()) {
      newClassCount.instanceCount = 0;
      newClassCount.instanceCountCanChange = false;
    } else if (umpleClass.getIsSingleton()) {
      newClassCount.instanceCount = 1;
      newClassCount.instanceCountCanChange = false;
    } else {
      newClassCount.instanceCount = classCount;
      newClassCount.instanceCountCanChange = true;
    }
    
    // Add to the map
    this.instances.put(umpleClass.getName(), newClassCount);
  }

  // Set each class initially to a constant amount of instances
  public void initializeClassCountsConstant(Integer constInt) {
    this.instances = new HashMap<>();

    // For each class
    for (UmpleClass umpleClass : umpleModel.getUmpleClasses()) {
      initializeClassCount(umpleClass, constInt);
    }
  }

  /*
    Generate the initial class counts randomly.
    Parameter "minimumInstanceProbabilities" is a map of initial instance counts to their probabilities
  */
  public void initializeClassCountsRandom(Map<Integer, Double> minimumInstanceProbabilities) {    
    this.instances = new HashMap<>();
    
    // Seed Random
    Random randomNumGen = new Random();
    // For each class
    for (UmpleClass umpClass : umpleModel.getUmpleClasses()) {
      double randDouble = randomNumGen.nextDouble();
      double cumulative = 0.0;
      // Loop through the probabilities to randomly select a value 
      for (Map.Entry<Integer, Double> entry : minimumInstanceProbabilities.entrySet()) {
        cumulative += entry.getValue();
        if (randDouble <= cumulative) {
          // Initialize the class with the random value
          initializeClassCount(umpClass, entry.getKey());
          // Move on to next class
          break;
        }
      }
    }
  }

  /*
    Using the number of instance of each class, get the associations between the instances.
    The maxLinks boolean determines if you max or min number of links between the sets of instances

    Returns an arraylist of AssociationLinkSet, which is a data class
  */
  public ArrayList<AssociationLinkSet> distributeAssociations(boolean maxLinks) {
    ArrayList<AssociationLinkSet> result = new ArrayList<AssociationLinkSet>();
    
    // Loop through associations
    for (Association assoc : umpleModel.getAssociations()) {
      AssociationLinkSet nextAssoc = new AssociationLinkSet(
        assoc, 
        this.instances.get(assoc.getEnd(0).getClassName()).instanceCount, 
        this.instances.get(assoc.getEnd(1).getClassName()).instanceCount
      );
      nextAssoc.getLinksFromAssociation(maxLinks);
      result.add(nextAssoc);
    }

    return result;
  }

}

/*
 Data class to hold a 2D matrix of links between 2 classes (for 1 association)

 Call getLinksFromAssociation() in order to populate the "links" attribute
*/
class AssociationLinkSet {
  public boolean[][] links;
  internal Association association;
  internal Integer classCountStart;
  internal Integer classCountEnd;

  /*
    Given the num of instances of each class, get the associations/links between each instance.
    Creates a matrix of the links between classes for a given association
    The matrix is classCountStart by classCountEnd, and the boolean entries represent if there is a link between class instances

    Algorithm:
    Check which class is the limiting factor
    Take the limiting class (lets say B), begin assigning As round-robin until B links are satisfied
    
    Example: 
    For A 2..3 -- 2..7 B with 7 As and 10 Bs (getting the minimum links)
    B1 = A1, A2
    B2 = A3, A4
    B3 = A5, A6
    B4 = A7, A1
    B5 = A2, A3
    ...
    Each A should have at least its minimums (since B was the limiting class)
    A1 = B1, B4, B8
    A2 = B1, B5, B8
    ...
    A6 = B3, B7, B10
    A7 = B4, B7
  */
  public void getLinksFromAssociation(boolean getMaxLinks){
    boolean[][] result = new boolean[classCountStart][classCountEnd];

    // Reflexivity uses a different algorithm; Since there is only 1 set of instances instead of 2
    boolean isReflexive = association.getEnd(0).getClassName().equals(association.getEnd(1).getClassName());
    if (isReflexive) {
      // There is always a 0 lower bound on both ends (umple would throw an error otherwise)
      // So for minimum links we can simply return no links
      if (!getMaxLinks) {
        this.links = result;
        return;
      }

      // TODO: Implement reflexive associations
      // Symmetric, Asymmetric, Asymmetric hierarchy; all have different rules

      this.links = result;
      return;
    }

    // Minimum links is the number of classes multiplied by the lower bound on the other end
    // Maximum links is the number of classes multiplied by the upper bound on the other end
    int endLower = association.getEnd(1).getMultiplicity().getLowerBound();
    int endUpper = association.getEnd(1).getMultiplicity().getUpperBound();
    int startLower = association.getEnd(0).getMultiplicity().getLowerBound();
    int startUpper = association.getEnd(0).getMultiplicity().getUpperBound();
    
    // The maximum links for a * upper bound is #OfInstances of the other class (you cannot link to 11 Bs if there are only 10 Bs)
    if (endUpper == -1) {endUpper = classCountStart;}
    if (startUpper == -1) {startUpper = classCountEnd;}

    int maximumLinksStart = classCountStart*endUpper;
    int minimumLinksStart = classCountStart*endLower;
    int maximumLinksEnd = classCountEnd*startUpper;
    int minimumLinksEnd = classCountEnd*startLower;

    boolean startLimiting;
    if (getMaxLinks) {
      startLimiting = (maximumLinksStart < maximumLinksEnd)? true : false;
    } else {
      startLimiting = (minimumLinksStart > minimumLinksEnd)? true : false;
    }

    // Loop through whichever end is the limiting factor
    if (startLimiting) {
      
      int roundRobinCount = 0;
      // For each instance in set "start"
      for (int i=0;i<classCountStart;i++) {
        // Loop through either max or min links - creating links
        for (int linkCount=0; linkCount<(getMaxLinks? endUpper : endLower) ;linkCount++) { 
          result[i][roundRobinCount] = true;
          roundRobinCount = (roundRobinCount+1)%classCountEnd;
        }
      }

    } else {

      int roundRobinCount = 0;
      // For each class in set "end"
      for (int i=0;i<classCountEnd;i++) {
        // Loop through either max or min links - creating links
        for (int linkCount=0; linkCount<(getMaxLinks? startUpper : startLower) ;linkCount++) {
          result[roundRobinCount][i] = true;
          roundRobinCount = (roundRobinCount+1)%classCountStart;
        }
      }

    }

    this.links = result;
    return;
  }

  public String toString() {
    String result = "";
    
    result += "("+classCountStart+")"+this.association.getEnd(0).getClassName();
    result += " X ";
    result += "("+classCountEnd+")"+this.association.getEnd(1).getClassName();
    result += "\n";
    for (int i=0;i<links.length;i++) {
      result += "|";
      for (int j=0;j<links[i].length;j++) {
        result += " " + (links[i][j] ? "1" : "0") + " ";
      }
      result += "|\n";
    }

    return result;
  }

  public Association getAssociation(){
    return this.association;
  }

}