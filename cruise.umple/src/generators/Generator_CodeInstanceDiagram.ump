/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
https://umple.org/license

This file generates a randomized instance diagram and the resulting objects
for every class in the model. The results of these instances is output
to a GV Diagram.

Command line action for this is
  -g InstanceDiagram

 */
namespace cruise.umple.compiler;

class InstanceDiagramGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend java.sql.Time;
  depend java.sql.Date;
  depend cruise.umple.util.*;
  depend cruise.umple.compiler.exceptions.*;

  protected String generatorType()
  {
    return "cid";
  }

  // Template for what will appear at the start of each graphviz file
  graphStart(umpleVersion) <<! /*This code was generated using the UMPLE <<=umpleVersion>> modeling language! */
  
  digraph InstanceDiagram {
    node [shape=rectangle]
    edge [arrowhead=none]
  !>>

  emit graphStart()(graphStart(UmpleModel.VERSION_NUMBER));

  protected void terminateCode(StringBuilder code, StringBuilder associations) {

    code.append("\n  // All associations\n");
    code.append(associations);

    code.append("}\n");

    model.setCode(code.toString());
    writeModel();
  }

  // Output the graphviz file to a file with the .gv suffix
  protected void writeModel()
  {
    try
    {
      String outputDir = getModel().getUmpleFile().getPath();
      String path = StringFormatter.addPathOrAbsolute(outputDir, "");
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName()
          + generatorType() + ".gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz Diagram code." + e, e);
    }
  } 

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  String outputCode = "";
  Random attributeRandomGen = new Random(67); // Set the seed used for the generation of random attributes
  
  // Meta variables - These should be passed as suboptions
  int suboptionLinkingFlag = 2; // 2 is Random
  int suboptionInitialClassCountFlag = -1; // -1 is Random
  int suboptionMaxIterations = 100;
  int suboptionMaxClassCount = 500;

  public void generate()
  {


    // TODO: Handle reflexive associations with non-zero links

    // Note: The odds of a superclass remaining in the diagram is low.
    // If we start with 1 instance of superclass and 1 of subclass, the system will assume that its 1 polymorphic instance
    // Should we prevent this?

    // Create class instance object
    ClassInstanceCountSet classInstanceResult = new ClassInstanceCountSet(model);

    // Initialize class counts
    if (suboptionInitialClassCountFlag == -1) {
      Map<Integer, Double> minimumInstanceProbabilities = new HashMap<>();
      minimumInstanceProbabilities.put(1, 0.33);
      minimumInstanceProbabilities.put(2, 0.33);
      minimumInstanceProbabilities.put(3, 0.33);
      classInstanceResult.initializeClassCountsRandom(minimumInstanceProbabilities);
    } else {
      classInstanceResult.initializeClassCountsConstant(suboptionInitialClassCountFlag);
    }
    
    // Run the instance count algorithm
    classInstanceResult.getInstanceCounts(suboptionMaxIterations, suboptionMaxClassCount);
    
    // TODO: Output errors properly
    if (classInstanceResult.statusCode == 1) {
      outputCode += "Reached maximum iterations. Ensure that the system is instantiable and non-infinite";
      model.setCode(outputCode);
      writeModelToFile();
      return;
    } else if (classInstanceResult.statusCode == 2) {
      outputCode += "Reached maximum class count. Ensure that the system is instantiable and non-infinite";
      model.setCode(outputCode);
      writeModelToFile();
      return;
    } else if (classInstanceResult.statusCode == 3) {
      outputCode += "Inheritance unresolvable. Ensure that all abstract/interface classes have concrete implementations that can be instantiated";
      model.setCode(outputCode);
      writeModelToFile();
      return;
    }

    // Get class count result
    Map<String, Integer> minInstance = classInstanceResult.getInstanceCountMap();
    // Get associations from the class count
    ArrayList<AssociationLinkSet> actualLinks = classInstanceResult.distributeAssociations(suboptionLinkingFlag);


    StringBuilder code = new StringBuilder();           // part of the gv file with the node/classes
    StringBuilder associations = new StringBuilder();   // part of the gv file with all the associations

    // Output basic gv file header
    _graphStart(0,code);

    //gets the desired separator value. Graphviz default is 0.5 but for Umple we use 1.0 for 'normal'
    double sepVal = getSuboptionValue("gvseparator", 1.0); 
    //checks if the separator value is not 1.0 (Umple default which will be 0.5 in Graphviz).
    // If it isn't it applies the desired separator value to nodesep and ranksep
    if (sepVal != 1.0){
      Double graphVizSepVal = sepVal/2.0;
      code.append("nodesep =" + graphVizSepVal +";"); //injects sepVal(desired separator value) into nodesep
      code.append("ranksep =" + graphVizSepVal +";"); //injects sepVal(desired separator value) into ranksep
    }

    for (UmpleClass umpClass : model.getUmpleClasses()) { // looping through the model. need to extract the attribute information.
      if (umpClass.getIsAbstract()){                      // we do not consider abstract classes in instance diagrams
          continue;
      }
      String currentInstanceName = umpClass.getName();
      Integer numberOfInstaces = minInstance.get(currentInstanceName);    // minInstance may change at a later date
      for (int i = 0; i < numberOfInstaces; i++) {
        createInstance(umpClass, code, i + 1);
      }
    }

    Map<String, ClassInstanceCount> classInstanceCountMap = classInstanceResult.instances;

    for (int k = 0; k < actualLinks.size(); k++) {
      AssociationLinkSet assocLinkSet = actualLinks.get(k);

      Association uAssoc = assocLinkSet.getAssociation();
      AssociationEnd leftEnd = uAssoc.getEnd(0);
      AssociationEnd rightEnd = uAssoc.getEnd(1);
      String leftClass = leftEnd.getClassName();
      String rightClass = rightEnd.getClassName();

      String leftRoleName = leftEnd.getDisplayRoleName();
      String rightRoleName = rightEnd.getDisplayRoleName();

      ArrayList<String> leftInstanceList = new ArrayList<String>();
      ArrayList<String> rightInstanceList = new ArrayList<String>();

      PopulateInstanceList(leftClass , classInstanceCountMap , leftInstanceList);
      PopulateInstanceList(rightClass, classInstanceCountMap , rightInstanceList);

      for (int i = 0; i < assocLinkSet.links.length; i++) {
        for (int j = 0; j < assocLinkSet.links[0].length; j++) {
          if (assocLinkSet.links[i][j]){

            AssociationCreate(uAssoc, associations, leftInstanceList.get(i), rightInstanceList.get(j), leftRoleName, rightRoleName);  // creates the association
          }
        }
      }
    }

    terminateCode(code, associations);


    // TODO: Remove printing the output to a text file
    /*
    for (Map.Entry<String, Integer> entry : minInstance.entrySet()) {
      outputCode += entry.getKey() + " - " + entry.getValue() + "\n";
    }
    for (AssociationLinkSet link : actualLinks) {
      outputCode += "\n" + link.toString();
    }
    model.setCode(outputCode);
    writeModelToFile();
    */
  }

  public void PopulateInstanceList(String currentClassName ,Map<String, ClassInstanceCount> classInstanceCountMap, ArrayList<String> instanceList){

    ClassInstanceCount currentClassInstanceCount = classInstanceCountMap.get(currentClassName);
    
    for (int i = 1; i < currentClassInstanceCount.trueInstances + 1; i++) {
      instanceList.add(currentClassName + i);
    }

    Iterator value = currentClassInstanceCount.subClasses.iterator();
    
    while (value.hasNext()) {
      PopulateInstanceList(value.next().toString(), classInstanceCountMap, instanceList);
    }
  }

  public void createInstance(UmpleClass umpClass, StringBuilder code, int iteration){

    boolean manyClass = getModel().getUmpleClasses().size() >= 200 ? true : false;
    boolean firstAttributeIsId = false;
    String firstAttributeInstanceName = "";   // if the first attribute is "name" use as instance name. Do not use className
    String className = umpClass.getName();
    String instanceName = "";

    if (umpClass.getAttributes().size() != 0){
      Attribute firstAttribute = umpClass.getAttributes().get(0);
      String firstAttributeName = firstAttribute.getName();
      int attributeNameLength = firstAttributeName.length();



      // If the first attribute is literally "id" case insensitive OR the last 2 characters are literally "Id" or "ID"
      // and the type is String or Integer
      if ( 
        (firstAttributeName.toLowerCase().equals("id")  || 
        (firstAttributeName.length() > 1 && 
        (firstAttributeName.substring(firstAttributeName.length() - 2).equals("Id") ||
        firstAttributeName.substring(firstAttributeName.length() - 2).equals("ID")))) &&
        (firstAttribute.getType().equals("String") || firstAttribute.getType().equals("Integer"))
        ) {
        firstAttributeIsId = true;
        instanceName = className + iteration + ": " + className;

        // if the first attribute is called "name" and is type String
      } else if (firstAttributeName.toLowerCase().equals("name") && firstAttribute.getType().equals("String")){
        firstAttributeInstanceName = createRandomAttributeValue(firstAttribute);
        instanceName = firstAttributeInstanceName + iteration + ": " + className;
      } else{
        instanceName = className + iteration + ": " + className;
      }
    
    } else{
      instanceName = className + iteration + ": " + className;
    }


    
    String classColor = umpClass.getDisplayColor();
    if (!classColor.equals("")) classColor=" style=filled, fillcolor="+classColor+" ";
    code.append("\n  // Instance: "+className + iteration+"\n");
    
    if (manyClass) {
      code.append("  \""+className + iteration+"\" ["+classColor+"shape=record, label=\"{"+instanceName);
    } 
    else {
      code.append("  \""+className + iteration+"\" ["+classColor+"shape=plaintext margin=0 label=");
	    
      // Different cellpadding for if the class has nothing but the
      // name because of a glitch in graphviz's graphics
      if (umpClass.getAttributes().size() == 0 || hasSuboption("hideattributes")) {
	    code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"10\">"
		   			+"<tr><td>    "+instanceName+"    </td></tr>");
      }
      else {
        code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"2\">"
                    +"<tr><td cellpadding=\"4\">    "+instanceName+"    </td></tr>");
		  }
    }

    attributeCreation(umpClass, code, manyClass, firstAttributeIsId, firstAttributeInstanceName, iteration);  // creates the attributes for the particular instance

    // Terminate outputting the class attributes
    if(manyClass) code.append("}\"");
   	else code.append("</table>>"); 
    
    
    // Output the tooltip : Class name followed by any comment
    code.append(",\n   tooltip=\"instance "+className + iteration+"\n");
    code.append(SuperGvGenerator.appendTooltipComment(umpClass.getComments(), false));
    code.append("\"");

    // Terminate the class as a whole
    code.append("];\n");
  }

  private void attributeCreation(UmpleClass uClass, StringBuilder code, boolean manyClass, boolean hasId, String instanceName, int idValue){
    // Iterate through attributes of the class
    boolean isFirst = true;

    if (!hasSuboption("hideattributes")) { 
      for (Attribute uAttribute : uClass.getAttributes()) {
        if (!uAttribute.isConstant()) 
        { 
          String instanceAttribute;

          if (isFirst && (hasId)){
            instanceAttribute = Integer.toString(idValue);
          } else if (isFirst && instanceName.length() != 0){
            instanceAttribute = instanceName;
          } else {
            instanceAttribute = createRandomAttributeValue(uAttribute);  // this will take into account if the attribute is a list or not
          }
          
          
          if (manyClass) {
            if (isFirst) code.append("|"); // attribute block starter
            else code.append("\\\n"); // separator between attributes
          }
          else {
            if (isFirst) code.append("<hr/>"); // attribute block starter
          }

          String isList = uAttribute.getIsList() ? "[]" : "";
          String type = uAttribute.getType().replace("<","&lt;").replace(">","&gt;");
          
          if (manyClass) {
            code.append(""+uAttribute.getName()+"\\:\\ "+instanceAttribute+"\\l");
          }
          else {
            StringBuilder attrTooltip = new StringBuilder();
            attrTooltip.append(type+isList+" "+uAttribute.getName()+"&#13;");
            attrTooltip.append(SuperGvGenerator.appendTooltipComment(uAttribute.getComments(), true));        
            code.append("<tr><td align=\"left\" href=\"\" title=\""+attrTooltip+"\">"
                +"  "+uAttribute.getName()+": "
                +instanceAttribute+"  </td></tr>");
          }
        } else { //attribute is constant
          // Not sure if this is needed. in the Class diagram constant variables are ignored.
          // could just leave this empty
        }
          isFirst = false;
      }
    }
  }

  private String createRandomAttributeValue(Attribute uAttribute){ //TODO Make this function better
    String type = uAttribute.getType().replace("<","&lt;").replace(">","&gt;");

    if (uAttribute.getIsList()){
      String listString = "[";
      listString = listString + randomAttributeTypeGen(type);
      listString = listString + ", " + randomAttributeTypeGen(type);
      listString = listString + ", ... ]";
      return listString;
    }
    
    return randomAttributeTypeGen(type);

  }

  public String randomAttributeTypeGen(String type){
      
    if (type.equals("Boolean")){

      int trueFalseInt = attributeRandomGen.nextInt(2);
      if (trueFalseInt == 1){
        return "true";
      } else{
        return "false";
      }

    } else if (type.equals("Integer")){

      int randomInt = attributeRandomGen.nextInt(1000) - 500;
      return Integer.toString(randomInt);

    } else if (type.equals("Double") || type.equals("Float")){

      Float randomFloat = attributeRandomGen.nextFloat()* 1000 - 500;
      String randomFloatString = randomFloat.toString();
      return randomFloatString.substring(0, 6);

    } else if (type.equals("String")){

      return randomStringGen();

    } else if (type.equals("Date")){

      long randomLong = attributeRandomGen.nextLong()  % 1760000000000l;
      Date date = new Date(randomLong);
      return date.toString();

    } else if (type.equals("Time")){

      long randomLong = attributeRandomGen.nextLong()  % (60 * 60 * 24 * 1000);
      Time time = new Time(randomLong);
      return time.toString();

    } else{
      return randomStringGen();
      // copy the string code here
    }
  }

  public String randomStringGen(){
    String[] wordBank = {"Beans","Cake","Mother","Snake","Steal"};
    int randomInt = attributeRandomGen.nextInt(5);
    return wordBank[randomInt];
  }

  public void AssociationCreate(Association uAssoc, StringBuilder associations, String left, String right, String leftRoleName, String rightRoleName){
    AssociationEnd leftEnd = uAssoc.getEnd(0);
    AssociationEnd rightEnd = uAssoc.getEnd(1);
    String leftClass = leftEnd.getClassName();
    String rightClass = rightEnd.getClassName();

    String[] arrows = SuperGvGenerator.retArrows(uAssoc);
    String toolTip = leftClass + " " + leftRoleName + " " + arrows[1] + " " + rightRoleName + " " + rightClass;
    associations.append(SuperGvGenerator.twoLabelAssociation(left, right, arrows[0], rightRoleName, leftRoleName, toolTip));
  }

  // Output the instance diagram to a text file
  private void writeModelToFile()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + 
        model.getUmpleFile().getSimpleFileName() + ".txt";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException(
        "There was a problem generating the Instance Diagram." + e, e);
    }
  }

}

/*
 Data class to hold the number of class instances
*/
class ClassInstanceCount {
  depend java.util.*;

  // Number of instances required for this class (including polymorphed subclasses)
  public Integer requiredInstances;
  // Number of concrete instances of this class required (does not include polymorphed subclasses)
  public Integer trueInstances;
  // Set of subclasses (unordered and unique)
  public Set<String> subClasses;
  // -1 means no limit, 0 (for abstract and interface), 1 (for singleton)
  public Integer maximumInstanceCount;
}

/*
  Class to hold the number of class instances for a given umple model

  Provides methods/algorithms to calculate the number of class instances
*/
class ClassInstanceCountSet {
  depend java.util.*;

  // Status of the ClassInstanceCountSet object 
  // -1 is invalid, 0 is valid, 1 is maxIter reached, 2 is maxInstances reached, 3 is inheritance impossible
  public int statusCode = -1;

  internal UmpleModel umpleModel;

  // Map with each class and it's instance counts (not an arraylist since classes are unordered and unique)
  public Map<String, ClassInstanceCount> instances;

  // Get the number of instances for each class, interface, trait, etc...
  public Map<String, Integer> getInstanceCountMap() {
    Map<String, Integer> result = new HashMap<>();
    for (Map.Entry<String, ClassInstanceCount> entry  : this.instances.entrySet()) {
      result.put(entry.getKey(), entry.getValue().trueInstances);
    }
    return result;
  }

  /* 
    Recursive function to get the set of concrete instances of a class
    Will add the concrete classes to the "subclassSet" parameter
  */
  private void getConcreteSubclasses(String className, Set<String> subclassSet) {
    ClassInstanceCount topLevelInstance = this.instances.get(className);
    
    // If this instance is concrete, add it to the subclassSet
    if (topLevelInstance.maximumInstanceCount == -1) {
      subclassSet.add(className);
    }
    
    // Check this class' subclasses
    for (String subclassName : topLevelInstance.subClasses) {
      getConcreteSubclasses(subclassName, subclassSet);
    }
  }

  /* 
    Recursive function to get the total number of concrete instances of a class and it's subclasses
  */
  private Integer getNumberOfConcreteInstances(String className) {
    ClassInstanceCount topLevelInstance = instances.get(className);
    
    Integer result = 0;

    // Get number of concrete subclasses (recursive)
    for (String subclassName : topLevelInstance.subClasses) {
      result += getNumberOfConcreteInstances(subclassName);
    }

    // Now add the number for this class (base case)
    if (topLevelInstance.maximumInstanceCount == 0) {
      // For abstract/interface/etc... classes; add nothing
    } else if (topLevelInstance.maximumInstanceCount == 1) {
      // For singleton classes; add 1
      result += 1;
    } else if (topLevelInstance.maximumInstanceCount == -1) {
      // For regular classes, add the difference between required instances and the calculated subclasses
      int difference = topLevelInstance.requiredInstances - result;
      if (difference > 0) {
        result += difference;
      }
    }
    
    return result;
  }

  /*
    This function handles the logic for inheritance.

    For every abstract-class or interface, checks if there are enough concrete subclass instances to satisfy the required amount.
    For each unsatisfied class, determines the set of concrete classes that can be increased to satisfy the required amount.
    Ranks the concrete classes by how common they are in these "unsatisfied sets"
        - The more common they are, the more unsatisfied superclasses they can satisfy by gaining more instances
    Increases the concrete class counts by the required amount.
  
    Returns a status code as an integer
      - 0 : No inheritance issues
      - 1 : Inheritance issue detected, concrete class counts have been increased accordingly
      - 2 : Inheritance issue detected, unresolvable
  */
  private int satisfyInheritance() {
    // Map of each unsatisfied class to its concrete subclasses
    Map<String, Set<String>> unsatisfiedInheritance = new HashMap<>();

    for (Map.Entry<String, ClassInstanceCount> entry  : this.instances.entrySet()) {
      Integer instanceCountDifference = entry.getValue().requiredInstances - getNumberOfConcreteInstances(entry.getKey());

      if (instanceCountDifference > 0) {
        // Inheritance is not satisfied, we need more concrete instances
        Set<String> concreteSubclasses = new HashSet<>();
        getConcreteSubclasses(entry.getKey(), concreteSubclasses);
        unsatisfiedInheritance.put(entry.getKey(), concreteSubclasses);
      }
    }

    if (unsatisfiedInheritance.size() == 0) {
      // Inheritance is satisfied
      return 0;
    }


    // TODO: Prevent infinite loops
    // For each concrete, perform a search of the diagram to see if increasing the instance count would increase a superclass
    // Basically follow along the associations and generalizations looking for cycles. Calculate a set of multiplicities for the whole cycle
    // If the cycle multiplicities are >=1, then eliminate it from the set (since it creates an infinite loop)


    // Check if a concrete subclass set has size = 0; This means it is impossible to satisfy the system
    // This couldve been caused by a bad diagram or an infinite loop detection removal
    for (Set<String> entry : unsatisfiedInheritance.values()) {
      if (entry.size() == 0) {
        return 2;
      }
    }

    // Rank the subclasses by most common among the sets 
    // A common concrete subclass can satisfy multiple superclasses at once
    Map<String, Integer> concreteSubclassFrequency = new HashMap<>();
    for (Set<String> entry : unsatisfiedInheritance.values()) {
      for (String subclassName : entry) {
        int count = concreteSubclassFrequency.containsKey(subclassName) ? concreteSubclassFrequency.get(subclassName) : 0;
        concreteSubclassFrequency.put(subclassName, count+1);
      }
    }

    // Distribute required connections among the concrete subclasses
    for (Map.Entry<String, Set<String>> entry : unsatisfiedInheritance.entrySet()) {
      // Recalculate number of instances required (this is required since a previous iteration of this loop couldve changed it)
      Integer instanceCountDifference = this.instances.get(entry.getKey()).requiredInstances - getNumberOfConcreteInstances(entry.getKey());
      
      // Get best concrete subclass
      String best = "";
      Integer bestFreq = 0;
      for (String concreteSubclass : entry.getValue()) {
        int frequency = concreteSubclassFrequency.get(concreteSubclass);
        if (frequency > bestFreq) {
          bestFreq = frequency;
          best = concreteSubclass;
        }
      }

      // Increase the best concrete subclass by the desired number of instances
      this.instances.get(best).requiredInstances += instanceCountDifference;
    }

    return 1;
  }

  /* 
    Set the non-polymorphic count of every class. 
    This should only be run once the system is solved.

    Assumes that superclasses are sums of their subclasses and themselves.
    With this assumption we can simply subtract the counts of the DIRECT subclasses to get the number of non-polymorphic instances
  */
  private void setTrueInstanceCount() {
    for (Map.Entry<String, ClassInstanceCount> entry  : this.instances.entrySet()) {
      int current = entry.getValue().requiredInstances;
      // Loop through direct subclasses subtracting
      for (String directSubclass : entry.getValue().subClasses) {
        current -= this.instances.get(directSubclass).requiredInstances;
      }
      // Set number of non-polymorphic instances
      entry.getValue().trueInstances = current;
    }
  }

  // Make sure that the required instance count for superclasses is >= the number of concrete subclasses
  private void updateSuperclassInstanceCounts() {
    for (Map.Entry<String, ClassInstanceCount> entry  : this.instances.entrySet()) {
      entry.getValue().requiredInstances = Math.max(getNumberOfConcreteInstances(entry.getKey()), entry.getValue().requiredInstances);
    }
  }

  /*
    We can represent the system as a graph problem. 
    Each class is a node, and each association is 2 directed links between the nodes.
    For every link, the class count at the start multiplied by the multiplicity must be smaller/equal to the class count at the end.
    
    If you have the link A 2..4 -> 3..6 B, for every 2..4 As, there must be 3..6 Bs.
    Thus, we have the following tightest inequality; for every 4 or less As, there must be at at least 3 Bs
    There can be less As, or more Bs, but this equality must hold true.
    So for A = 1-4 there are >3 Bs, for A = 5-8 there are >6 Bs
    
    Algorithm:
    Initialize all class counts to their initial value
    Loop through every association
      End = max(End, lowerEnd*ceil(Start/UpperStart))
    Repeat until no more changes appear
  
    Creates a Map of classnames and their minimum class counts
  */
  public void getInstanceCounts(int maxIter, int maxClasses) {
    int loopStatus = -1;
    boolean noChange = false;
    int iteration = -1;
    // Run infinite loop
    while (true) {
      iteration++;

      // Ensure superclass counts are sums of their subclasses
      updateSuperclassInstanceCounts();

      // Check if the system has stabilized (all associations are satisfied)
      if (noChange) {
        // All associations are satisfied but inheritance may not be (abstract class count >= 1)

        // Run the inheritance logic
        int inheritanceStatus = satisfyInheritance();
        if (inheritanceStatus == 0) {
          // Everything is in order; associations satisfied, inheritance satisfied... End algorithm
          setTrueInstanceCount();
          loopStatus = 0;
          break;
        } else if (inheritanceStatus == 1) {
          // Inheritance was not satisfied (and the required instances have been changed), continue algorithm
        } else if (inheritanceStatus == 2) {
          // Inheritance was not satisfied and is impossible, return error
          loopStatus = 3;
          break;
        }
      }
      noChange = true;

      // Check if we've reached max iterations
      if (iteration >= maxIter) {
        loopStatus = 1;
        break;
      }

      // Check if we've reached max class counts
      int sum = 0;
      for (ClassInstanceCount n: this.instances.values()) {
        sum += n.requiredInstances;
      }
      if (sum > maxClasses) {
        loopStatus = 2;
        break;
      }

      for (Association assoc : umpleModel.getAssociations()) {
        int lowerLeft = assoc.getEnd(0).getMultiplicity().getLowerBound();
        int upperLeft = assoc.getEnd(0).getMultiplicity().getUpperBound();
        int lowerRight = assoc.getEnd(1).getMultiplicity().getLowerBound();
        int upperRight = assoc.getEnd(1).getMultiplicity().getUpperBound();

        // For directional associations, there are 3 situations for the multiplicity on the unmanaged side:
        // - 0..1: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... no changes required
        // - *: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... convert it to 0..1
        // - 2, 2..4, anything: The user has ignored Warning036...
        //                      We will assume the user wishes to enforce that multiplicity; so pretend its bidirectional... no changes required
        if (!assoc.getIsLeftNavigable() && upperLeft==-1) {
          lowerLeft = 0;
          upperLeft = 1;
        }
        if (!assoc.getIsRightNavigable() && upperRight==-1) {
          lowerRight = 0;
          upperRight = 1;
        }

        // Get the current count for the classes
        Integer oldInstanceLeft = this.instances.get(assoc.getEnd(0).getClassName()).requiredInstances;
        Integer oldInstanceRight = this.instances.get(assoc.getEnd(1).getClassName()).requiredInstances;

        // How many left instances do we need? 
        // LinksPerRight*ceil(Right/HowManyLinksCanEachLeftHold)
        Integer newInstanceLeft;
        if (upperRight!=-1) {
          newInstanceLeft = Integer.valueOf((int)(lowerLeft*Math.ceil((double)oldInstanceRight/(double)upperRight)));
        } else {
          // Ceiling of (?/*) will always be 1 since * is an extremely large constant
          newInstanceLeft = Integer.valueOf((int)(lowerLeft));
        }
        // If the new required instance is higher, replace the old instance count
        if (newInstanceLeft > oldInstanceLeft) {
          noChange = false;
          this.instances.get(assoc.getEnd(0).getClassName()).requiredInstances = newInstanceLeft;
        }

        // How many right instances do we need?
        // LinksPerLeft*ceil(Left/HowManyLinksCanEachRightHold)
        Integer newInstanceRight;
        if (upperLeft!=-1) {
          newInstanceRight = Integer.valueOf((int)(lowerRight*Math.ceil((double)oldInstanceLeft/(double)upperLeft)));
        } else {
          // Ceiling of (?/*) will always be 1 since * is an extremely large constant
          newInstanceRight = Integer.valueOf((int)(lowerRight));
        }
        // If the new required instance is higher, replace the old instance count
        if (newInstanceRight > oldInstanceRight) {
          noChange = false;
          this.instances.get(assoc.getEnd(1).getClassName()).requiredInstances = newInstanceRight;
        }

      }
    }

    // Set the resulting status code
    this.statusCode = loopStatus;
    return;
  }

  /* 
    Initialize the counting object for a Class.
  */
  private void initializeClassCount(UmpleClass umpleClass, Integer classCount) {
    ClassInstanceCount newClassCount = new ClassInstanceCount();
    
    // Set subclasses
    newClassCount.subClasses = new HashSet<String>();
    for (UmpleClass subclass : umpleClass.getSubclasses()) {
      newClassCount.subClasses.add(subclass.getName());
    }
    
    // Set instance count and maximum instance count
    if (umpleClass.getIsAbstract()) {
      newClassCount.requiredInstances = 0;
      newClassCount.maximumInstanceCount = 0;
    } else if (umpleClass.getIsSingleton()) {
      newClassCount.requiredInstances = 1;
      newClassCount.maximumInstanceCount = 1;
    } else {
      newClassCount.requiredInstances = classCount;
      newClassCount.maximumInstanceCount = -1;
    }
    
    // Add to the map
    this.instances.put(umpleClass.getName(), newClassCount);
  }

  /* 
    Initialize the counting object for an Interface.

    This method is horribly inefficient since interfaces do not have a "subclass" property;
    It has to search through every class and interface to check they "extend" this interface 
  */ 
  private void initializeInterfaceCount(UmpleInterface umpleInterface) {
    ClassInstanceCount newClassCount = new ClassInstanceCount();

    // Set subclasses 
    // Horribly inefficient: We have to search every class and interface to see which ones inherit
    newClassCount.subClasses = new HashSet<String>();
    // Loop through all interfaces to see which ones extend this interface
    for (UmpleInterface umpInt : umpleModel.getUmpleInterfaces()) {
      for (UmpleInterface extendedInt : umpInt.getExtendsInterface()) {
        // If the interface extends, add it to the subclass list
        if (extendedInt.getName().equals(umpleInterface.getName())) {
          newClassCount.subClasses.add(umpInt.getName());
        }
      }
    }
    // Loop through all classes to see which ones extend this interface
    for (UmpleClass umpClass : umpleModel.getUmpleClasses()) {
      for (UmpleInterface extendedInt : umpClass.getParentInterface()) {
        // If the interface extends, add it to the subclass list
        if (extendedInt.getName().equals(umpleInterface.getName())) {
          newClassCount.subClasses.add(umpClass.getName());
        }
      }
    }

    // Set instance count and maximum instance count
    newClassCount.requiredInstances = 0;
    newClassCount.maximumInstanceCount = 0;

    // Add to the map
    this.instances.put(umpleInterface.getName(), newClassCount);
  }

  /* 
    Initialize the counting object for an UmpleTrait.

    They can be represented similarly to an abstract/interface; 
      - They can be inherited but not instantiated
  */
  private void initializeTraitCount(UmpleTrait umpleTrait) {
    ClassInstanceCount newClassCount = new ClassInstanceCount();
    
    // Set subclasses
    newClassCount.subClasses = new HashSet<String>();
    for (UmpleClass subclass : umpleTrait.getSubClasses()) {
      newClassCount.subClasses.add(subclass.getName());
    }
    for (UmpleTrait subtrait : umpleTrait.getSubTraits()) {
      newClassCount.subClasses.add(subtrait.getName());
    }

    // Set instance count and maximum instance count
    newClassCount.requiredInstances = 0;
    newClassCount.maximumInstanceCount = 0;
   
    // Add to the map
    this.instances.put(umpleTrait.getName(), newClassCount);
  }

  // Set each class initially to a constant amount of instances
  public void initializeClassCountsConstant(Integer constInt) {
    this.instances = new HashMap<>();

    // For each class
    for (UmpleClass umpleClass : umpleModel.getUmpleClasses()) {
      initializeClassCount(umpleClass, constInt);
    }

    // For each interface
    for (UmpleInterface umpInt : umpleModel.getUmpleInterfaces()) {
      initializeInterfaceCount(umpInt);
    }

    // For each trait
    for (UmpleTrait umpTrait : umpleModel.getUmpleTraits()) {
      initializeTraitCount(umpTrait);
    }
  }

  /*
    Generate the initial class counts randomly.
    Parameter "minimumInstanceProbabilities" is a map of initial instance counts to their probabilities
  */
  public void initializeClassCountsRandom(Map<Integer, Double> minimumInstanceProbabilities) {    
    this.instances = new HashMap<>();
    
    // Seed Random
    Random randomNumGen = new Random();
    // For each class
    for (UmpleClass umpClass : umpleModel.getUmpleClasses()) {
      double randDouble = randomNumGen.nextDouble();
      double cumulative = 0.0;
      // Loop through the probabilities to randomly select a value 
      for (Map.Entry<Integer, Double> entry : minimumInstanceProbabilities.entrySet()) {
        cumulative += entry.getValue();
        if (randDouble <= cumulative) {
          // Initialize the class with the random value
          initializeClassCount(umpClass, entry.getKey());
          // Move on to next class
          break;
        }
      }
    }

    // For each interface
    for (UmpleInterface umpInt : umpleModel.getUmpleInterfaces()) {
      initializeInterfaceCount(umpInt);
    }

    // For each trait
    for (UmpleTrait umpTrait : umpleModel.getUmpleTraits()) {
      initializeTraitCount(umpTrait);
    }
  }

  /*
    Using the number of instance of each class, get the associations between the instances.

    The linkingFlag parameter determines the number of links to create:
    - 0 Minimum
    - 1 Maximum
    - 2 Random

    Returns an arraylist of AssociationLinkSet, which is a data class
  */
  public ArrayList<AssociationLinkSet> distributeAssociations(int linkingFlag) {
    ArrayList<AssociationLinkSet> result = new ArrayList<AssociationLinkSet>();
    
    // Loop through associations
    for (Association assoc : umpleModel.getAssociations()) {
      AssociationLinkSet nextAssoc = new AssociationLinkSet(
        assoc, 
        getNumberOfConcreteInstances(assoc.getEnd(0).getClassName()),
        getNumberOfConcreteInstances(assoc.getEnd(1).getClassName())
      );
      nextAssoc.getLinksFromAssociation(linkingFlag);
      result.add(nextAssoc);
    }

    return result;
  }

}

/*
 Data class to hold a 2D matrix of links between 2 classes (for 1 association)

 Call getLinksFromAssociation() in order to populate the "links" attribute
*/
class AssociationLinkSet {
  depend java.util.*;
  depend java.io.*;

  public boolean[][] links;
  internal Association association;
  internal Integer classCountStart;
  internal Integer classCountEnd;

  /*
    Given the num of instances of each class, get the associations/links between each instance.
    Creates a matrix of the links between classes for a given association
    The matrix is classCountStart by classCountEnd, and the boolean entries represent if there is a link between class instances

    The linkingFlag parameter determines the number of links to create:
      - 0 Minimum
      - 1 Maximum
      - 2 Random

    Algorithm:
    Check which class is the limiting factor
    Take the limiting class (lets say B), begin assigning As round-robin until B links are satisfied
    
    Example: 
    For A 2..3 -- 2..7 B with 7 As and 10 Bs (getting the minimum links)
    B1 = A1, A2
    B2 = A3, A4
    B3 = A5, A6
    B4 = A7, A1
    B5 = A2, A3
    ...
    Each A should have at least its minimums (since B was the limiting class)
    A1 = B1, B4, B8
    A2 = B1, B5, B8
    ...
    A6 = B3, B7, B10
    A7 = B4, B7
  */
  public void getLinksFromAssociation(int linkingFlag){
    boolean[][] result = new boolean[classCountStart][classCountEnd];

    // Reflexivity uses a different algorithm; Since there is only 1 set of instances instead of 2
    boolean isReflexive = association.getEnd(0).getClassName().equals(association.getEnd(1).getClassName());
    if (isReflexive) {
      // There is always a 0 lower bound on both ends (umple would throw an error otherwise)
      // So for minimum links we can simply return no links
      if (linkingFlag == 0) {
        this.links = result;
        return;
      }

      // TODO: Implement reflexive associations
      // Symmetric, Asymmetric, Asymmetric hierarchy; all have different rules

      this.links = result;
      return;
    }

    // Minimum links is the number of classes multiplied by the lower bound on the other end
    // Maximum links is the number of classes multiplied by the upper bound on the other end
    int endLower = association.getEnd(1).getMultiplicity().getLowerBound();
    int endUpper = association.getEnd(1).getMultiplicity().getUpperBound();
    int startLower = association.getEnd(0).getMultiplicity().getLowerBound();
    int startUpper = association.getEnd(0).getMultiplicity().getUpperBound();
    
    // The maximum links for a * upper bound is #OfInstances of the other class (you cannot link to 11 Bs if there are only 10 Bs)
    if (endUpper == -1) {endUpper = classCountEnd;}
    if (startUpper == -1) {startUpper = classCountStart;}

    int maximumLinksStart = classCountStart*endUpper;
    int minimumLinksStart = classCountStart*endLower;
    int maximumLinksEnd = classCountEnd*startUpper;
    int minimumLinksEnd = classCountEnd*startLower;

    
    // The smallest maximum bound determines the limiting class for max links
    int smallestMaximum = (maximumLinksStart < maximumLinksEnd) ? maximumLinksStart : maximumLinksEnd;
    
    // The largest minimum bound determines the limiting class for min/random links
    int largestMinimum = (minimumLinksStart > minimumLinksEnd) ? minimumLinksStart : minimumLinksEnd;

    int totalLinkCount;
    if (linkingFlag == 0) { // minimum
      totalLinkCount = largestMinimum;
    } else if (linkingFlag == 1) { // maximum
      totalLinkCount = smallestMaximum;
    } else { //random
      Random random = new Random();
      totalLinkCount = random.nextInt(smallestMaximum - largestMinimum + 1) + largestMinimum;
    }

    int linksPerStartInstance = (int)Math.floor((double)totalLinkCount / (double)classCountStart);
    int extraInstanceCount = totalLinkCount % classCountStart;

    // Loop through instances of the starting class
    int roundRobinCount = 0;
    for (int i=0;i<classCountStart;i++) {      

      // Each instance has "linksPerStartInstance" links +1 if we need to get rid of an extra
      int desiredLinks = linksPerStartInstance;
      desiredLinks += (i < extraInstanceCount) ? 1 : 0;

      // Loop through creating links
      for (int linkCount=0; linkCount<desiredLinks ;linkCount++) { 
        result[i][roundRobinCount] = true;
        roundRobinCount = (roundRobinCount+1)%classCountEnd;
      }
    }

    this.links = result;
    return;
  }

  public String toString() {
    String result = "";
    
    result += "("+classCountStart+")"+this.association.getEnd(0).getClassName();
    result += " X ";
    result += "("+classCountEnd+")"+this.association.getEnd(1).getClassName();
    result += "\n";
    for (int i=0;i<links.length;i++) {
      result += "|";
      for (int j=0;j<links[i].length;j++) {
        result += " " + (links[i][j] ? "1" : "0") + " ";
      }
      result += "|\n";
    }

    return result;
  }

  public Association getAssociation(){
    return this.association;
  }

}