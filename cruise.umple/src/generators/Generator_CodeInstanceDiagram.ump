/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
https://umple.org/license

This file generates a randomized instance diagram and the resulting objects
for every class in the model. The results of these instances is output
to JSON.

Command line action for this is
  -g InstanceDiagram

 */
namespace cruise.umple.compiler;

class InstanceDiagramGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.compiler.exceptions.*;

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  String outputCode = "";


  public void generate()
  {

    // TO BE IMPLEMENTED: Split model (forest) into connected trees and run the algorithm multiple times.
    // The above may not be necessary

    // TO BE IMPLEMENTED: Solve for class instance counts
    // Take row of free variable -> find LCM -> LCM is the free value, calculate the rest

    // TO BE IMPLEMENTED: Convert class counts to a json file of class instances

    // NOTE: The below code is temporary; it is being used to test the output of the model

    AssociationMatrix modelMatrix = createMatrixFromModel(model);
    outputCode += modelMatrix.toString();

    outputCode += "\n";

    modelMatrix.toPartialRREF();
    outputCode += modelMatrix.toString();
    
    ArrayList<String> freeVars = modelMatrix.getFreeVariables();
    for (String var : freeVars) {
      outputCode += "\n" + var;
    }

    model.setCode(outputCode);


    writeModelToFile();
  }

  /*
    Create the association matrix (system of linear equations) from the model.
    
    Since reflexive associations must have a 0 lower bound, the minimum number of classes is always 0.
    Reflexive associations can be safely ignored

    See class AssociationMatrix for explanation as to the convention
  */
  private AssociationMatrix createMatrixFromModel(UmpleModel umpleModel) {
    
    AssociationMatrix resultMatrix = new AssociationMatrix();
    // Since colClasses isnt immutable, we need to add classes one-by-one
    for (UmpleClass umpClass : umpleModel.getUmpleClasses()) {
      resultMatrix.addColClass(umpClass.getName());
    }
    
    // Loop through every association and add it as a row to the matrix
    for (Association assoc : umpleModel.getAssociations()) {
      
      //Create the matrix row
      AssociationRow newAssocRow = new AssociationRow();

      // Skip reflexive associations
      if (assoc.getEnd(0).getClassName() == assoc.getEnd(1).getClassName()) {
        continue;
      }

      // Step 1: Find the desired index, and the value
      int indexLeft = resultMatrix.indexOfColClass(assoc.getEnd(0).getClassName());
      Multiplicity mulLeft = assoc.getEnd(0).getMultiplicity();
      int indexRight = resultMatrix.indexOfColClass(assoc.getEnd(1).getClassName());
      Multiplicity mulRight = assoc.getEnd(1).getMultiplicity();
      

      // Step 2: Convert Multiplicity to the LinearExpression representation
      LinearExpression leftExp = new LinearExpression();
      LinearExpression rightExp = new LinearExpression();

      // Check if the multiplicity is a constant
      if (mulLeft.getBound() != null && !mulLeft.getBound().equals("*")) { 
        leftExp.addTerm(new LinearTerm(Double.parseDouble(mulLeft.getBound())));
      } else {
        LinearTerm leftTerm = new LinearTerm(1);
        //Add the multiplicity as a variable
        leftTerm.addMultiplier(new MultiplicityVariable(mulLeft), 1.0);
        leftExp.addTerm(leftTerm);
      }

      // Check if the multiplicity is a constant
      // Note that we reverse the sign of one of the ends - See class AssociationMatrix
      if (mulRight.getBound() != null && !mulRight.getBound().equals("*")) { 
        rightExp.addTerm(new LinearTerm(-Double.parseDouble(mulRight.getBound())));
      } else {
        LinearTerm rightTerm = new LinearTerm(-1);
        //Add the multiplicity as a variable
        rightTerm.addMultiplier(new MultiplicityVariable(mulRight), 1.0);
        rightExp.addTerm(rightTerm);
      }   

      // Step 3: Place the 2 object into the Matrix row
      // Note that we swap the positions/indices of the ends - See class AssociationMatrix
      for (int i=0;i<resultMatrix.numberOfColClasses(); i++) {
        if (i == indexLeft) {
          newAssocRow.addMatrixEntry(rightExp);
        } else if (i == indexRight) {
          newAssocRow.addMatrixEntry(leftExp);
        } else {
          newAssocRow.addMatrixEntry(new LinearExpression());
        }
      }

      // Add row to matrix
      resultMatrix.addMatrixRow(newAssocRow);
    }

    return resultMatrix;
  }

  // Output the instance diagram to a file
  private void writeModelToFile()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + 
        model.getUmpleFile().getSimpleFileName() + ".txt";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException(
        "There was a problem generating the Instance Diagram." + e, e);
    }
  }

}



/*
 Represents the model as a matrix/System-of-linear-equations
 Each column represents a class, and each row represents an association

 The linear equations in the system represent sums of instances of classes.
  If class Alpha has a 1--2 association with class Beta, then: 
      - NumOfAlpha*2 = NumOfBeta.
      - NumOfAlpha*2 - NumOfBeta = 0
      - NumOfAlpha*2 - NumOfBeta + 0*NumOfCharlie + 0*NumOfDelta + ... = 0
  Each association adds a linear equation where only 2 of the values are non-zero.
*/
class AssociationMatrix
{
  // THIS SHOULD BE IMMUTABLE. See Issue #173 on Github... 
  // If not immutable - then there should be overrides to resize the matrix's columns
  // List of classes in the model, their index corresponds to the column number
  String[] colClasses;

  // Rows representing associations in the model
  AssociationRow[] matrixRows;

  /*
    Perform gauss-jordan elimination to reduce the matrix.
    The standard algorithm has been modified to account for variables in place of concrete values.
    These variable/LinearTerm cells can still act as pivots by dividing by the LinearTerm
    Example Row: [2*A, C, 0, 0] can be converted to [1, C/(2*A), 0, 0]
    

    IMPORTANT NOTE: 
    Since each row can only contain 2 entries (LinearTerms), 
        there could be rows simplified to 1 entry - a LinearExpression (2 LinearTerms in the same cell)
    These LinearExpressions will NOT be used as pivots, they will be skipped (similarly to a 0 pivot)
    
    Rationale:
    As mentioned above, every other entry in the row must be 0.
    There are 2 situations:
    - Other values in the column are chosen as the pivot: 
          This linear expression is reduced to 0 through subtraction by the pivot
    - There are no other values in the column:
      - The LinearExpression != 0: We divide it by itself, and it becomes a pivot in an empty column (ie. not required to solve the system)
      - The LinearExpression == 0: The column is fully 0, resulting in a free variable column (useful for solving the system)
    The only situation where a LinearExpression becomes a non-zero pivot is not necessary to solve the system
  */
  public void toPartialRREF() 
  {
    int cols = numberOfColClasses();
    int rows = numberOfMatrixRows();

    // Loop through the pivot diagonal
    for (int pivotCol=0, pivotRow=0; pivotCol < cols && pivotRow < rows; pivotCol++) {

      // Step 1: Find the first non-zero element in the pivot column
      int nonZeroRow = -1;
      for (int i = pivotRow; i<rows; i++) {
        // Check for non-zero (term>0), non-LinearExpression value (term<2)
        if (getMatrixRow(i).getMatrixEntry(pivotCol).numberOfTerms() == 1) {
          nonZeroRow = i;
          break;
        }
      }

      //If there was no non-zero value, skip this column
      if (nonZeroRow == -1) {
        continue;
      }

      // Step 2: Swapping the non-zero pivot to the current/pivot row position
      Collections.swap(matrixRows, nonZeroRow, pivotRow);


      // Step 3: Scale the pivot row (make the pivot 1)
      // Since we know there is only 1 LinearTerm we can do getTerm(0)
      LinearTerm pivotValue = getMatrixRow(pivotRow).getMatrixEntry(pivotCol).getTerm(0);
      getMatrixRow(pivotRow).multiplyRowInplace(pivotValue.getReciprocal());
      

      // Step 4: Eliminate values in the other rows (make the pivot column full of 0s)
      for (int k=0;k<rows;k++) {
        if (k != pivotRow) {
          // Get scaling factor
          LinearExpression multiplier = getMatrixRow(k).getMatrixEntry(pivotCol);
          // Copy pivot row
          AssociationRow subtractPattern = getMatrixRow(pivotRow).copy();
          //Scale pivot row
          subtractPattern.multiplyRowInplace(multiplier);
          //Perform Row Subtraction
          getMatrixRow(k).subtractRowInplace(subtractPattern);
        }
      }

      // Note that this line is not reached if pivot is 0; the next loop will increment column but not row
      pivotRow++;
    }
  }

  /*
    This function returns the free variables of the matrix (assuming the matrix is in RREF).
    It will return garbage if the matrix is not in RREF
  */
  public ArrayList<String> getFreeVariables(){
    ArrayList<String> freeVars = new ArrayList<String>();
    
    // Go down the diagonal
    for (int row=0, col=0 ; col<numberOfColClasses() ; col++) {

      // If the diagonal does not exist, then the column is a free variable
      if (row>=numberOfMatrixRows()) {
        freeVars.add(getColClass(col));
        continue;
      }

      // If the diagonal has 0, then the column is a free variable
      if (getMatrixRow(row).getMatrixEntry(col).numberOfTerms() != 1)  {
        freeVars.add(getColClass(col));
        continue;
      } 
      
      row++;
    }
    return freeVars;
  }


  public String toString() {
    String output = "";
    output += "[";
    for (int i=0;i<numberOfMatrixRows();i++) {
      output += getMatrixRow(i);
      if (i != numberOfMatrixRows()-1) {
        output += "," + "\n";
      }
    }
    output += "]";
    return output;
  }
}


/*
  Rows of the association matrix
  Represents an association
*/
class AssociationRow
{
  LinearExpression[] matrixEntries;
  
  // Multiply this row inplace by a LinearExpression
  public void multiplyRowInplace(LinearExpression linExp)
  {
    for (int i = 0; i<matrixEntries.size() ;i++) {
      matrixEntries.set(i, matrixEntries.get(i).multiply(linExp));
    }
  }

  //Subtract the values in this row by the values in another row
  public void subtractRowInplace(AssociationRow other)
  {
    for (int i = 0; i<matrixEntries.size() ;i++) {
      // Subtract by adding the negative of the other expression
      matrixEntries.set(i, matrixEntries.get(i).addition(other.matrixEntries.get(i).multiply(-1.0)));
    }
  }

  // Multiply this row inplace by a LinearTerm
  public void multiplyRowInplace(LinearTerm linTerm){
    for (int i = 0; i<matrixEntries.size() ;i++) {
      matrixEntries.set(i, matrixEntries.get(i).multiply(linTerm));
    }
  }

  public AssociationRow copy() {
    AssociationRow newAssocRow = new AssociationRow();
    for (int i=0;i<this.matrixEntries.size();i++) {
      newAssocRow.addMatrixEntry(this.matrixEntries.get(i).copy());
    }
    return newAssocRow;
  }

  public String toString() {
    String output = "";
    output += "[";
    for (int i=0;i<matrixEntries.size();i++) {
      output += matrixEntries.get(i);
      if (i != matrixEntries.size()-1) {
        output += " | ";
      }
    }
    output += "]";
    return output;
  }
}



/*
  Entries in the association matrix are linear expressions
  A series of linear terms, such as 2*A*B + (-3)*C + D/2
*/
class LinearExpression {
  LinearTerm[] terms;

  public LinearExpression multiply(LinearExpression multiplyTerm)
  {
    LinearExpression result = new LinearExpression();

    for (int i = 0; i<this.terms.size() ;i++) {
      for (int j = 0; j<multiplyTerm.terms.size() ;j++) {
        result.terms.add(
          this.terms.get(i).multiply(multiplyTerm.terms.get(j))
          );
      }
    }

    result.eliminateTerms();
    return result;
  }

  public LinearExpression multiply(LinearTerm multiplyTerm)
  {
    LinearExpression result = new LinearExpression();

    for (int i = 0; i<this.terms.size() ;i++) {
      result.terms.add(this.terms.get(i).multiply(multiplyTerm));
    }

    result.eliminateTerms();
    return result;
  }

  public LinearExpression multiply(Double multiplyTerm)
  {
    LinearExpression result = new LinearExpression();

    for (int i = 0; i<this.terms.size() ;i++) {
      result.terms.add(this.terms.get(i).multiply(multiplyTerm));
    }

    // Elimination of terms is unnecessary here
    return result;
  }

  public LinearExpression addition(LinearExpression addTerm) {
    LinearExpression result = copy();

    for (int i=0;i<addTerm.terms.size();i++) {
      result.terms.add(addTerm.terms.get(i));
    }

    result.eliminateTerms();
    return result;
  }

  public void eliminateTerms() {

    // Loop through and group any terms that have the same variables
    // Example: 2*A*B + 1*A*B = 3*A*B + 0*A*B
    for (int i=0;i<terms.size();i++) {
      for (int j=i+1;j<terms.size();j++) {
        if (terms.get(i).sameMultipliers(terms.get(j))) {
          terms.get(i).setConstantTerm(terms.get(i).getConstantTerm() + terms.get(j).getConstantTerm());
          terms.get(j).setConstantTerm(0);
        } 
      }
    }

    // Iterate backwards through items, removing items if they have a constant term of 0.
    for (int i=terms.size()-1; i>=0 ;i--) {
      if (terms.get(i).getConstantTerm() == 0.0) {
        terms.remove(i);
      }
    }

  }

  public LinearExpression copy() {
    LinearExpression newExp = new LinearExpression();
    for (int i=0;i<this.terms.size();i++) {
      newExp.addTerm(this.terms.get(i).copy());
    }
    return newExp;
  }

  public String toString() {
    String output = "";
    for (int i=0;i<terms.size();i++) {
      output += terms.get(i);
      if (i != terms.size()-1) {
        output += "+";
      }
    }
    if (terms.size()==0) {
      output += "0.0";
    }
    return output;
  }
}



/*
  Represents a linear term; a series of variable coefficients
  LinearTerm = constantTerm*(multipliers^powers)
  The multipliers are the MultiplicityVariables in this case

  NOTE: The power of the multiplier should be 1 or -1, but it's possible to go higher
*/
class LinearTerm {
  Double constantTerm;
  internal MultiplicityVariable[] multipliers;
  internal Double[] powers;

  public int size() {
    return multipliers.size();
  }

  // Returns true if all multipliers and powers are equal. (Everything is equal except constant)
  public boolean sameMultipliers(LinearTerm other) {
    if (other.multipliers.size() != this.multipliers.size()) {
      return false;
    }

    for (int i=0;i<multipliers.size();i++) {
      if (this.multipliers.get(i) != other.multipliers.get(i)
        || this.powers.get(i) != other.powers.get(i)) {
        return false;
      }
    }

    return true;
  }

  // Add a new multiplier to this term
  public void addMultiplier(MultiplicityVariable newMultiplier, Double newPower) {
    multipliers.add(newMultiplier);
    powers.add(newPower);
    eliminateTerms();
  }

  // Get a copy of this term multiplied by another LinearTerm
  public LinearTerm multiply(LinearTerm multiplyTerm)
  {
    LinearTerm result = copy();

    // If the constant term is 0, then multiplication is pointless
    if (constantTerm == 0) {
      return result;
    }

    result.constantTerm *= multiplyTerm.constantTerm;

    // Update the list of powers and multipliers
    for (int i=0;i<multiplyTerm.size();i++) {
      // Check if any variable in "multiplyTerm" is also here
      int index = result.multipliers.indexOf(multiplyTerm.multipliers.get(i));

      // If variable is not already in the list, add it
      if (index == -1) {
        result.multipliers.add(multiplyTerm.multipliers.get(i));
        result.powers.add(multiplyTerm.powers.get(i));
      } else { 
        result.powers.set(index, result.powers.get(index) + multiplyTerm.powers.get(i));
      }
    }

    result.eliminateTerms();
    return result;
  }

  // Remove any variable who's power is 0
  public void eliminateTerms() {
    // Iterate backwards removing anything with power==0
    for (int i=size()-1; i>=0 ;i--) {
      if (powers.get(i) == 0) {
        multipliers.remove(i);
        powers.remove(i);
      }
    }
  }

  // Get a copy of this term multiplied by a constant
  public LinearTerm multiply(Double multiplyTerm)
  {
    LinearTerm result = copy();
    result.constantTerm *= multiplyTerm;
    return result;
  }

  // Get a copy of this LinearTerm's reciprocal
  public LinearTerm getReciprocal() {
    LinearTerm recTerm = new LinearTerm(1/constantTerm);
    for (int i=0;i<size();i++) {
      recTerm.multipliers.add(multipliers.get(i));
      recTerm.powers.add(-powers.get(i));
    }
    return recTerm;
  }

  // Get a copy
  public LinearTerm copy() {
    LinearTerm newTerm = new LinearTerm(constantTerm);
    // Pass references of multipliers, not copies
    newTerm.multipliers = new ArrayList<MultiplicityVariable>(multipliers);
    // This should deep copy the Doubles
    newTerm.powers = new ArrayList<Double>(powers);
    return newTerm;
  }

  public String toString() {
    String output = "";
    output += constantTerm;
    for (int i=0;i<size();i++) {
      output += "*" + "(" + multipliers.get(i) + "^" + powers.get(i) + ")";
    }
    return output;
  }
}



/*
  Represents a variable multiplicity (1..3) in the association matrix
  
  Each MultiplicityVariable is a separate variable in the system.
  Even if 2 MultiplicityVariables share the same bounds, they are not equal
*/
class MultiplicityVariable {
  Multiplicity valueRange;

  public String toString() {
    String output = "";
    output += "(" + valueRange.getParserable() + ")";
    return output;
  }
}