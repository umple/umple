/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
https://umple.org/license

This file generates a randomized instance diagram and the resulting objects
for every class in the model. The results of these instances is output
to JSON.

Command line action for this is
  -g InstanceDiagram

 */
namespace cruise.umple.compiler;

class InstanceDiagramGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.compiler.exceptions.*;

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  String outputCode = "";


  public void generate()
  {

    // TO BE IMPLEMENTED: Output error when reaching max iterations

    // TO BE IMPLEMENTED: Output error when hitting a max class count...

    // TO BE IMPLEMENTED: 
    // the minimum is not a satisfying model
    // All the 0..? associations are never used
    // Also create a random version? where its not always minimum bound, but a random bound

    // TO BE IMPLEMENTED: Handling inheritance
    // Superclasses are sums of a dummy (if non abstract) and its children
    // and if we have to update the value max() how do we decide which to increase?
    // Choosing it at random is an option... But there could be a better way
    // Maybe since i am going to make a minimal version and a random version; inheritance forces the random one to be used

    Map<String, Integer> minInstance = getMinInstances(100);

    for (Map.Entry<String, Integer> entry : minInstance.entrySet()) {
      outputCode += entry.getKey() + " - " + entry.getValue() + "\n";
    }

    ArrayList<ClassAssociationLinkSet> actualLinks = distributeAssociations(minInstance);
    for (ClassAssociationLinkSet link : actualLinks) {
      outputCode += "\n" + link.toString();
    }

    model.setCode(outputCode);

    writeModelToFile();
  }

  /*
    We can represent the system as a graph problem. 
    Each class is a node, and each association is 2 directed links between the nodes.
    For every link, the class count at the start multiplied by the multiplicity must be smaller/equal to the class count at the end.
    
    If you have the link A 2..4 -> 3..6 B, for every 2..4 As, there must be 3..6 Bs.
    Thus, we have the following tightest inequality; for every 4 or less As, there must be at at least 3 Bs
    There can be less As, or more Bs, but this equality must hold true.
    So for A = 1-4 there are >3 Bs, for A = 5-8 there are >6 Bs
    
    Algorithm:
    Initialize all class counts to 1
    Loop through every association
      End = max(End, lowerEnd*ceil(Start/UpperStart))
    Repeat until no more changes appear
  
    Returns a map of classnames and their minimum class counts
  */
  private Map<String, Integer> getMinInstances(int maxIter) {
    Map<String, Integer> result = new HashMap<String, Integer>();
    
    // Initialize every class to 1. 
    for (UmpleClass umpClass : model.getUmpleClasses()) {
      result.put(umpClass.getName(), 1);
    }

    // Begin algorithm
    boolean noChange = false;
    for (int iter=0;iter<maxIter;iter++) {
      if (noChange) {
        break;
      }
      noChange = true;

      for (Association assoc : model.getAssociations()) {
        int lowerLeft = assoc.getEnd(0).getMultiplicity().getLowerBound();
        int upperLeft = assoc.getEnd(0).getMultiplicity().getUpperBound();
        int lowerRight = assoc.getEnd(1).getMultiplicity().getLowerBound();
        int upperRight = assoc.getEnd(1).getMultiplicity().getUpperBound();

        // For directional associations, there are 3 situations for the multiplicity on the unmanaged side:
        // - 0..1: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... no changes required
        // - *: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... convert it to 0..1
        // - 2, 2..4, anything: The user has ignored Warning036...
        //                      We will assume the user wishes to enforce that multiplicity so pretend its bidirectional... no changes required
        if (!assoc.getIsLeftNavigable() && upperLeft==-1) {
          lowerLeft = 0;
          upperLeft = 1;
        }
        if (!assoc.getIsRightNavigable() && upperRight==-1) {
          lowerRight = 0;
          upperRight = 1;
        }

        // TO BE IMPLEMENTED: Treat * as a very large number
        // It would have a -1 as the value
        // This code needs to be after the directional association detection above

        // Going towards the right
        Integer newInstanceLeft = Integer.valueOf((int)(lowerRight*Math.ceil(result.get(assoc.getEnd(0).getClassName())/upperLeft)));
        Integer oldIstanceleft = result.get(assoc.getEnd(1).getClassName());
        // If the new required instance is higher, replace the old instance count
        if (newInstanceLeft > oldIstanceleft) {
          noChange = false;
          result.put(assoc.getEnd(1).getClassName(), newInstanceLeft);
        }

        // Going towards the left
        Integer newInstanceRight = Integer.valueOf((int)(lowerLeft*Math.ceil(result.get(assoc.getEnd(1).getClassName())/upperRight)));
        Integer oldIstanceRight = result.get(assoc.getEnd(0).getClassName());
        // If the new required instance is higher, replace the old instance count
        if (newInstanceRight > oldIstanceRight) {
          noChange = false;
          result.put(assoc.getEnd(0).getClassName(), newInstanceRight);
        }

      }
    }
    return result;
  }

  /*
    Given the number of instance of each class, get the associations between the instances.

    Returns an arraylist of ClassAssociationLinkSet, which is a data class
  */
  private ArrayList<ClassAssociationLinkSet> distributeAssociations(Map<String, Integer> minimumInstances) {
    ArrayList<ClassAssociationLinkSet> result = new ArrayList<ClassAssociationLinkSet>();
    
    // Loop through associations
    for (Association assoc : model.getAssociations()) {
      result.add(new ClassAssociationLinkSet(assoc, minimumInstances.get(assoc.getEnd(0).getClassName()), minimumInstances.get(assoc.getEnd(1).getClassName())));
    }

    return result;
  }

  // Output the instance diagram to a file
  private void writeModelToFile()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + 
        model.getUmpleFile().getSimpleFileName() + ".txt";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException(
        "There was a problem generating the Instance Diagram." + e, e);
    }
  }

}

/*
 Data class to hold a 2D matrix

 Automatically calculates the links in the constructor
*/
class ClassAssociationLinkSet {
  private boolean[][] links;
  internal Association association;
  internal Integer classCountStart;
  internal Integer classCountEnd;

  after constructor {
    this.links = getLinksFromAssociation(classCountStart, classCountEnd, association);
  }

  /*
    Given the num of instances of each class, get the associations between each instance.
    Returns a reference to a matrix of the minimum links between classes for a given association
    The matrix is startClassCount by endClassCount, and the boolean entries represent if there is a link between class instances

    TO BE IMPLEMENTED: return maximum links between classes when passed a flag

    Algorithm:
    Check which minimum is larger: A*Bmin or B*Amin. 
    If they !=, It will be impossible to satisfy one min with the min of the other, we have to add some extra connections
    Take the largest minimum (lets say B), begin assigning As round-robin until B min is satisfied
    
    Example: For A 2..3 -- 2..7 B with 7 As and 10 Bs
    B1 = A1, A2
    B2 = A3, A4
    B3 = A5, A6
    B4 = A7, A1
    B5 = A2, A3
    ...
    Each A should have its minimums
    A1 = B1, B4, B8
    A2 = B1, B5, B8
    ...
    A6 = B3, B7, B10
    A7 = B4, B7

  */
  private boolean[][] getLinksFromAssociation(Integer startClassCount, Integer endClassCount, Association assoc){
    boolean[][] result = new boolean[startClassCount][endClassCount];

    // Minimum links is the number of classes multiplied by the lower bound on the other end
    int endLower = assoc.getEnd(1).getMultiplicity().getLowerBound();
    int startLower = assoc.getEnd(0).getMultiplicity().getLowerBound();
    int minimumLinksStart = startClassCount*endLower;
    int minimumLinksEnd = endClassCount*startLower;

    if (minimumLinksStart > minimumLinksEnd) {
      
      int roundRobinCount = 0;
      for (int i=0;i<startClassCount;i++) {
        for (int min=0;min<endLower;min++) {
          result[i][roundRobinCount] = true;
          roundRobinCount = (roundRobinCount+1)%endClassCount;
        }
      }

    } else {

      int roundRobinCount = 0;
      for (int i=0;i<endClassCount;i++) {
        for (int min=0;min<startLower;min++) {
          result[roundRobinCount][i] = true;
          roundRobinCount = (roundRobinCount+1)%startClassCount;
        }
      }

    }

    return result;
  }

  public String toString() {
    String result = "";
    
    result += "("+classCountStart+")"+this.association.getEnd(0).getClassName();
    result += " X ";
    result += "("+classCountEnd+")"+this.association.getEnd(1).getClassName();
    result += "\n";
    for (int i=0;i<links.length;i++) {
      result += "|";
      for (int j=0;j<links[i].length;j++) {
        result += " " + (links[i][j] ? "1" : "0") + " ";
      }
      result += "|\n";
    }

    return result;
  }

}