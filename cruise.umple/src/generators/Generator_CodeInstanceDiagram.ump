/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
https://umple.org/license

This file generates a randomized instance diagram and the resulting objects
for every class in the model. The results of these instances is output
to JSON.

Command line action for this is
  -g InstanceDiagram

 */
namespace cruise.umple.compiler;

class InstanceDiagramGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.util.*;
  depend cruise.umple.compiler.exceptions.*;

  protected String generatorType()
  {
    return "cid";
  }

  // Template for what will appear at the start of each graphviz file
  graphStart(umpleVersion) <<! /*This code was generated using the UMPLE <<=umpleVersion>> modeling language! */
  
  digraph FeatureModel { 
    node [shape=rectangle]  
    edge [arrowhead=none] 
  !>>

  emit graphStart()(graphStart(UmpleModel.VERSION_NUMBER));

  protected void terminateCode(StringBuilder code, StringBuilder associations) {

    code.append("\n  // All associations\n");
    code.append(associations);

    code.append("}\n");

    model.setCode(code.toString());
    writeModel();
  }

  // Output the graphviz file to a file with the .gv suffix
  protected void writeModel()
  {
    try
    {
      String outputDir = getModel().getUmpleFile().getPath();
      String path = StringFormatter.addPathOrAbsolute(outputDir, "");
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName()
          + generatorType() + ".gv";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating GraphViz Diagram code." + e, e);
    }
  } 

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  String outputCode = "";


  public void generate()
  {

    // TODO: 
    // the minimum is not a satisfying model
    // All the 0..? associations are never used
    // I should also create a random version where its not always minimum bound, but a random bound

    // TODO: Handling inheritance
    // Superclasses are sums of a dummy (if non abstract) and its children
    // and if we have to update the value how do we decide which to increase?
    // extendsClass (single), parentInterface (list), subclasses (list); are relevant UmpleClass attributes
    // Side Note: Verify if chain inheritances subclasses are in the list, or if they are chained...
    // Potential Algorithm when you need more instances of abstract/interface:
    // How many more do you need?: sum of subclass - total need
    // Take all concrete subclasses, give them a score based on connectedness, pick the best score (the least connected)

    // Run class count algorithm
    ClassInstanceCountSet classInstanceResult = new ClassInstanceCountSet(model);
    classInstanceResult.getInstanceCounts(100, 100);
    
    // TODO: Output errors
    if (classInstanceResult.statusCode == 1) {
      outputCode += "Reached maximum iterations. Ensure that the system is instantiable and non-infinite";
      model.setCode(outputCode);
      writeModelToFile();
      return;
    } else if (classInstanceResult.statusCode == 2) {
      outputCode += "Reached maximum class count. Ensure that the system is instantiable and non-infinite";
      model.setCode(outputCode);
      writeModelToFile();
      return;
    }
    
    // Get class count result
    Map<String, Integer> minInstance = classInstanceResult.minimumInstances;
    // Get associations from the class count
    ArrayList<AssociationLinkSet> actualLinks = classInstanceResult.distributeAssociations(true);


    StringBuilder code = new StringBuilder();           // part of the gv file with the node/classes
    StringBuilder associations = new StringBuilder();   // part of the gv file with all the associations

    // Output basic gv file header
    _graphStart(0,code);

    //gets the desired separator value. Graphviz default is 0.5 but for Umple we use 1.0 for 'normal'
    double sepVal = getSuboptionValue("gvseparator", 1.0); 
    //checks if the separator value is not 1.0 (Umple default which will be 0.5 in Graphviz).
    // If it isn't it applies the desired separator value to nodesep and ranksep
    if (sepVal != 1.0){
      Double graphVizSepVal = sepVal/2.0;
      code.append("nodesep =" + graphVizSepVal +";"); //injects sepVal(desired separator value) into nodesep
      code.append("ranksep =" + graphVizSepVal +";"); //injects sepVal(desired separator value) into ranksep
    }

    for (UmpleClass umpClass : model.getUmpleClasses()) { // looping through the model. need to extract the attribute information.
      if (umpClass.getIsAbstract()){                      // we do not consider abstract classes in instance diagrams
          continue;
      }
      String currentInstanceName = umpClass.getName();
      Integer numberOfInstaces = minInstance.get(currentInstanceName);    // minInstance may change at a later date
      for (int i = 0; i < numberOfInstaces; i++) {
        createInstance(umpClass, code, i + 1);
      }
    }

    // AssociationCreate(); TODO make the helper function that makes all the associations
    terminateCode(code, associations);


    // TODO: Remove printing the output to a text file
    /*
    for (Map.Entry<String, Integer> entry : minInstance.entrySet()) {
      outputCode += entry.getKey() + " - " + entry.getValue() + "\n";
    }
    for (AssociationLinkSet link : actualLinks) {
      outputCode += "\n" + link.toString();
    }
    model.setCode(outputCode);
    writeModelToFile();
    */
  }

  public void createInstance(UmpleClass umpClass, StringBuilder code, int iteration){

    boolean manyClass = getModel().getUmpleClasses().size() >= 200 ? true : false;

    String className = umpClass.getName();
    String instanceName = className + iteration + ": " + className;
    String classColor = umpClass.getDisplayColor();
    if (!classColor.equals("")) classColor=" style=filled, fillcolor="+classColor+" ";
    code.append("\n  // Instance: "+className + iteration+"\n");
    
    if (manyClass) {
      code.append("  \""+className + iteration+"\" ["+classColor+"shape=record, label=\"{"+instanceName);
    } 
    else {
      code.append("  \""+className + iteration+"\" ["+classColor+"shape=plaintext margin=0 label=");
	    
      // Different cellpadding for if the class has nothing but the
      // name because of a glitch in graphviz's graphics
      if (umpClass.getAttributes().size() == 0 || hasSuboption("hideattributes")) {
	    code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"10\">"
		   			+"<tr><td>    "+instanceName+"    </td></tr>");
      }
      else {
        code.append("<<table border=\"1\" cellspacing=\"0\" cellborder=\"0\" cellpadding=\"2\">"
                    +"<tr><td cellpadding=\"4\">    "+instanceName+"    </td></tr>");
		  }
    }

    attributeCreation(umpClass, code, manyClass);  // creates the attributes for the particular instance

    // Terminate outputting the class attributes
    if(manyClass) code.append("}\"");
   	else code.append("</table>>"); 
    
    
    // Output the tooltip : Class name followed by any comment
    code.append(",\n   tooltip=\"instance "+className + iteration+"\n");
    code.append(SuperGvGenerator.appendTooltipComment(umpClass.getComments(), false));
    code.append("\"");

    // Terminate the class as a whole
    code.append("];\n");
  }

  private void attributeCreation(UmpleClass uClass, StringBuilder code, boolean manyClass){
    // Iterate through attributes of the class
    boolean isFirst = true;

    if (!hasSuboption("hideattributes")) { 
      for (Attribute uAttribute : uClass.getAttributes()) {
        if (!uAttribute.isConstant()) 
        {
          String instanceAttribute = createRandomAttributeValue(uAttribute);  // this will take into account if the attribute is a list or not
          
          if (manyClass) {
            if (isFirst) code.append("|"); // attribute block starter
            else code.append("\\\n"); // separator between attributes
          }
          else {
            if (isFirst) code.append("<hr/>"); // attribute block starter
          }

          String isList = uAttribute.getIsList() ? "[]" : "";
          String type = uAttribute.getType().replace("<","&lt;").replace(">","&gt;");
          
          if (manyClass) {
            code.append(""+uAttribute.getName()+"\\:\\ "+instanceAttribute+"\\l");
          }
          else {
            StringBuilder attrTooltip = new StringBuilder();
            attrTooltip.append(type+isList+" "+uAttribute.getName()+"&#13;");
            attrTooltip.append(SuperGvGenerator.appendTooltipComment(uAttribute.getComments(), true));        
            code.append("<tr><td align=\"left\" href=\"\" title=\""+attrTooltip+"\">"
                +"  "+uAttribute.getName()+": "
                +instanceAttribute+"  </td></tr>");
          }
        } else { //attribute is constant
          // Not sure if this is needed. in the Class diagram constant variables are ignored.
          // could just leave this empty
        }
          isFirst = false;
      }
    }
  }

  private String createRandomAttributeValue(Attribute uAttribute){ //TODO Make this function better
    if (uAttribute.getIsList()){
      return "[A,B,C]";
    }
    return "A";
  }

  // Output the instance diagram to a text file
  private void writeModelToFile()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + 
        model.getUmpleFile().getSimpleFileName() + ".txt";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException(
        "There was a problem generating the Instance Diagram." + e, e);
    }
  }

}

/*
 Data class to hold the number of class instances for a given umple model

 Call getInstanceCounts() in order to populate the "minimumInstances" and "statusCode" attribute
*/
class ClassInstanceCountSet {
  depend java.util.*;

  public Map<String, Integer> minimumInstances;

  // Status of the minimumInstances variable 
  // -1 is uninitialized, 0 is valid, 1 is maxIter reached, 2 is maxInstances reached
  public int statusCode;

  internal UmpleModel umpleModel;

  /*
    We can represent the system as a graph problem. 
    Each class is a node, and each association is 2 directed links between the nodes.
    For every link, the class count at the start multiplied by the multiplicity must be smaller/equal to the class count at the end.
    
    If you have the link A 2..4 -> 3..6 B, for every 2..4 As, there must be 3..6 Bs.
    Thus, we have the following tightest inequality; for every 4 or less As, there must be at at least 3 Bs
    There can be less As, or more Bs, but this equality must hold true.
    So for A = 1-4 there are >3 Bs, for A = 5-8 there are >6 Bs
    
    Algorithm:
    Initialize all class counts to 1
    Loop through every association
      End = max(End, lowerEnd*ceil(Start/UpperStart))
    Repeat until no more changes appear
  
    Creates a Map of classnames and their minimum class counts
  */
  public void getInstanceCounts(int maxIter, int maxClasses) {
    Map<String, Integer> result = new HashMap<String, Integer>();
    
    // Initialize every class to 1. 
    for (UmpleClass umpClass : umpleModel.getUmpleClasses()) {
      result.put(umpClass.getName(), 1);
    }

    int loopStatus = -1;
    boolean noChange = false;
    int iteration = -1;
    // Run infinite loop
    while (true) {
      iteration++;

      // Check if the system has stabilized (all associations are satisfied)
      if (noChange) {
        loopStatus = 0;
        break;
      }
      noChange = true;

      // Check if we've reached max iterations
      if (iteration >= maxIter) {
        loopStatus = 1;
        break;
      }

      // Check if we've reached max class counts
      int sum = 0;
      for (int n: result.values()) {
        sum += n;
      }
      if (sum > maxClasses) {
        loopStatus = 2;
        break;
      }

      for (Association assoc : umpleModel.getAssociations()) {
        int lowerLeft = assoc.getEnd(0).getMultiplicity().getLowerBound();
        int upperLeft = assoc.getEnd(0).getMultiplicity().getUpperBound();
        int lowerRight = assoc.getEnd(1).getMultiplicity().getLowerBound();
        int upperRight = assoc.getEnd(1).getMultiplicity().getUpperBound();

        // For directional associations, there are 3 situations for the multiplicity on the unmanaged side:
        // - 0..1: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... no changes required
        // - *: We will treat it as bidirectional with 1 in the direction, and 0 against the direction... convert it to 0..1
        // - 2, 2..4, anything: The user has ignored Warning036...
        //                      We will assume the user wishes to enforce that multiplicity so pretend its bidirectional... no changes required
        if (!assoc.getIsLeftNavigable() && upperLeft==-1) {
          lowerLeft = 0;
          upperLeft = 1;
        }
        if (!assoc.getIsRightNavigable() && upperRight==-1) {
          lowerRight = 0;
          upperRight = 1;
        }

        // TODO: Treat * as a very large number (the maxInstanceCount?)
        // Currently, it would have a -1 as the value
        // This code needs to be after the directional association detection above

        // Going towards the right
        Integer newInstanceLeft = Integer.valueOf((int)(lowerRight*Math.ceil(result.get(assoc.getEnd(0).getClassName())/upperLeft)));
        Integer oldIstanceleft = result.get(assoc.getEnd(1).getClassName());
        // If the new required instance is higher, replace the old instance count
        if (newInstanceLeft > oldIstanceleft) {
          noChange = false;
          result.put(assoc.getEnd(1).getClassName(), newInstanceLeft);
        }

        // Going towards the left
        Integer newInstanceRight = Integer.valueOf((int)(lowerLeft*Math.ceil(result.get(assoc.getEnd(1).getClassName())/upperRight)));
        Integer oldIstanceRight = result.get(assoc.getEnd(0).getClassName());
        // If the new required instance is higher, replace the old instance count
        if (newInstanceRight > oldIstanceRight) {
          noChange = false;
          result.put(assoc.getEnd(0).getClassName(), newInstanceRight);
        }

      }
    }

    // Set the result map
    this.statusCode = loopStatus;
    this.minimumInstances = result;
    return;
  }

  /*
    Using the number of instance of each class, get the associations between the instances.
    The maxLinks boolean determines if you max or min number of links between the sets of instances

    Returns an arraylist of AssociationLinkSet, which is a data class
  */
  public ArrayList<AssociationLinkSet> distributeAssociations(boolean maxLinks) {
    ArrayList<AssociationLinkSet> result = new ArrayList<AssociationLinkSet>();
    
    // Loop through associations
    for (Association assoc : umpleModel.getAssociations()) {
      AssociationLinkSet nextAssoc = new AssociationLinkSet(assoc, this.minimumInstances.get(assoc.getEnd(0).getClassName()), this.minimumInstances.get(assoc.getEnd(1).getClassName()));
      nextAssoc.getLinksFromAssociation(maxLinks);
      result.add(nextAssoc);
    }

    return result;
  }

}

/*
 Data class to hold a 2D matrix of links between 2 classes (for 1 association)

 Call getLinksFromAssociation() in order to populate the "links" attribute
*/
class AssociationLinkSet {
  public boolean[][] links;
  internal Association association;
  internal Integer classCountStart;
  internal Integer classCountEnd;

  /*
    Given the num of instances of each class, get the associations/links between each instance.
    Creates a matrix of the links between classes for a given association
    The matrix is classCountStart by classCountEnd, and the boolean entries represent if there is a link between class instances

    Algorithm:
    Check which class is the limiting factor
    Take the limiting class (lets say B), begin assigning As round-robin until B links are satisfied
    
    Example: 
    For A 2..3 -- 2..7 B with 7 As and 10 Bs (getting the minimum links)
    B1 = A1, A2
    B2 = A3, A4
    B3 = A5, A6
    B4 = A7, A1
    B5 = A2, A3
    ...
    Each A should have at least its minimums (since B was the limiting class)
    A1 = B1, B4, B8
    A2 = B1, B5, B8
    ...
    A6 = B3, B7, B10
    A7 = B4, B7
  */
  public void getLinksFromAssociation(boolean getMaxLinks){
    boolean[][] result = new boolean[classCountStart][classCountEnd];

    // Minimum links is the number of classes multiplied by the lower bound on the other end
    // Maximum links is the number of classes multiplied by the upper bound on the other end
    int endLower = association.getEnd(1).getMultiplicity().getLowerBound();
    int endUpper = association.getEnd(1).getMultiplicity().getUpperBound();
    int startLower = association.getEnd(0).getMultiplicity().getLowerBound();
    int startUpper = association.getEnd(0).getMultiplicity().getUpperBound();
    
    // The maximum links for a * upper bound is #OfInstances of the other class (you cannot link to 11 Bs if there are only 10 Bs)
    if (endUpper == -1) {endUpper = classCountStart;}
    if (startUpper == -1) {startUpper = classCountEnd;}

    int maximumLinksStart = classCountStart*endUpper;
    int minimumLinksStart = classCountStart*endLower;
    int maximumLinksEnd = classCountEnd*startUpper;
    int minimumLinksEnd = classCountEnd*startLower;

    boolean startLimiting;
    if (getMaxLinks) {
      startLimiting = (maximumLinksStart < maximumLinksEnd)? true : false;
    } else {
      startLimiting = (minimumLinksStart > minimumLinksEnd)? true : false;
    }

    // Loop through whichever end is the limiting factor
    if (startLimiting) {
      
      int roundRobinCount = 0;
      // For each class in set "start"
      for (int i=0;i<classCountStart;i++) {
        // Loop through either max or min links - creating links
        for (int min=0; min<(getMaxLinks? endUpper : endLower) ;min++) { 
          result[i][roundRobinCount] = true;
          roundRobinCount = (roundRobinCount+1)%classCountEnd;
        }
      }

    } else {

      int roundRobinCount = 0;
      // For each class in set "end"
      for (int i=0;i<classCountEnd;i++) {
        // Loop through either max or min links - creating links
        for (int min=0; min<(getMaxLinks? startUpper : startLower) ;min++) {
          result[roundRobinCount][i] = true;
          roundRobinCount = (roundRobinCount+1)%classCountStart;
        }
      }

    }

    this.links = result;
    return;
  }

  public String toString() {
    String result = "";
    
    result += "("+classCountStart+")"+this.association.getEnd(0).getClassName();
    result += " X ";
    result += "("+classCountEnd+")"+this.association.getEnd(1).getClassName();
    result += "\n";
    for (int i=0;i<links.length;i++) {
      result += "|";
      for (int j=0;j<links[i].length;j++) {
        result += " " + (links[i][j] ? "1" : "0") + " ";
      }
      result += "|\n";
    }

    return result;
  }

}