/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

*/

namespace cruise.umple.compiler;
class PythonGenerator
{
  isA JavaGenerator;
  depend java.io.*;
  depend java.nio.file.*;
  depend cruise.umple.compiler.java.*;
  depend cruise.umple.util.StringFormatter;
  depend cruise.umple.compiler.exceptions.*;

  private static final int TXL_VERSION = 9;

  @Override
  public void writeFile(UmpleElement aClass) throws IOException
  {
    if (!isTxlInstalled()) {
      throw new UmpleCompilerException("TXL is required for Python code generation. Please go to https://www.txl.ca/txl-download.html to download and install TXL.", new IOException("TXL not found"));
    }

    //System.out.println("toString() methods have been removed due to an issue with their generation.");
    String className=aClass.getName();
    UmpleClass uClass;
    if (aClass instanceof UmpleClass)
    {
      uClass=(UmpleClass)aClass;
      if(uClass.getHasProxyPattern()||(uClass.getIsDistributed()&&(getModel().getDistributePattern()==1||getModel().getDistributePattern()==2)))
      {
        aClass.setName(className+"Impl");
          }
      if(uClass.hasOuterClass())
      {
        return ; // inner classes should not be writen in single files.
      }
    }
    ILang language = getLanguageFor(aClass);
    String contents = language.getCode(getModel(), aClass);

    aClass.setName(className);
    String path = StringFormatter.addPathOrAbsolute(
                  getModel().getUmpleFile().getPath(),
                            getOutput()) +
                            aClass.getPackageName().replace(".", File.separator);
    if (aClass instanceof UmpleClass)
    { uClass=(UmpleClass)aClass;
      if(uClass.getNeedsDefaultInterface()||uClass.getIsDistributed()||uClass.getHasProxyPattern()){
        contents= super.WriteProxyFiles(contents,uClass,path);
      }
      if(uClass.getHasProxyPattern()||(uClass.getIsDistributed()&&(getModel().getDistributePattern()==1||getModel().getDistributePattern()==2))){
        className=className+"Impl";
        //contents=contents.replaceAll("(,|, |\\(|\\( )(this)(,| ,|\\)| \\))","$1self$3");
      }
    }

    File file = new File(path);
    file.mkdirs();
    String filename = path + File.separator + className + ".java";
    BufferedWriter bw = new BufferedWriter(new FileWriter(filename));

    try
    {
      bw.write(contents);
      bw.flush();
    }
    finally
    {
      bw.close();
      contents = "";
    }

    generateTxlFiles();

    String pythonFilename = path + File.separator + className + ".py";
    String TXLScriptsPath = "./txl/umpleJavaToPython.txl";
    String[] TXLcommand = {"txl", filename, TXLScriptsPath, "-o", pythonFilename};

    try {

      Process p = Runtime.getRuntime().exec(TXLcommand);
      BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

      String line;
      if(reader.ready()) {
        line = reader.readLine();
      }
      else {
        line = null;
      }

      while (line!=null) {
        if(line.contains("error")) {
           System.err.println("TXL ran into an error while processing one of the files. The file may be missing from the generated code.");
           return;
        }

        if(reader.ready()) {
          line = reader.readLine();
        }
        else {
          line = null;
        }
      }

      p.waitFor();

    } catch (IOException e) {
      System.err.println(e.getMessage());
	  throw new UmpleCompilerException("Unable to open Runtime Process.", e);
    } catch (InterruptedException e) {
      System.err.println(e.getMessage());
      throw new UmpleCompilerException("Unable to open Runtime Process.", e);
    } catch (Exception e) {
      throw new UmpleCompilerException("Unable to open Runtime Process.", e);
    }

    try {
      File pythonFile = new File(pythonFilename);
      Scanner pyReader = new Scanner(pythonFile);
      while (pyReader.hasNextLine()) {
        contents += pyReader.nextLine() + "\n";
      }
      pyReader.close();
    } catch (FileNotFoundException e) {
      System.err.println("Error found with compilation of " + new File(pythonFilename).getName() + " : Output might be missing a file");
      return;
    }

    getModel().getGeneratedCode().put(aClass.getName(),contents);

    /* TODO
    if (aClass instanceof UmpleClass)
    {
      StringBuilder exceptionBuilder = new StringBuilder();
      for(String key:((JavaClassGenerator)language).uncaughtExceptions.keySet())
      {
        exceptionBuilder.append(((JavaClassGenerator)language).uncaughtExceptions.get(key).toString()+System.getProperty("line.separator"));
      }
      String exception = exceptionBuilder.toString();
      uncaughtExceptions.append(exception);
      if(((UmpleClass)aClass).getHasMainMethod())
      {
        mainClasses.add((UmpleClass)aClass);
      }
    } */
  }

  private boolean isTxlInstalled()
  {
    //Check for TXL installation
	try {

  	  Process p = Runtime.getRuntime().exec("txl");
	  BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

	  String line;
	  if(reader.ready()) {
	    line = reader.readLine();
	  }
	  else {
	    line = null;
	  }

	  while (line!=null) {
	    if(!line.startsWith("TXL v")) {
	      throw new IOException("TXL not found.");
	    }

	    if(reader.ready()) {
	      line = reader.readLine();
	    }
	    else {
	      line = null;
	    }
	  }
	} catch (IOException e) {
	  System.err.println(e.getMessage());
	  System.err.println("TXL is required for Python code generation. Please go to https://www.txl.ca/txl-download.html to download and install TXL.");
	  return false;
	} catch (Exception e) {
	  throw new UmpleCompilerException("Unable to open Runtime Process.", e);
	}
	return true;
  }

  private void generateTxlFiles() throws IOException {

    String versionPath = "txl/TXL-Version.txt";
    String versionContent = Integer.toString(TXL_VERSION) + "\nThese files were automatically generated by Umple for the python code generation and can be safely deleted after the generation.";

    String[][] filesData = {{ "txl/BooleanTranslation.txl", "%---------------------%\n% Boolean expressions %\n%---------------------%\n\nfunction replaceAllBoolean\n    replace [repeat statement]\n        statements [repeat statement]\n\n    by\n        statements\n            [replaceNullCheck]\n            [replaceNotNullCheck]\n            [replaceBoolNegation]\n            [replaceBoolAnd]\n            [replaceBoolOr]\n            [replaceTrue]\n            [replaceFalse]\n            [replaceClassMatchCheck]\nend function\n\nrule replaceNullCheck\n    replace [condition]\n        elem [value_no_recursion] '== 'null\n    by \n        elem 'is 'None\nend rule\n\nrule replaceNotNullCheck\n    replace [value]\n        cond [condition]\n    deconstruct cond\n        elem [value_no_recursion] '!= 'null\n    by \n        'not '( elem 'is 'None ')\nend rule\n\nrule replaceBoolNegation\n    replace [value_no_recursion]\n        '! expr [boolean_expression]\n    by \n        'not expr\nend rule\n\nrule replaceBoolAnd\n    replace [boolean_operator]\n        '&&\n    by \n        'and\nend rule\n\nrule replaceBoolOr\n    replace [boolean_operator]\n        '|'|\n    by \n        'or\nend rule\n\nrule replaceTrue\n    replace [value]\n        'true\n    by \n        'True\nend rule\n\nrule replaceFalse\n    replace [value]\n        'false\n    by \n        'False\nend rule\n\nrule replaceClassMatchCheck\n    replace [value]\n        'getClass().equals( id2 [id] '.getClass())\n    by  \n        'type(self) 'is 'type( id2 ')\nend rule\n"},
{ "txl/ClassTranslation.txl", "%--------------------%\n%     Classes        %\n%--------------------%\n%decl and inheritance and external imports\nrule replaceConcreteClassesWithInheritance\n    replace $ [concrete_class_declaration]\n        _ [acess_modifier] 'class className [nested_class] inheritances [repeat inheritance_list] '{ classBody [class_body_decl] '} \n    export className \n    construct inheritanceClasses [list nested_class]\n        _ [extractInheritanceBlockClasses each inheritances]\n    construct imports [repeat import_statement]\n        _ [createImports classBody inheritances]\n    by\n        imports 'class className '( inheritanceClasses ')':  classBody  [replaceClassBody]\nend rule\n\n%inheritance  imports\nrule replaceInterfacesWithInheritance\n    replace [interface_declaration]\n        _ [acess_modifier] 'interface className [nested_class] inheritances [repeat inheritance_list] '{ classBody [class_body_decl] '} \n    export className\n    construct inheritanceClasses [list nested_class]\n        _ [extractInheritanceBlockClasses each inheritances]\n    construct imports [repeat import_statement]\n        _ [createImports classBody inheritances]\n    construct AbcClass [list nested_class]\n        'ABC\n    construct finalInheritances [list nested_class]\n        AbcClass [, inheritanceClasses]\n    by\n        'from 'abc 'import 'ABC, 'abstractmethod imports 'class className '(  finalInheritances '):  classBody [replaceClassBody] [replaceInterfaceBody]\nend rule\n\nfunction replaceInterfaceBody\n   replace [class_body_decl]\n        elements [repeat class_body_element]\n    construct declarations [repeat member_variable_declaration]\n        _ [^ elements]\n    export enumeratorDeclerations [repeat enum_declaration]\n        _ [^ elements]\n    construct memberVariables [repeat id]\n        _ [addMemberVariable each declarations]\n    construct listMemberVariables [repeat id]\n        _ [addListMemberVariable each declarations]\n    by\n        '@abstractmethod 'def '__init__(self): 'pass elements [replaceAllMethods]\nend function\n\nfunction replaceClassBody\n    replace [class_body_decl]\n        elements [repeat class_body_element]\n    construct declarations [repeat member_variable_declaration]\n        _ [^ elements]\n    construct transientMembers [repeat id]\n        _ [addIfTransient each declarations]\n    export transientMembers\n    construct memberVariables [repeat id]\n        _ [addMemberVariable each declarations]\n    construct listMemberVariables [repeat id]\n        _ [addListMemberVariable each declarations]\n    export enumeratorDeclerations [repeat enum_declaration]\n        _ [^ elements]\n    by\n        elements [removeMemberVariableDeclarations] [replaceEnumDeclaration] \n            [replaceAllLists listMemberVariables]\n            [replaceConstructor memberVariables] \n            [replaceAllMethods]\n            [replaceAllMemberVariableNames memberVariables] \nend function\n\nfunction getTransientMembers decls [repeat member_variable_declaration]\n    replace [repeat id]\n        result [repeat id]\n    by\n        result [addIfTransient each decls]\nend function\n\nfunction addIfTransient decl [member_variable_declaration]\n    replace [repeat id]\n        result [repeat id]\n    deconstruct decl\n        _ [opt acess_modifier] 'transient _ [opt static] _ [opt volatile] _ [variable_declaration]\n    by\n        result [addMemberVariable decl]\nend function\n\nfunction removeMemberVariableDeclarations\n    replace [repeat class_body_element]\n        elems [repeat class_body_element]\n    construct empty [repeat class_body_element]\n        _\n    by\n        empty [addIfNotMemberDecleration each elems]\nend function\n\nfunction addIfNotMemberDecleration elem [class_body_element]\n    replace [repeat class_body_element]\n        keepers [repeat class_body_element]\n    construct declerations [repeat member_variable_declaration]\n        _ [^ elem]\n    construct declerationSize [number]\n        _ [length declerations]\n    where\n        declerationSize [= 0]\n    by\n        keepers [. elem]\nend function\n\nfunction addMemberVariable MemberVariable [member_variable_declaration]\n    replace [repeat id]\n        SequenceSoFar [repeat id]\n    deconstruct MemberVariable\n        _[opt acess_modifier] _[opt transient] _[opt static] _[opt volatile]  decl [variable_declaration]\n    deconstruct decl\n        _ [nested_class] memberName [id]';\n    by\n        SequenceSoFar [. memberName]\nend function"},
{ "txl/ConstructorTranslation.txl", "rule replaceConstructor\n    replace [constructor]\n         mod [acess_modifier] className [id]'( params [list method_parameter +] ') '{ statements [repeat statement]  '}\n    construct newParams [list id]\n    by\n        'def '__init__(self, newParams [translateParams each params]'):  statements [replaceStatements]\nend rule\n\nrule replaceConstructorNoArgs\n    replace [constructor]\n         mod [acess_modifier] className [id]'() '{ statements [repeat statement]  '}\n    by\n        'def '__init__(self):  statements [replaceStatements]\nend rule"},
{ "txl/EnumTranslation.txl", "rule replaceEnumDeclaration\n    replace [enum_declaration]\n        _ [opt acess_modifier] 'enum enumName [id] '{ vals [list id] '}\n    construct enumValDeclarations [repeat enum_value_declaration]\n        _ [generateEnumValues vals]\n    by\n        'class enumName '(Enum'):\n            'def '_generate_next_value_('name, 'start, 'count, 'last_values)':\n                'return 'name\n            'def '__str__'(self):\n                'return 'str(self. 'value)\n        enumValDeclarations\nend rule\n\nfunction generateEnumValues vals [list id]\n    replace [repeat enum_value_declaration]\n        decls [repeat enum_value_declaration]\n    by\n        decls [generateEnumValue each vals]\nend function\n\nfunction generateEnumValue val [id]\n    replace [repeat enum_value_declaration]\n        decls [repeat enum_value_declaration]\n    construct decl [enum_value_declaration]\n        val '= 'auto()\n    by decls [. decl]\nend function"},
{ "txl/ImportProcessing.txl", "function createImports classBody [class_body_decl] inheritances [repeat inheritance_list]\n    replace [repeat import_statement]\n        empty [repeat import_statement]\n    construct declarations [repeat member_variable_declaration]\n        _ [^ classBody]\n    construct declarationClassesToImport [repeat id]\n        _ [getClassesToImport classBody each declarations]\n    construct allInternalClassesToImport [repeat id]\n        _ [extractInheritanceImportClasses classBody each inheritances] [concatenateRepeatNoDuplicates declarationClassesToImport]\n    construct allImports [repeat import_statement]\n        _ [addImportStatement each allInternalClassesToImport] [addExternalImports classBody]\n    by\n        allImports\nend function \n\nfunction addImportStatement a [id]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    construct newImport [import_statement]\n        'from a 'import a\n    by\n        imports [. newImport]\nend function\n\nfunction getClassesToImport classBody [class_body_decl] declaration [member_variable_declaration]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct declaration\n        _[opt acess_modifier] _[opt static] _[opt volatile] varDec [variable_declaration]\n    deconstruct varDec\n        class [nested_class] _ [id]';\n    construct classesToImport [repeat id]\n        _ [extractListClass classBody class] [extractRegularClass classBody class]\n    by \n        empty [addToRepeatIfNotThere each classesToImport] \nend function \n\nfunction isTypeEnum typeName [id]\n    match * [enum_declaration]\n        _ [opt acess_modifier] 'enum enumName [id] '{ _ [list id]'}\n    where\n        enumName [= typeName]\nend function\n\nfunction extractInheritanceBlockClasses inheritanceList [inheritance_list]\n    replace [list nested_class]\n        classes [list nested_class]\n    deconstruct inheritanceList\n        _[inheritance_statement] classesToAdd [list nested_class]\n    by\n        classes [inheritanceClassFilter each classesToAdd]\nend function\n\nfunction inheritanceClassFilter class [nested_class]\n    replace [list nested_class]\n        classes [list nested_class]\n    construct unparsed [stringlit]\n        _ [unparse class]\n    construct filter [repeat nested_class]\n        'java.io.Serializable \n    where not\n        filter [containsNestedClass class]\n    by\n        classes [, class]\nend function\n\nfunction extractInheritanceImportClasses classBody [class_body_decl] inheritanceList [inheritance_list]\n    replace [repeat id]\n        classesToImport [repeat id]\n    deconstruct inheritanceList\n        _[inheritance_statement] classesToAdd [list nested_class]\n    construct classIds [repeat id]\n        _ [extractListClass classBody each classesToAdd] [extractRegularClass classBody each classesToAdd]\n    by\n        classesToImport [. classIds] \nend function\n\n\nfunction concatenateRepeatNoDuplicates elems [repeat id]\n    replace [repeat id]\n        currentList [repeat id]\n    by\n        currentList [addToRepeatIfNotThere each elems] \nend function\n\nfunction addToRepeatIfNotThere elem [id]\n    replace [repeat id]\n        currentList [repeat id]\n    where not \n        currentList [containsId elem]\n    by\n        currentList [. elem]\nend function\n\nfunction extractListClass classBody [class_body_decl] class [nested_class]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct class\n        _ [id]'< ids [list id] '>\n    construct unfiltered [repeat id]\n        _ [listToRepeat ids] \n    construct filtered [repeat id]\n        _ [filterOutUnwantedTypes classBody unfiltered]\n    by\n        filtered\nend function\n\nfunction filterOutUnwantedTypes classBody [class_body_decl] ids [repeat id]\n    replace [repeat id]\n        empty [repeat id]\n    by \n        empty [addIfNotDefaultTypeOrEnum classBody each ids]\nend function\n\nfunction addIfNotDefaultTypeOrEnum classBody [class_body_decl] id [id]\n    replace [repeat id]\n        current [repeat id]\n    where not \n        id [matchDefaultType]\n    where not \n        classBody [isTypeEnum id]\n    by\n        current [. id] \nend function\n\nrule matchDefaultType\n    match [id]\n        id [id]\n    construct defaults [repeat id]\n        'byte 'short 'int 'long 'float 'double 'boolean 'char 'String 'Array\n    where\n        defaults [containsId id]    \nend rule\n\nfunction extractRegularClass classBody [class_body_decl] class [nested_class]\n    replace [repeat id]\n        empty [repeat id]\n    deconstruct class\n        id [id]\n    where not \n        id [matchDefaultType]\n    where not \n        classBody [isTypeEnum id]\n    by\n        empty [. id]\nend function\n\nfunction listToRepeat ids [list id]\n    replace [repeat id]\n        aRep [repeat id]\n    by \n        aRep [addToRepeat each ids]\nend function\n\nfunction addToRepeat a [id]\n     replace [repeat id]\n        aRep [repeat id]\n    by \n        aRep [. a]\nend function\n\nfunction repeatToList aRep [repeat id]\n    replace [list id]\n        aList [list id]\n    by \n        aList [addToList each aRep]\n\nend function\n\n\nfunction addToList anys [id]\n     replace [list id]\n        aRep [list id]\n    by \n        aRep [, anys]\nend function\n\nfunction addListMemberVariable MemberVariable [member_variable_declaration]\n    replace [repeat id]\n        SequenceSoFar [repeat id]\n    deconstruct MemberVariable\n        _[opt acess_modifier] decl [variable_declaration]\n    deconstruct decl\n        'List '< _ [list id] '> memberName [id]';\n    by\n        SequenceSoFar [. memberName]\nend function\n\nfunction replaceAllMemberVariableNames memberVariables [repeat id]\n    replace [any]\n        any [any]\n    by \n        any \n            [replaceMemberVariableNames memberVariables] \n            [replaceMemberVariableNamesWithThis memberVariables]\n            [replaceMemberVariableNamesBrackets memberVariables]\nend function\n\nrule replaceMemberVariableNames memberVariables [repeat id]\n    replace [nested_identifier]\n         name [id] rep [repeat attribute_access]\n    where \n        memberVariables [containsId name]\n    construct underscore [id]\n        '_\n    construct newName [id]\n        underscore [+ name] \n    by\n        'self '. newName rep\nend rule\n\nrule replaceMemberVariableNamesWithThis memberVariables [repeat id]\n    replace [nested_identifier]\n        'this '. name [id] rep [repeat attribute_access]\n    where \n        memberVariables [containsId name]\n    construct underscore [id]\n        '_\n    by\n        'self '. underscore [+ name] rep\nend rule\n\nrule replaceMemberVariableNamesBrackets memberVariables [repeat id]\n    replace [nested_identifier]\n         name [id] '[ val [value] ']  rep [repeat attribute_access]\n    where \n        memberVariables [containsId name]\n    construct underscore [id]\n        '_\n    construct newName [id]\n        underscore [+ name]\n    by\n        'self '. newName '[ val ']  rep\nend rule\n\n\nrule containsId Object [id]\n    match [id]\n        Object\nend rule\n\nrule containsNestedClass Object [nested_class]\n    match [nested_class]\n        Object\nend rule\n\n%--------------------%\n%  External imports  %\n%--------------------%\n\nfunction addExternalImports body [class_body_decl]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    by\n        imports [addOSImportIfNeeded body]\n        [addEnumImportIfNeeded body]\n        [addPickleImportIfNeeded]\nend function\n\n\nfunction addOSImportIfNeeded body [class_body_decl]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    where\n        body [shouldOsImport]\n    construct newImport [import_statement]\n        'import 'os\n    by \n        imports [. newImport]\nend function\n\nfunction shouldOsImport\n    match * [nested_identifier]\n        'System.getProperties().getProperty(\"line.separator\")\nend function\n\nfunction addEnumImportIfNeeded body [class_body_decl]\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    where\n        body [shouldEnumImport]\n    construct newImport [import_statement]\n        'from 'enum 'import 'Enum, 'auto\n    by \n        imports [. newImport]\nend function\n\nfunction shouldEnumImport\n    match * [enum_declaration]\n        _ [enum_declaration]\nend function\n\nfunction addPickleImportIfNeeded\n    replace [repeat import_statement]\n        imports [repeat import_statement]\n    import Imports [repeat import_statement]\n    where\n        Imports [shouldImportPickle]\n    construct newImport [import_statement]\n        'import 'pickle\n    by \n        imports [. newImport]\nend function\n\nfunction shouldImportPickle\n    match * [import_statement]\n        'import 'java.io.Serializable;\nend function"},
{ "txl/Java.Grm", "comments\n    //\n    /*  */\nend comments\n\ncompounds \n    'self. '== '!=\nend compounds \n\ntokens\n    number  \"(-\\s?)?\\d+(.\\d+)?\"\nend tokens\n\n%--------------------%\n%     Statements     %\n%--------------------%\n\nkeys\n return new if else for true false while this super tuple len True False + - * / ? ; : pass\nend keys\n\ndefine acess_modifier\n        'private\n    |   'public\n    |   'protected\nend define\n\ndefine boolean_operator\n        '&&\n    |   '|'|\nend define\n\ndefine comparator\n        '==\n    |   '!=\n    |   '>\n    |   '<\n    |   '>=\n    |   '<=\nend define\n\ndefine arithmatic_operator\n        '+\n    |   '-\n    |   '*\n    |   '/\n    |   '%\nend define\n\ndefine program\n    [repeat package_statement]  \n    [repeat import_statement]\n    [repeat class_declaration]\nend define\n\ndefine package_statement \n    'package [imported]';\nend define\n\ndefine import_statement \n    'import [imported]';\nend define\n\n\n\ndefine imported\n        [id]\n    |   '*\n    |   [id]'. [imported]\nend define\n\ndefine nested_class\n    [nestable_class] [repeat nested_class_access]\nend define\n\ndefine nested_class_access\n    '. [nestable_class]\nend define\n\ndefine nestable_class\n    [id]'< [list id] '>\n    | [id] \nend define\n\ndefine arithmatic_expression\n       [value_no_recursion] [arithmatic_operator] [arithmatic_expression]\n    |   [value_no_recursion]\nend define\n\ndefine nested_identifier\n     [nestable_value] [SPOFF] [repeat attribute_access] [SPON]\nend define\n\ndefine attribute_access\n       '. [nestable_value] \nend define\n\ndefine nestable_value \n        [function_call]\n    |    [id]\n    |   'this\n    |   'super\nend define\n\ndefine value_no_recursion \n        [new_call]\n    |   '( [value]')\n    |   [nested_identifier]\n    |   [nested_class] '. [id]\n    |   [number]\n    |   [stringlit]\n    |   'null\n    |   'true\n    |   'false\n    |   [casting]\n    |   '! [boolean_expression]\n    |   [method_reference]\nend define\n\ndefine method_reference\n    [nested_class] ':: [id]\nend define\n\ndefine value\n       [value_no_ternary]\n    |   [ternary]\nend define\n\ndefine value_no_ternary\n        [value_no_recursion]\n    |   [boolean_expression]\n    |   [arithmatic_expression]\nend define\n\ndefine new_call\n    'new [nested_class] '( [list value] ')\nend define\n\ndefine variable_declaration\n        [nested_class] [assignment] '; [NL]\n    |   [nested_class] [nested_identifier]';\nend define\n\ndefine assignment\n        [nested_identifier] '= [value] \n    |    [nested_identifier]'++\n    |    [nested_identifier]'--\n    |   [nested_identifier] '+= [value]\n    |   [nested_identifier] '-= [value]\nend define\n\n\ndefine stmt_return\n        'return [value] '; [NL]\nend define\n\ndefine statement\n        [variable_declaration]\n    |   [stmt_return]\n    |   [conditional_block]\n    |   [for_loop]\n    |   [for_in_loop]\n    |   [while_loop]\n    |   [nested_identifier]'; [NL]\n    |   [assignment] '; [NL]\n    |   [throw_statement]\n    |   [switch_case]\nend define\n\ndefine while_loop\n    'while( [value] ') [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine ternary\n    [value_no_recursion] '? [value] ': [value]\nend define\n\ndefine for_loop\n    'for( [variable_declaration] [value]'; [assignment]') '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine for_in_loop\n    'for( [nested_class] [id] ': [nested_identifier]')'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine switch_case\n    'switch( [value] ') '{ [repeat switch_case_case] [opt switch_case_default] '}\nend define\n\ndefine switch_case_case\n    'case [value] ': [repeat statement] 'break;\nend define\n\ndefine switch_case_default\n    'default ': [repeat statement]\nend define\n\ndefine conditional_block\n    [if] [repeat else_if] [opt else]\nend define\n\ndefine if \n    'if '( [value] ') '{  [repeat statement]  '}\n    | 'if '( [value] ') [statement]\nend define\n\ndefine else_if\n    'else 'if '( [value] ') [NL]'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine else\n    'else [NL]'{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine throw_statement\n    'throw 'new [id] '( [stringlit] ');\nend define\n\ndefine casting\n    '( [nested_class]') [value]\nend define\n\ndefine function_call\n        [id][SPOFF] '( [SPON] [list value]')    \nend define\n\ndefine boolean_expression\n        [condition] [repeat boolean_continuation]\nend define\n\ndefine boolean_continuation\n        [boolean_operator] [condition]\nend define\n\ndefine condition\n        [value_no_recursion] [comparator] [value]\n    |   [value_no_recursion]\nend define\n\ndefine method_parameter\n    [nested_class] [id]\nend define\n\ndefine decorator\n    '@ [SPOFF] [id] [SPON] [NL]\nend define\n\ndefine throws\n    'throws [list nested_class]\nend define\n\ndefine concrete_method_declaration\n        [opt decorator] [acess_modifier] [opt static] [nested_class] [id] '( [list method_parameter] ') [opt throws] [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine method_declaration\n        [concrete_method_declaration]\n    |   [abstract_method_declaration]\nend define\n\ndefine abstract_method_declaration\n    [acess_modifier] [nested_class] [id] '( [list method_parameter] '); [NL]\nend define\n\ndefine inheritance_statement\n        'extends\n    |   'implements\nend define\n\n\n%--------------------%\n%        Class       %\n%--------------------%\n\ndefine class_declaration\n        [concrete_class_declaration]\n    |   [interface_declaration]\nend define\n\ndefine concrete_class_declaration\n    [acess_modifier] 'class [nested_class] [repeat inheritance_list] [NL] '{ [NL] [IN] [class_body_decl] [EX] '} [NL]\nend define\n\ndefine inheritance_list\n    [inheritance_statement] [list nested_class]\nend define\n\ndefine interface_declaration\n        [acess_modifier] 'interface [nested_class] [repeat inheritance_list] [NL] '{ [NL] [IN] [class_body_decl] [EX] '} [NL]\nend define\n\ndefine class_type\n        'class\n    |   'interface\nend define\n\ndefine static\n    'static\nend define\n\ndefine volatile\n    'volatile\nend define\n\ndefine transient\n    'transient\nend define\n\ndefine constructor\n    [acess_modifier] [id]'( [list method_parameter] ') [opt throws] [NL] '{ [NL] [IN] [repeat statement] [EX] '} [NL]\nend define\n\ndefine enum_declaration\n    [opt acess_modifier] 'enum [id] '{ [list id]'}\nend define\n\ndefine member_variable_declaration\n    [opt acess_modifier] [opt transient] [opt static] [opt volatile] [variable_declaration]\nend define\n\ndefine class_body_decl\n    [repeat class_body_element]\nend define\n\ndefine class_body_element\n        [enum_declaration]\n    |   [member_variable_declaration]\n    |   [constructor]\n    |   [method_declaration]\nend define\n"},
{ "txl/ListTranslation.txl", "%--------------------%\n%  List replacement  %\n%--------------------%\n\nfunction replaceAllLists memberLists [repeat id]\n    replace [any]\n        any [any]\n    by \n        any\n            [replaceListAssignement memberLists]\n            [replaceListUnmutable memberLists]\n            [replaceGetListContent memberLists]\n            [replaceListGetSize memberLists]\n            [replaceListGetIndex memberLists]\n            [replaceListContains memberLists]\n            [replaceListAddAtIndex memberLists]\n            [replaceListAddNoIndex memberLists]\n            [replaceListCopy]\n            [replaceListSort memberLists]\nend function \n\nrule replaceListAssignement memberLists [repeat id]\n    replace [assignment]\n        id [id] '= 'new 'ArrayList '< _[list id] '> '(') \n    where\n        memberLists [containsId id]\n    by \n        id '= '[']\nend rule\n\nrule replaceListCopy\n    replace [assignment]\n        id [id] '= 'new 'ArrayList '< _[list id] '> '( oldList [nested_identifier]') \n    deconstruct oldList\n        val [nestable_value] rep [repeat attribute_access]\n    construct newNested [repeat attribute_access]\n        '.copy()\n    by \n        id '= val rep [. newNested]\nend rule\n\nrule replaceListUnmutable memberLists [repeat id]\n    replace [value]\n        'Collections.unmodifiableList( id [id] ')\n    where\n        memberLists [containsId id]\n    by \n        'tuple( id ')\nend rule\n\n\nrule replaceGetListContent memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '. 'get( index [value] ')  rest [repeat attribute_access]\n    where\n        memberLists [containsId id]\n    by \n        id '[ index '] rest \nend rule\n\nrule replaceListGetSize memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.size()\n    where\n        memberLists [containsId id]\n    by \n        'len( id ')\nend rule\n\nrule replaceListGetIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.indexOf( val [value] ')\n    where\n        memberLists [containsId id]\n    by \n        id '.index( val ')\nend rule\n\nrule replaceListContains memberLists [repeat id]\n    replace [value]\n        nested [nested_identifier]\n    deconstruct nested\n        id [id]'. 'contains '( val [value_no_recursion] ')\n    where\n        memberLists [containsId id]\n    by \n        val 'in id\nend rule\n\nrule replaceListAddAtIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.add( position [value] ', value [value] ')\n    where\n        memberLists [containsId id]\n    by \n        id '.insert( position ', value ')\nend rule\n\nrule replaceListAddNoIndex memberLists [repeat id]\n    replace [nested_identifier]\n        id [id] '.add( value [value] ')\n    where\n        memberLists [containsId id]\n    by \n        id '.append( value ')\nend rule\n\nrule replaceListSort memberLists [repeat id]\n    replace [nested_identifier]\n        'Collections.sort( listId [id] ', priorityFunc [id] ')\n    where\n        memberLists [containsId listId]\n    by \n        listId '.sort( 'key '= priorityFunc ')\nend rule"},
{ "txl/MethodTranslation.txl", "%--------------------%\n%     Methods        %\n%--------------------%\n\nfunction replaceAllMethods\n    replace [repeat class_body_element]\n        elems [repeat class_body_element]\n    by\n        elems\n            [removeOverrideDecorator]\n            [replaceToString]\n            [replaceAbstractMethod]\n            [replaceAbstractMethodNoArgs]\n            [replaceConcreteMethod]\n            [replaceConcreteMethodNoArgs]\n            [replaceStaticMethod]\n            [addGetState]\nend function\n\nrule removeOverrideDecorator\n    replace [opt decorator]\n        '@Override\n    by \n        _\nend rule\n\nrule replaceConcreteMethod\n    replace [concrete_method_declaration]\n        _[acess_modifier] _[nested_class] methodName [id]'( params [list method_parameter +] ') _ [opt throws] '{ statements [repeat statement] '}\n    construct newParams [list id]\n    by\n        'def methodName '(self, newParams [translateParams each params] '):  statements [replaceStatements] [changeKeyArgumentNameInNestedIdentifier]\nend rule\n\nrule replaceConcreteMethodNoArgs\n    replace [concrete_method_declaration]\n        _[acess_modifier] _[nested_class] methodName [id]'() _ [opt throws] '{ statements [repeat statement] '}\n    by\n        'def methodName '(self):  statements [replaceStatements]\nend rule\n\nrule replaceAbstractMethod\n    replace [abstract_method_declaration]\n        _[acess_modifier] _[nested_class] methodName [id] '( params [list method_parameter +] ');\n    construct newParams [list id]\n    by\n        '@abstractmethod 'def methodName '(self, newParams [translateParams each params] '): 'pass\nend rule\n\nrule replaceAbstractMethodNoArgs\n    replace [abstract_method_declaration]\n        _[acess_modifier] _[nested_class] methodName [id]'();\n    by\n        '@abstractmethod 'def methodName '(self): 'pass\nend rule\n\nrule replaceToString\n    replace [method_declaration]\n        _[acess_modifier] _[nested_class]  'toString '() _ [opt throws] '{ statements [repeat statement] '}\n    by\n        'def '__str__ '(self):  statements [replaceStatements] \nend rule\n\nrule replaceStaticMethod\n    replace [method_declaration]\n        _[acess_modifier] _[static] _[nested_class] methodName [id]'() _ [opt throws] '{ statements [repeat statement] '}\n    by\n        '@staticmethod 'def methodName '():  statements [replaceStatements] [changeKeyArgumentNameInNestedIdentifier]\nend rule\n\nrule replaceConstructor memberVariables [repeat id]\n    replace [constructor]\n         mod [acess_modifier] className [id]'( params [list method_parameter] ') _ [opt throws] '{ statements [repeat statement]  '}\n    construct selfParam [list id]\n        'self\n    construct modifiedParams [list id]\n        _ [translateParams each params]\n    by\n        'def '__init__( selfParam [, modifiedParams] '):  \n            statements \n                [addNoneAssignmentIfNeeded each memberVariables] \n                [replaceStatements] \n                [changeKeyArgumentNameInNestedIdentifier]\nend rule\n\n\nfunction addGetState\n    replace [repeat class_body_element]\n        rep [repeat class_body_element]\n    import transientMembers [repeat id]\n    construct transientCount [number]\n        _ [length transientMembers]\n    where \n        transientCount [> 0]\n    construct stateDeclaration [repeat statement]\n        'state '= 'dict(self '.__dict__ ')\n    construct pops [repeat statement]\n        _ [createGetStatePop each transientMembers]\n    construct returnStatement [statement]\n        'return 'state\n    construct getStateStatements [repeat statement]\n        stateDeclaration [. pops] [.returnStatement]\n    construct getStateFunc [class_body_element]\n        'def '__getstate__(self):\n            getStateStatements\n    by\n        rep [. getStateFunc]\nend function\n\nfunction createGetStatePop id [id]\n    replace [repeat statement] \n        result [repeat statement] \n    construct memberAsString [stringlit]\n        _ [unparse id]\n    construct underscore [stringlit]\n        \"_\"\n    construct memberAsStringWithUnderscore [stringlit]\n        underscore [+ memberAsString]\n    construct pop [statement]\n        'state '.pop( memberAsStringWithUnderscore ')\n    by\n        result [. pop]\nend function\n\nfunction translateParams PreviousParam [method_parameter]\n    replace [list id]\n        SequenceSoFar [list id]\n    deconstruct PreviousParam\n        _ [nested_class] paramName [id]\n    construct cleanName [id]\n        paramName [changeKeyArgumentName]\n    by\n        SequenceSoFar [, cleanName]\nend function\n\nrule changeKeyArgumentName\n    replace $ [id]\n        argName [id]\n    by  \n        argName\n            [replaceInKeyArgument]\nend rule\n\nrule changeKeyArgumentNameInNestedIdentifier\n    replace $ [nested_identifier]\n        root [id] rep [repeat attribute_access]\n    by \n        root [changeKeyArgumentName]  rep\nend rule\n\nrule replaceInKeyArgument\n    replace [id]\n        'in\n    by \n        'input\nend rule\n\n\nfunction addNoneAssignmentIfNeeded memberVariable [id]\n    replace [repeat statement]\n        results [repeat statement]\n    where not\n        results [isMemberAssigned memberVariable]\n    construct noneAssignment [statement]\n        memberVariable '= 'None\n    by\n        results [. noneAssignment]\nend function\n\nrule isMemberAssigned memberVar [id]\n    match [assignment]\n        memberVar '= _ [value] \nend rule "},
{ "txl/Python.Grm", "include \"Java.Grm\"\n\n%Num of char in a line before TXL splits it in two. Hopefully a temporary solution.\n#pragma -width 1073741824\n\n\nredefine boolean_operator\n    ...\n    |'and\n    | 'or\nend redefine\n\nredefine comparator\n    ...\n    |   'is\n    |   'in\nend redefine\n\nredefine nestable_value\n    ...\n    | 'self\n    |  [array_access]\nend redefine\n\n\ndefine array_access\n    [id] [SPOFF] '[ [value] '] [SPON]\nend define\n\nredefine assignment\n    ...\n    |   [nested_identifier] '= [value] [NL]\nend redefine\n\nredefine statement\n    ...\n    |  [nested_identifier] [NL]\n    | 'pass [NL]\nend redefine\n\nredefine stmt_return\n    ...\n    |   'return [value] [NL]\nend redefine\n\n\nredefine value_no_recursion\n    ...\n    |   'True\n    |   'False\n    |   'None\n    |   '[ [list value] ']\n    |   'not [boolean_expression] \n    |   [lambda_function]\nend redefine\n\ndefine  lambda_function\n    'lambda [list id] ': [value]\nend define \n\ndefine python_function_name\n        'tuple\n    |   'len\n    |   'super\nend define\n\nredefine function_call\n    ...\n    |   [id] [SPOFF] '( [SPON] [list value] [list assignment]')\n    |   [python_function_name] [SPOFF] '( [SPON] [list value] [list assignment]')\nend redefine\n\n\nredefine for_loop\n    ...\n    |'for [nestable_value] 'in 'range( [value] ', [value] ', [value] '): [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine for_in_loop\n    ...\n    | 'for [id] 'in  [nested_identifier] [SPOFF] ': [SPON] [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine while_loop\n    ...\n    | [opt variable_declaration] 'while [value] ': [NL] [IN] [repeat statement] [EX] [NL]\nend redefine\n\nredefine if \n    ... \n    |   'if [value] ': [NL] [IN] [repeat statement] [EX] \nend redefine\n\nredefine else_if\n    ...\n    |   'elif [value] ': [NL] [IN] [repeat statement] [EX] \nend redefine\n\nredefine else\n    ...\n    |   'else:  [NL] [IN] [repeat statement] [EX] \nend redefine\n\nredefine throw_statement\n    ...\n    |   'raise 'RuntimeError( [stringlit] ') [NL]\nend redefine\n\n\nredefine method_parameter\n    ...\n    | [id]\nend redefine\n\nredefine ternary\n    ...\n    |   [value_no_ternary] 'if [value] 'else [value]\nend redefine\n\nredefine concrete_method_declaration\n    ...\n    |   [opt decorator] 'def  [id] [SPOFF]'(self, [SPON] [list id] [SPOFF] '): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [opt decorator] 'def  [id] [SPOFF]'(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [opt decorator] 'def  [id] [SPOFF]'(): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\nredefine abstract_method_declaration\n    ...\n    |   [SPOFF] '@abstractmethod [SPON] [NL] 'def  [id] [SPOFF]'(self, [SPON] [list id] [SPOFF] '): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\n    |   [SPOFF] '@abstractmethod [SPON] [NL] 'def  [id] [SPOFF]'(self): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\n\nredefine constructor\n    ...\n    | 'def '__init__ [SPOFF] '( [SPON] [list id] [SPOFF]'): [SPON] [NL] [IN] [repeat statement] [NL] [EX] [NL]\nend redefine\n\nredefine concrete_class_declaration\n    ... \n    | [repeat import_statement] [NL] 'class [nested_class] [SPOFF] [opt inheritance_group] ': [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\nend redefine\n\ndefine inheritance_group\n    '( [SPON] [list nested_class] [SPOFF] ')\nend define\n\nredefine interface_declaration\n    ... \n    |  [import_statement] [repeat import_statement] [NL] 'class [nested_class] [SPOFF] '( [SPON] [list nested_class] [SPOFF] '): [SPON] [NL] [IN] [class_body_decl] [NL] [EX] [NL]\nend redefine\n\nredefine class_body_decl\n    ...\n    | 'pass\n    | [opt constructor] [repeat method_declaration]\nend redefine\n\nredefine variable_declaration\n    ...\n    |   [assignment] [FL]\n    |   [id] [FL]\nend redefine\n\nredefine import_statement\n    ...\n    |   'from [nested_class] 'import [nested_class] [NL]\n    |   'from [nested_class] 'import [list nested_class] [NL]\n    |   'import [id] [NL]\nend redefine \n\nredefine enum_declaration\n    ...\n    | 'class [id] [SPOFF] '(Enum'): [SPON][NL] \n        [IN] 'def '_generate_next_value_ [SPOFF] '( [SPON] 'name, 'start, 'count, 'last_values) [SPOFF] ': [SPON] [NL] \n            [IN] 'return 'name [NL] \n        [EX] 'def '__str__ [SPOFF] '(self): [SPON] [NL] \n            [IN] 'return 'str [SPOFF] '(self. 'value) [SPON] [NL] \n        [EX] [repeat enum_value_declaration] [NL]\n    [EX]\nend redefine\n\ndefine enum_value_declaration\n    [id] '= 'auto [SPOFF] () [SPON] [NL]\nend define\n\nredefine switch_case\n    ...\n    |   'match [value] ': [NL] [IN] [repeat switch_case_case] [opt switch_case_default] [EX]\nend redefine\n\nredefine switch_case_case\n    ...\n    |   'case [value] ': [NL] [IN] [repeat statement] [EX]\nend redefine\n\nredefine switch_case_default\n    ...\n    |   'case 'default ': [NL] [IN] [repeat statement] [EX]\nend redefine\n"},
{ "txl/StatementTranslation.txl", "%--------------------%\n%     Statements     %\n%--------------------%\nfunction replaceStatements\n    replace [repeat statement]\n        statements [repeat statement]\n    by \n        statements\n            [replaceDefaultReadObject]\n            [reorderNestedIdentifier]\n            [replaceSwitchCase]\n            [addClassPrefixToEnum]\n            [replaceForLoop]\n            [replaceForInLoop]\n            [replaceAssignmentStatement] \n            [replaceReturn] \n            [replaceNoStatements] \n            [addSelfToOwnMethodCalls]\n            [replaceThisFunctionCall]\n            [replaceNestedStatement]\n            [replaceDecleration]\n            [replaceTernary]\n            [replaceAllBoolean]\n            [replaceDeclerationWithAssignment]\n            [replaceInlineIf]\n            [replaceIf]\n            [replaceElseIf]\n            [replaceElse]\n            [replaceWhile]\n            [replaceNull]\n            [replaceThis]\n            [replaceIncrement]\n            [replaceDecrement]\n            [replaceThrowError]\n            [replaceNewCall]\n            [replaceCasting]\n            [correctSuperInit]\n            [correctSuperFunctions]\n            [replaceSuperToString]\n            [replaceNewLine]\n            [replaceHexIdentity]\n            [replaceComparator]\nend function\n\nfunction replaceNoStatements\n    replace [repeat statement]\n    by \n        'pass  \nend function\n\nrule replaceAssignmentStatement\n    replace [statement]\n        identifier [nested_identifier] '= val [value] '; \n    by \n        identifier '= val\nend rule\n\nrule replaceReturn\n    replace [stmt_return]\n        'return val [value] ';\n    by \n        'return val\nend rule\n\nrule addSelfToOwnMethodCalls\n    replace [nested_identifier]\n        funcName [id] '( values [list value]') rep [repeat attribute_access]\n    where\n        funcName [~= 'str]\n    by\n        'self '. funcName '( values') rep\nend rule\n\nrule replaceThisFunctionCall\n    replace [nested_identifier]\n        'this. funcName [id] '( values [list value]')\n    by\n        'self '. funcName '( values')\nend rule\n\nrule replaceNestedStatement\n    replace [statement]\n        stmt [statement]\n    deconstruct stmt\n        value [nested_identifier] ';\n    by\n        value\nend rule\n\n\nrule replaceThis\n    replace [value]\n        'this\n    by \n        'self\nend rule\n\nrule replaceDeclerationWithAssignment\n    replace [variable_declaration]\n        _ [nested_class] assignment [assignment] ';\n    by \n        assignment\nend rule\n\nrule replaceDecleration\n    replace [variable_declaration]\n        _[nested_class] varName [id]';\n    by \n        varName \nend rule\n\nrule replaceIf\n    replace [if]\n        'if '( bool [value] ') '{ statements [repeat statement]  '}\n    by \n        'if bool ': statements\nend rule\n\nrule replaceInlineIf\n     replace [if]\n        'if '( bool [value] ')  statement [ statement]  \n    by \n        'if bool ': statement\nend rule\n\nrule replaceElseIf\n    replace [else_if]\n        'else 'if '( bool [value] ') '{  statements [repeat statement]  '} \n    by \n        'elif bool ': statements\nend rule\n\n\nrule replaceElse\n    replace [else]\n        'else '{  statements [repeat statement]  '} \n    by \n        'else ': statements\nend rule\n\n\nrule replaceTernary\n    replace [ternary]\n        condition [value_no_recursion] '? opt1 [value] ': opt2 [value]\n    by\n        '( opt1 ') 'if condition 'else opt2\nend rule\n\nrule replaceWhile\n    replace [while_loop]\n        'while( val [value] ')  '{ statements [repeat statement] '} \n    by\n        'while val ':  statements \nend rule\n\nrule replaceNull\n    replace [value]\n        'null\n    by\n        'None\nend rule\n\n\nrule replaceDecrement\n    replace [assignment]\n        nest [nestable_value] '--\n    construct decr [arithmatic_expression]\n        nest '- '1\n    by \n        nest '= decr\nend rule\n\nrule replaceIncrement\n    replace [assignment]\n        nest [nestable_value] '++\n    by \n        nest '= nest '+ '1\nend rule\n\nrule replaceForLoop\n    replace [statement]\n        'for( decl [variable_declaration] goal [value]'; assignment [assignment]') '{  stmts[repeat statement]  '} \n    deconstruct decl\n        _[nested_class] name [id] '= start [value] ';\n    construct declaration [variable_declaration]\n        name '= start\n    construct newStatements [repeat statement]\n        assignment\n    by \n        declaration 'while goal ':  stmts  [. newStatements]\nend rule\n\nrule replaceForInLoop\n    replace [for_in_loop]\n        'for( _[nested_class] var [id] ': nested [nested_identifier]')'{ stmts [repeat statement] '} \n    by \n        'for var 'in  nested':  stmts\nend rule\n\nrule replaceThrowError\n    replace [throw_statement]\n        'throw 'new _[id] '( message [stringlit] ');\n    by\n        'raise 'RuntimeError(  message ') \nend rule \n\nrule replaceCasting\n    replace [value]\n        '( _ [nested_class]') name [value]\n    by \n        name \nend rule\n\nrule replaceNewCall\n    replace [value]\n        'new class [nested_class] '( vals [list value] ')\n    deconstruct class\n        id [id]\n    by\n        id '( vals ')\nend rule\n\nrule correctSuperInit\n    replace [nested_identifier]\n        'super( params [list value] ')\n    by\n        'super().__init__( params ')\nend rule\n\nrule correctSuperFunctions\n    replace [nested_identifier]\n        'super rep [repeat attribute_access]\n    by\n        'super() rep\nend rule\n\nrule replaceSuperToString\n    replace [nested_identifier]\n        'super().toString() rep [repeat attribute_access]\n    by\n        'super().__str__() rep\nend rule\n\nrule replaceNewLine\n    replace [nested_identifier]\n        'System.getProperties().getProperty(\"line.separator\")\n    by\n        'os.linesep\nend rule \n\nrule replaceHexIdentity\n    replace [nested_identifier]\n        'Integer.toHexString(System.identityHashCode( val [value_no_recursion] '))\n    by\n        'format( 'id( val '), '\"x\")\nend rule\n\nrule replaceSwitchCase\n    replace [statement]\n        'switch( val [value_no_recursion] ') '{ cases [repeat switch_case_case]  default [opt switch_case_default] '}\n    construct firstCase [repeat switch_case_case]\n        cases [head 1]\n    construct otherCases [repeat switch_case_case]\n        cases [tail 2]\n    construct ifElses [repeat else_if]\n        _ [replaceSwitchCaseCase val each otherCases]\n    construct throwAwayIf [if]\n        'if 'a: 'pass\n    construct realIf [if]\n        throwAwayIf [replaceFirstSwitchCaseCase val each firstCase]\n    construct else [opt else]\n        _ [replaceSwitchCaseDefault default]\n    by\n        realIf ifElses else\nend rule\n\n\nfunction replaceFirstSwitchCaseCase switch [value_no_recursion] firstCase [switch_case_case] \n    replace [if]\n        _ [if]\n    deconstruct firstCase\n        'case val [value] ': stmts [repeat statement] 'break;\n    construct condition [condition]\n        switch '== val [fixEnumValueWithNoEnum]\n    construct newIf [if]\n        'if condition ': stmts [replaceNoStatements]\n    by \n        newIf\nend function\n\nfunction replaceSwitchCaseCase switch [value_no_recursion] aCase [switch_case_case] \n    replace [repeat else_if]\n        rep [repeat else_if]\n    deconstruct aCase\n        'case val [value] ': stmts [repeat statement] 'break;\n    construct elseIf [else_if]\n        'elif switch '== val [fixEnumValueWithNoEnum] ': stmts [replaceNoStatements]\n    by \n        rep [. elseIf]\nend function\n\nfunction replaceSwitchCaseDefault defaultCase [opt switch_case_default]\n    replace [opt else]\n        _ [opt else]\n    deconstruct defaultCase\n        'default ': stmts [repeat statement]\n    by\n        'else: stmts [replaceNoStatements]\n\nend function\n\nfunction replaceDefaultReadObject\n    replace [repeat statement]\n        rep [repeat statement]\n    construct seeking [statement]\n        'in.defaultReadObject();\n    deconstruct seeking\n        seekingAny [any]\n    where \n        rep [containsGeneric seekingAny]\n    construct repAny [repeat any]\n        _ [repeatStatementToAny each rep]\n    construct beforeAfter [repeat sequence_any]\n        _ [getBeforeAfter seekingAny repAny]\n    deconstruct beforeAfter \n        beforeAfterRep [repeat sequence_any]\n    %reparse result to get back to original type\n    construct before [repeat sequence_any]\n        beforeAfterRep [select 1 1] \n    construct after [repeat sequence_any]\n        beforeAfterRep [select 2 2]\n    construct beforeReparsed [repeat statement]\n        _ [reparse before]\n    construct afterReparsed [repeat statement]\n        _ [reparse after]\n    construct middle [repeat statement]\n        'self '.__dict__ '.clear()\n        'self '.__dict__ '.clear() '.update(pickle '.load(input) '.__dict__)\n    by \n        beforeReparsed [. middle] [. afterReparsed]\nend function\n\nfunction repeatStatementToAny stmt [statement]\n    replace [repeat any]\n        rep [repeat any]\n    deconstruct stmt\n        stmtAny [any]\n    by\n        rep [. stmtAny]\nend function\n\nrule replaceComparator\n    replace [value]\n        'Comparator.comparing( class [nested_class] ':: funcName [id] ')\n    by\n        'lambda 'x ': 'x '. funcName '()\nend rule\n\n%--------------------------------%\n%  Switch case Enum correction   %\n%--------------------------------%\n\nrule fixEnumValueWithNoEnum\n    replace $ [value]\n        val [value]\n    deconstruct val\n        _ [id]\n    import enumeratorDeclerations [repeat enum_declaration]\n    by\n        val [fixEnumValueWithNoEnumCheck each enumeratorDeclerations]\nend rule\n\nrule fixEnumValueWithNoEnumCheck aEnum [enum_declaration]\n    replace [value]\n        identifier [id]\n    deconstruct aEnum \n        _ [opt acess_modifier] 'enum enumName [id] '{ vals [list id]'}\n    where\n        identifier [= each vals]\n    by\n        enumName '. identifier\nend rule\n\nrule addClassPrefixToEnum\n    replace [value]\n        enumName [id] '.  enumVal [id]\n    where\n        enumName [isAnEnum]\n    import className [nested_class]\n    deconstruct className\n        root [nestable_class] accesses [repeat nested_class_access]\n    construct addedAccess [nested_class_access] \n        '. enumName\n    construct newClassName [nested_class]\n        root accesses [. addedAccess]\n    by\n        newClassName '. enumVal\nend rule\n\nfunction isAnEnum\n    match [id]\n        name [id]\n    import enumeratorDeclerations [repeat enum_declaration]\n    where\n        name [isSpecificEnum each enumeratorDeclerations]\nend function\n\nfunction isSpecificEnum aEnum [enum_declaration]\n    match [id]\n        name [id]\n    deconstruct aEnum    \n        _ [opt acess_modifier] 'enum enumName [id] '{ _ [list id]'}\n    where\n        name [= enumName]\nend function\n%--------------------------------%\n%  Nested Identifier reordering  %\n%--------------------------------%\n\nrule reorderNestedIdentifier\n    replace [nested_identifier]\n        nested [nested_identifier]\n    construct seeking [attribute_access]\n        '.toString() \n    where \n        nested [containsAttributeAccess seeking]\n    by\n        nested [reorderToString]\nend rule\n\nfunction reorderToString\n    replace [nested_identifier]\n        nested [nested_identifier]\n    construct funcName [id]\n        'str\n    construct seeking [attribute_access]\n        '.toString()\n    by\n        nested [reorderSpecific seeking funcName]\nend function\n\nfunction reorderSpecific seeking [attribute_access] funcName [id]\n    replace [nested_identifier]\n        nested [nested_identifier]\n    deconstruct nested\n        root [nestable_value] rep [repeat attribute_access]\n    where \n        nested [containsAttributeAccess seeking]\n    construct zero [number]\n        '0 \n    construct count [number]\n        zero [findCount seeking rep]\n    by\n        nested [swap count funcName]\nend function\n\nfunction findCount seeking [attribute_access] rep [repeat attribute_access]\n    replace [number]\n        count [number]\n    construct repLength [number]\n        _ [length rep]\n    construct head [repeat attribute_access]\n        rep [head 1]\n    where \n        repLength [> 0]\n    construct remaining [repeat attribute_access]\n        rep [tail 2]\n    where not\n        head [containsAttributeAccess seeking] \n    by\n        count [+ 1] [findCount seeking remaining]\nend function\n\nfunction swap count [number] funcName [id]\n    replace [nested_identifier]\n        root [nestable_value] rep [repeat attribute_access]\n    construct before [repeat attribute_access]\n        rep [head count]\n    construct countWithSkip [number]\n        count [+ 2]\n    construct after [repeat attribute_access]\n        rep [tail countWithSkip]\n    by\n        funcName '( root before ') after\nend function\n\nrule containsAttributeAccess seeking [attribute_access]\n    match [attribute_access]\n        seeking\nend rule\n\n\n\n\n%--------------------------------%\n%  Generic Before/after search   %\n%--------------------------------%\n\ndefine sequence_any\n    [repeat any]\nend define\n\nfunction getBeforeAfter seeking [any] rep [repeat any]\n    replace [repeat sequence_any]\n    where \n        rep [containsGeneric seeking]\n    deconstruct rep\n        repAny [repeat any]\n    construct zero [number]\n        '0 \n    construct index [number]\n        zero [getIndex seeking repAny]\n    by \n        _ [createBeforeAfter index repAny]\nend function\n\nfunction createBeforeAfter index [number] rep [repeat any]\n    replace [repeat sequence_any]\n        empty [repeat sequence_any]\n    construct beforeIndex [number]\n        index\n    construct before [sequence_any]\n        rep [head beforeIndex]\n    construct countWithSkip [number]\n        index [+ 2]\n    construct after [sequence_any]\n        rep [tail countWithSkip]\n    by\n        empty [. before] [. after]\nend function\n\nfunction getIndex  seeking [any] rep [repeat any]\n    replace [number]\n        index [number]\n    construct repLength [number]\n        _ [length rep]\n    construct head [repeat any]\n        rep [head 1]\n    where \n        repLength [> 0]\n    construct remaining [repeat any]\n        rep [tail 2]\n    where not\n        head [containsGeneric seeking] \n    by\n        index [+ 1] [getIndex seeking remaining]\nend function\n\nrule containsGeneric seeking [any]\n    match [any]\n        seeking\nend rule"},
{ "txl/umpleJavaToPython.txl", "include \"Python.Grm\"\ninclude \"BooleanTranslation.txl\"\ninclude \"ImportProcessing.txl\"\ninclude \"ListTranslation.txl\"\ninclude \"MethodTranslation.txl\"\ninclude \"StatementTranslation.txl\"\ninclude \"EnumTranslation.txl\"\ninclude \"ClassTranslation.txl\"\n\n%--------------------%\n%     Top level      %\n%--------------------%\n\nfunction main\n    replace [program] \n\t _[repeat package_statement] \n     Imports [repeat import_statement]\n     classes [repeat class_declaration]\n    export Imports\n    by\n\tclasses\n        [replaceConcreteClassesWithInheritance] \n        [replaceInterfacesWithInheritance]\nend function\n\n"},
};

    boolean regenerateFiles = false;

    try {
        //Look for TXL folder
        Path tempDir = Paths.get("txl");

        if (Files.exists(tempDir)) {

            //Check last update time
            Path tempVersion = Paths.get(versionPath);
            if (Files.exists(tempVersion)) {
                File versionFile = new File(versionPath);
                Scanner myReader = new Scanner(versionFile);

                if (myReader.hasNextLine()) {
                  String version = myReader.nextLine();

                    if (!version.equals(Integer.toString(TXL_VERSION))) {
                        regenerateFiles = true;
                    }
                } else {
                	regenerateFiles = true;
                }

                myReader.close();
            } else {
				      regenerateFiles = true;
            }

            // If version number is valid, verify file integrity
            if (!regenerateFiles) {

                Path filePath;

            	for (int i = 0; i < filesData.length; i++) {
            	  filePath = Paths.get(filesData[i][0]);
            	  regenerateFiles = !Files.exists(filePath);
            	}
            }

        } else {
            regenerateFiles = true;
        }
    } catch (Exception e) {
        throw new UmpleCompilerException("An error occured while verifying the integrity of the Txl files.", e);
    }

    if (regenerateFiles) {

		File txlFolder = new File("txl");
	    txlFolder.mkdirs();

	    //Write TXL Version File
	    BufferedWriter bw = new BufferedWriter(new FileWriter(versionPath));
	    try {
	      bw.write(versionContent);
	      bw.flush();
	    }
	    catch (Exception e) {
	      throw new UmpleCompilerException("An error occured while generating the TXL-Version.txt file.", e);
	    }
	    finally {
	      bw.close();
	    }

	    //Write all other TXL files
	    for (int i = 0; i < filesData.length; i++) {
		    bw = new BufferedWriter(new FileWriter(filesData[i][0]));
		    try {
		      bw.write(filesData[i][1]);
		      bw.flush();
		    }
		    catch (Exception e) {
		      throw new UmpleCompilerException("An error occured while generating the " + filesData[i][0] + " file.", e);
		    }
		    finally {
		      bw.close();
		    }
	    }
	}

  }

}
