/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

This file generates state tables for all state machines in the current system.

A state-state table shows from-states in rows and to-states in columns, with
the cells showing all events that can make that transition. Empty cells indicate
no direct way to get from one state to another.

A state-event table shows from-states in rows and events in columns, with the
cells showing the resulting to-state.

Command line action for this is
  -g StateTables

 */
namespace cruise.umple.compiler;


class StateTablesGenerator
{
  isA CodeGeneratorWithSubptions;
  depend java.io.*;
  depend java.util.*;
  depend cruise.umple.util.*;
  depend cruise.umple.compiler.exceptions.*;

  // Contains various aspects from an Umple file (.ump), such as classes, attributes, associations and methods.  Generated output is based
  // off of what's contained in here.
  UmpleModel model = null;
  String output = "";
}



//Container containing multiple concurrent states.
class CompositeStateWrapper
{//cswCheckpoint
	depend java.util.Map;
	depend java.util.HashMap;
	depend java.util.ArrayList;
	Map<String,State> states = new HashMap<String,State>();
	//Map<State,ArrayList<CompositeStateWrapper>> compositeStateWrapperMap = new HashMap<State,ArrayList<CompositeStateWrapper>>();
	boolean hasChildStates = false;
	boolean displayPrimacy = false; //TODO implement this system. it will be necessary for creating the state tables.
	CompositeStateWrapper parentCsw = null;
	Map<String,CompositeStateWrapper> childStates = new HashMap<String,CompositeStateWrapper>();
	Map<String,Boolean> isPrimaryMap = new HashMap<String,Boolean>();
	String guardString = "";
	//Returns copy of CompositeStateWrapper
	CompositeStateWrapper getCopy()
	{
		CompositeStateWrapper csw = new CompositeStateWrapper();
		ArrayList<State> stateList = new ArrayList<State>(states.values());
		for(State s : stateList)
		{
			csw.addState(s);
			CompositeStateWrapper childCsw = childStates.get(s.getName());
			if(childCsw != null)
			{
				csw.addChildState(s.getName(), childCsw.getCopy());
			}
		}
		return csw;
	}	
	//Returns true if CSW contains state (including child states)
	boolean containsState(String stateName)
	{
		State state = states.get(stateName);
		if(state != null)
		{
			return true;
		}
		ArrayList<CompositeStateWrapper> childStateList = new ArrayList<CompositeStateWrapper>(childStates.values());
		for(CompositeStateWrapper csw : childStateList)
		{
			if(csw.containsState(stateName))
			{
				return true;
			}
		}
		return false;
	}
	
	
	//Returns true if Transition t would lead to CompositeStateWrapper nextCsw
	boolean isTransition(CompositeStateWrapper nextCsw, Transition t)
	{
		String fromState = t.getFromState().getName();
		String nextState = t.getNextState().getName();
		//String tName = t.getEvent().getName();//may delete
		/*
		System.out.println("Validating...");
		System.out.println("fromState: " + fromState);
		System.out.println("nextState: " + nextState);
		System.out.println("fromCsw: " + getCompositeName());
		System.out.println("nextCsw: " + nextCsw.getCompositeName());
		*/
		if(!containsState(fromState))//This CSW isn't a valid fromState
		{
			return false;
		}
		if(!nextCsw.containsState(nextState))//Next csw doesn't contain a valid nextState
		{
			return false;
		}
		//We have deduced that the fromCsw contains the fromState and the nextCsw contains the nextState
		ArrayList<State> fromStateList = new ArrayList<State>(states.values());
		Map<String,State> nextCswStateMap = nextCsw.getStates();
		for(State s : fromStateList)
		{
			String sName = s.getName();
			if(!nextCswStateMap.containsKey(sName))//key not detected, investigate if transition
			{
				if(sName != fromState)
				{
					return false;
				}
			}
		}
		//We have now deduced that all states in fromCsw are equal to nextCsw 
		ArrayList<CompositeStateWrapper> fromChildCswList = new ArrayList<CompositeStateWrapper>(childStates.values());
		ArrayList<String> fromChildCswKeyList = new ArrayList<String>(childStates.keySet());
		Map<String,CompositeStateWrapper> fromChildStateMap = childStates;//Just doing this to keep track of it, may change it later
		Map<String,CompositeStateWrapper> nextChildStateMap = nextCsw.getChildStates();
		for(String fromChildCswKey : fromChildCswKeyList)
		{
			CompositeStateWrapper fromChildCsw = fromChildStateMap.get(fromChildCswKey);
			CompositeStateWrapper nextChildCsw = nextChildStateMap.get(fromChildCswKey);
			
			if(nextChildCsw == null && fromChildCswKey == fromState && nextCswStateMap.containsKey(nextState))
			{
				continue; //detected transition in this CSW, skip checking here.
			}
			boolean fromChildContainsState = false;
			if(fromChildCsw != null)
			{
				fromChildContainsState = fromChildCsw.containsState(fromState);
			}
			boolean nextChildContainsState = false;
			if(nextChildCsw != null)
			{
				nextChildContainsState = nextChildCsw.containsState(nextState);
			}
			//case 1, both child states don't contain transition related states, check equality and move on.
			if(!fromChildContainsState && !nextChildContainsState)
			{
				if(!fromChildCsw.checkEquality(nextChildCsw))
				{
					return false;
				}
			}
			//case 2, both child states contain transition, check recursively
			if(fromChildContainsState && nextChildContainsState)
			{
				if(!fromChildCsw.isTransition(nextChildCsw,t))
				{
					return false;
				}
			}
			//TODO case 3 and 4 occur when the transition is between concurrent branches.
			if(!fromChildContainsState && nextChildContainsState)
			{
				return false;				
				//TODO
			}
			if(fromChildContainsState && !nextChildContainsState)
			{
				return false;				
				//TODO
			}
		}
		
		return true;
	}
	
	
	
	//Checks if two CompositeStateWrappers have the same states.
	boolean checkEquality(CompositeStateWrapper csw)
	{
		if(csw == null)
		{
			return false;
		}
		ArrayList<State> stateList = new ArrayList<State>(csw.getStates().values());
		if(states.size() != stateList.size())
		{
			return false;
		}
		for(State s : stateList)
		{
			String sName = s.getName();
			if(!states.containsKey(sName))
			{
				return false;
			}
			CompositeStateWrapper localChildCsw = childStates.get(s.getName());
			CompositeStateWrapper otherChildCsw = csw.getChildStates().get(s.getName());
			if((localChildCsw == null && otherChildCsw != null) || (localChildCsw != null && otherChildCsw == null))
			{
				return false;
			}
			if(localChildCsw != null)
			{
				if(!localChildCsw.checkEquality(otherChildCsw))
				{
					return false;
				}
			}
		}
		return true;
	}
	//Adds state to composite state
	void addState(State s)
	{
		String stateName = s.getName();
		if(states.get(stateName) == null)
		{
			states.put(stateName,s);
		}
	}
	
	void addChildState(String stateName, CompositeStateWrapper csw)
	{
		if(childStates.get(stateName) == null)
		{
			childStates.put(stateName,csw);
		}
	}
	
	//traverses through the CSW's tree structure and tries to add state.
	//Returns true if successfully added.
	boolean addRecursiveChildState(String parent, State state)
	{
		//first, check if this CSW already contains child CSW associated with parent
		CompositeStateWrapper csw = childStates.get(parent);
		if(csw != null)
		{
			csw.addState(state);
			return true;
		}
		//next, check if CSW contains parent state but simply has not yet instantiated childCSW
		if(states.get(parent) != null)
		{
			CompositeStateWrapper newCsw = new CompositeStateWrapper();
			newCsw.addState(state);
			addChildState(parent,newCsw);
			return true;
		}
		//parent state not contained at this level.
		//now we need to recursively check each child CSW.
		ArrayList<CompositeStateWrapper> childCswList = new ArrayList<CompositeStateWrapper>(childStates.values());
		for(CompositeStateWrapper childCsw : childCswList)
		{
			if(childCsw.addRecursiveChildState(parent,state))
			{
				return true;
			}
		}
		//parent state not found, returning false.
		return false;
			}	
	//Sets corresponding boolean value in isPrimaryMap to given boolean
	void setStatePrimacy(String sName, boolean primacy)
	{
		isPrimaryMap.put(sName,primacy);
	}
	//Prints the name of the composite state.
	//name is a conjunction of state names within the composite state.
	String getCompositeName()
	{
		ArrayList<State> values = new ArrayList<State>(states.values());
		if(values.size() < 1)
		{
			return null;
		}
		String compositeName = values.get(0).getName();
		if(displayPrimacy)
		{
			if(isPrimaryMap.containsKey(values.get(0).getName()))//since we're storing booleans, we want to check if this value is mapped to avoid null pointers.
			{
				if(isPrimaryMap.get(values.get(0).getName()))
				{
					compositeName = compositeName + "-PRIMARY ";
				}
			}
		}
		CompositeStateWrapper firstChildCsw = childStates.get(values.get(0).getName());
		if(firstChildCsw != null)
		{
			compositeName = compositeName + " (" + firstChildCsw.getCompositeName() + ")";
		}
		for(int i = 1; i < values.size(); i++)
		{
			State s = values.get(i);
			compositeName = compositeName + " || " + s.getName();
			if(displayPrimacy)
			{
				if(isPrimaryMap.containsKey(s.getName()))
				{
					if(isPrimaryMap.get(s.getName()))
					{
						compositeName = compositeName + "-PRIMARY ";
					}					
				}
			}
			CompositeStateWrapper childCsw = childStates.get(s.getName());
			if(childCsw != null)
			{
				compositeName = compositeName + " (" + childCsw.getCompositeName() + ") ";
			}
		}
		return compositeName;
	}
	
	//sets displayPrimacy to given boolean for CSW and all child CSWs.
	void displayPrimacy(boolean dp)
	{
		displayPrimacy = dp;
		ArrayList<CompositeStateWrapper> childCswList = new ArrayList<CompositeStateWrapper>(childStates.values());
		for(CompositeStateWrapper childCsw : childCswList)
		{
			childCsw.displayPrimacy(dp);
		}
	}
}

//Container containing multiple transitions of the same name
class CompositeTransitionWrapper
{//ctwcheckpoint
	depend java.util.ArrayList;
	String tName;
	ArrayList<Transition> transitionList = new ArrayList<Transition>();
	boolean containsGuard = false;
	//HashMap<Transition,String> guardStringMap = new ArrayList<Transition
	//adds transition to list, returns true if succesfully added, returns false if not added.
	public boolean addTransition(Transition t)
	{
		if(extractGuardString(t) != null)
		{
			containsGuard = true;
		}
		if(t.getEvent().getName() != tName)
		{
			return false;
		}
		transitionList.add(t);
		return true;
	}
	
	private String extractGuardString(Transition t)
	{
		if(t == null)
		{
			return null;
		}
		JavaGenerator gen = new JavaGenerator();
		Guard guard = t.getGuard();
		String guardString = null;
		String eventName = t.getEvent().getName();
		if(guard != null)
		{
			guardString = extractGuardStringRecursive(guard,t.getFromState(),t.getEvent());
			System.out.println("Guard: " + guardString);
		}
		return guardString;
	}
	
	//extracts guard string.
	private String extractGuardStringRecursive(Guard guard, State curState, Event event)
	{
		JavaGenerator gen = new JavaGenerator();
		UmpleClass umpClass = curState.getStateMachine().getUmpleClass();
		if(umpClass == null)
		{
			return extractGuardStringRecursive(guard,
											  curState.getStateMachine().getParentState(),
											  event);
		}
		else 
		{
			gen.setModel(umpClass.getSourceModel());
			return guard.getCondition(gen).replaceAll("\"","&quote;");
		}
	}
	
}

class CompositeStateTableRow
{
	depend java.util.ArrayList;
	depend java.util.Map;
	depend java.util.HashMap;
	CompositeStateWrapper fromCsw;
	String cswName;//composite name
	
	isPseudo=false;//TODO implement H or H* support.
	
	private CompositeStateWrapper findNextCsw(ArrayList<CompositeStateWrapper> cswList, ArrayList<Transition> transitionList)
	{
		for(CompositeStateWrapper nextCsw : cswList)
		{
			for(Transition t : transitionList)
			{
				String fromState = t.getFromState().getName();
				if(fromCsw.isTransition(nextCsw,t))
				{
					return nextCsw;
				}
			}
		}
		return null;
	}	
	
	private Transition findTransition(CompositeStateWrapper nextCsw, ArrayList<CompositeTransitionWrapper> ctwList)
	{
		for(CompositeTransitionWrapper ctw : ctwList)
		{
			ArrayList<Transition> transitionList = ctw.getTransitionList();
			for(Transition t : transitionList)
			{
				if(fromCsw.isTransition(nextCsw,t))
				{
					return t;
				}
			}
		}
		return null;
	}

	private StringBuilder cswToHtmlString(CompositeStateWrapper csw)
	{
		StringBuilder sb = new StringBuilder();
		sb.append("<span");
		
		//TODO derived and action support
		
		sb.append(">");
		
		//TODO guard support
		
		sb.append(csw.getCompositeName());
		sb.append("</span>");
		return(sb);	
	}	
	
	private StringBuilder transitionToHtmlString(Transition t)
	{//compositestatestatecellcheckpoint
		StringBuilder sb = new StringBuilder();
		Event event = t.getEvent();
		String eventName = event.getName();
		
		if(event.isAutoTransition())
		{
			eventName="(auto)";
		}
		if(event.getIsTimer())
		{
			eventName="after(" + event.getTimerInSeconds() + ")";
		}
		String guardString = extractGuardString(t);
		if(guardString != null)
		{
			eventName = eventName + " [" + guardString + "]";
		}
		sb.append("<span");
		sb.append(">");
		sb.append(eventName);
		//TODO add guard support
		sb.append("</span>");
		return(sb);
	}
	
	private HashMap<String,Boolean> getTimerCellCheckedMap(HashMap<String,ArrayList<String>> timerTransitionMap)
	{
		HashMap<String,Boolean> timerCellCheckedMap = new HashMap<String,Boolean>();
		
		for(String eventHeader : timerTransitionMap.keySet())
		{			
			timerCellCheckedMap.put(eventHeader,false);
		}
		return timerCellCheckedMap;
	}	
	
	private String extractGuardString(Transition t)
	{
		if(t == null)
		{
			return null;
		}
		JavaGenerator gen = new JavaGenerator();
		Guard guard = t.getGuard();
		String guardString = null;
		String eventName = t.getEvent().getName();
		if(guard != null)
		{
			guardString = extractGuardStringRecursive(guard,t.getFromState(),t.getEvent());
			System.out.println("Guard: " + guardString);
		}
		return guardString;
	}
	
	//extracts guard string.
	private String extractGuardStringRecursive(Guard guard, State curState, Event event)
	{
		JavaGenerator gen = new JavaGenerator();
		UmpleClass umpClass = curState.getStateMachine().getUmpleClass();
		if(umpClass == null)
		{
			return extractGuardStringRecursive(guard,
											  curState.getStateMachine().getParentState(),
											  event);
		}
		else 
		{
			gen.setModel(umpClass.getSourceModel());
			return guard.getCondition(gen).replaceAll("\"","&quote;");
		}
	}
	
	public StringBuilder stateEventTableRowHtml(ArrayList<String> eventList,
	                                            HashMap<String,CompositeTransitionWrapper> ctwMap,
	                                            ArrayList<CompositeStateWrapper> cswList,
	                                            ArrayList<String> autoTransitionNameList,
	                                            HashMap<String,ArrayList<String>> timerTransitionMap,
	                                            HashMap<String,String> timerAssociationMap
	                                            )
	{//stateeventrowcheckpoint
		System.out.println("TimerTransitionMap size: " + timerTransitionMap.size());
		StringBuilder sb = new StringBuilder();
		boolean autoCellChecked = false;
		firstCellInRow(sb);
		HashMap<String,Boolean> timerCellCheckedMap = getTimerCellCheckedMap(timerTransitionMap);
		for(String eventName : eventList)//loop through event columns
		{
			System.out.println("Event: " + eventName);
			if(autoTransitionNameList.contains(eventName) && !autoCellChecked)//autoTransition detected, check 
			{
				CompositeStateWrapper autoNextCsw = null;
				for(String autoTransitionName : autoTransitionNameList)
				{
					ArrayList<Transition> autoTransitionList = ctwMap.get(autoTransitionName).getTransitionList();
					autoNextCsw = findNextCsw(cswList,autoTransitionList);
					if(autoNextCsw != null)
					{
						break;//found a valid CSW, exiting loop
					}
				}
				if(autoNextCsw != null)
				{
					sb.append("      <td class=\"event-entry\">");
					sb.append(cswToHtmlString(autoNextCsw));
					sb.append("</td>");
				}
				else 
				{
					sb.append("      <td class=\"event-entry\">");
					sb.append("&nbsp;");
					sb.append("</td>");
				}
				autoCellChecked = true;
				continue;
			}	
			else if(autoTransitionNameList.contains(eventName) && autoCellChecked)
			{
				continue;
			}
			
			//have to unpack timer check ahead of time to avoid null pointer exception
			//if there is no timer associated with eventName, this boolean wont matter
			boolean timerChecked = false;
			String timerHeader = null;
			if(timerAssociationMap.containsKey(eventName))
			{
				timerHeader = timerAssociationMap.get(eventName);
				timerChecked = timerCellCheckedMap.get(timerHeader);
				System.out.println("Timer: " + eventName + " Checked: " + timerChecked + " Header: " + timerHeader);
				
			}			
			if(timerTransitionMap.containsKey(timerHeader) && !timerChecked)
			{
				CompositeStateWrapper timerNextCsw = null;
				for(String timerTransitionName : timerTransitionMap.get(timerHeader))
				{
					ArrayList<Transition> timerTransitionList = ctwMap.get(timerTransitionName).getTransitionList();
					timerNextCsw = findNextCsw(cswList,timerTransitionList);
					if(timerNextCsw != null)
					{
						break;
					}
				}
				if(timerNextCsw != null)
				{
					sb.append("      <td class=\"event-entry\">");
					sb.append(cswToHtmlString(timerNextCsw));
					sb.append("</td>");
				}
				else 
				{
					sb.append("      <td class=\"event-entry\">");
					sb.append("&nbsp;");
					sb.append("</td>");
				}
				timerCellCheckedMap.put(timerHeader,true);
				continue;
			}
			else if(timerTransitionMap.containsKey(timerHeader) && timerChecked)
			{
				continue;
			}
			
			sb.append("      <td class=\"event-entry\">");
			ArrayList<Transition> transitionList = ctwMap.get(eventName).getTransitionList();
			CompositeStateWrapper nextCsw = findNextCsw(cswList,transitionList);
			if(nextCsw != null)//some kind of evaluation where we must find the corresponding csw.
			{
				sb.append(cswToHtmlString(nextCsw));//associated event
			}
			else 
			{
				sb.append("&nbsp;");
			}
			sb.append("</td>");
		}
		return(sb);
	}	
	
	private CompositeTransitionWrapper findCompositeStateWrapper(Transition t, ArrayList<CompositeTransitionWrapper> ctwList)
	{
		if(t == null)
		{
			return null;
		}
		String eventName = t.getEvent().getName();
		for(CompositeTransitionWrapper ctw : ctwList)
		{
			if(ctw.getTName() == eventName)
			{
				return ctw;
			}
		}
		return null;
	}	
	
	public StringBuilder stateStateTableRowHtml(HashMap<String,CompositeTransitionWrapper> ctwMap, ArrayList<CompositeStateWrapper> cswList)
	{//statestaterowcheckpoint
		StringBuilder sb = new StringBuilder();
		firstCellInRow(sb);
		ArrayList<CompositeTransitionWrapper> ctwList = new ArrayList<CompositeTransitionWrapper>(ctwMap.values());
		ArrayList<String> transitionHasOccuredList = new ArrayList<String>();
		for(CompositeStateWrapper nextCsw : cswList)
		{
			sb.append("      <td class=\"state-entry\">");
			Transition t = findTransition(nextCsw,ctwList);
			
			
			String eventName = null;
			//Guard guard = null;
			boolean hasGuard = false;
			if(t != null)
			{
				eventName = t.getEvent().getName();
				Guard guard = t.getGuard();
				if(guard != null )
			   {
					System.out.println(eventName + " contains guard");
			   }
			   CompositeTransitionWrapper ctw = findCompositeStateWrapper(t,ctwList);
			   hasGuard = ctw.getContainsGuard();
			}
			
			
			/*
			String guardString = extractGuardString(t);
			if(guardString != null)
			{
				eventName = eventName + " [" + guardString + "]";
			}
			*/
			
			if((t != null && !transitionHasOccuredList.contains(eventName)) || hasGuard)
			{
				sb.append(transitionToHtmlString(t));
				transitionHasOccuredList.add(eventName);
			}
			else 
			{
				sb.append("&nbsp;");
			}
			sb.append("</td>");
		}
		
		return(sb);
	}
	
	private StringBuilder firstCellInRow(StringBuilder sb)
	{
		sb.append("      <td class=\"state-header\" data-parent=\"");
		sb.append("\">");
		sb.append(fromCsw.getCompositeName());
		sb.append("</td>\n");
		return(sb);
	}
}
// Row in a state-state table and state-event table
// Also iterated through as columns in a state-state-table
class StateTableRow 
{
  depend java.util.Map;
  depend java.util.HashMap;

  State uState; // The state for this row (or column)
  String sLabel;  // The label to be used for the state
  Integer nestingLevel;  // Higher number means it is a substate
  StateTableRow parent; // null if not nested
  Integer tableRowId; // The unique id of this row

  isPseudo=false; // H or H* Can never actually be in this so skipped as a row
  Map<String,StateTableCell> stateEventCells = new HashMap<String,StateTableCell>();
  Map<State,StateTableCell> stateStateCells = new HashMap<State,StateTableCell>();

  // Add cells for the entire row of transitions
  public void build() 
  {  
    boolean isDerived = false;
    StateTableRow curRow = this;
    State curState;

    //Loops through this row and its parents to find transitions
    while(curRow != null) 
    {
      curState = curRow.getUState();
      extractTransitions(curState, isDerived);
      curRow = curRow.getParent();
      isDerived = true;
    }
    
  }  // End of build() method

  // Output this row of the stateEvent Table (not including tr tags
  public StringBuilder stateEventTableRowHtml() 
  {
    StringBuilder sb = new StringBuilder();

    // Output the name of the state with appropriate nesting
    firstCellInRow(sb);

    // Loop through all events, find the event in the hash table, and output each cell

    for(String ev : getStateTable().getAllEvents()) 
    {
      sb.append("      <td class=\"event-entry\">");
      if(stateEventCells.containsKey(ev)) 
      {
        sb.append(stateEventCells.get(ev).htmlString());
      }
      else 
      {
        sb.append("&nbsp;");
      }
      sb.append("</td>\n");
    }
    return(sb);
  }

  // Output this row of the stateState Table not including tr tags
  public StringBuilder stateStateTableRowHtml() 
  {
    StringBuilder sb = new StringBuilder();

    // Output the name of the state with appropriate nesting
    firstCellInRow(sb);

    // Loop through all states, find the state in the hash table, and output each cell
    for(StateTableRow col : getStateTable().getRows()) 
    {
      State colState = col.getUState();
      sb.append("      <td class=\"state-entry\">");

      if(stateStateCells.containsKey(colState)) 
      {
        sb.append(stateStateCells.get(colState).htmlString());
      }
      else 
      {
        sb.append("&nbsp;");
      }
      sb.append("</td>\n");
    }
    return(sb);
  }

  //Loops through the transitions in a state and adds them to a list
  private void extractTransitions(State curState, boolean isDerived) 
  {
    Event event;
    Action action;
    String transitionLabel = "?";
    String eventLabel = "??";
    String guardString, actionCode, transitionAction;
    Guard guard;

    // Add cells for each transition
    for (Transition t : curState.getTransitions()) 
    {
      event = t.getEvent();
      action = t.getAction();

      if(event.isAutoTransition()) 
      {
        transitionLabel = "";
        eventLabel = "(auto)";
      }
      else 
      {
        if (event.getIsTimer()) 
        {
          transitionLabel = "after(" + event.getTimerInSeconds() + ")";
          eventLabel=transitionLabel;
        }
        else 
        {
          eventLabel = event.getName();
          if(event.getArgs() == null || event.getArgs() == "") 
          {
            transitionLabel = eventLabel;
          }
          else 
          {
            transitionLabel = eventLabel + "(" + event.getArgs() + ")";
          }
        }
      }

      if (action == null || action.getActionCode() == "") 
      {
        transitionAction = "";
      }
      else 
      {
        actionCode = action.getActionCode();
        transitionAction = "/ " + actionCode.replaceAll("\"","&quot;");
      }

      guard = t.getGuard();
      if (guard == null) guardString = "";
      else 
      {
        guardString = extractGuardString(guard, curState, event, this);
      }
      // Add state to the state event list in hash table
      addStateEventCell(eventLabel, t, guardString, transitionAction, isDerived);

      // Add event to the state state list in hash table
      addStateStateCell(eventLabel, t, guardString, transitionAction, isDerived);

    } // End of loop through each transition
  }

  private void addStateEventCell(String label, Transition t, String guard, 
    String action, boolean isDerived) {

    if(stateEventCells.get(label) == null) 
    {
      stateEventCells.put(label, new StateTableCell());
    }

    stateEventCells.get(label).addStateTableEntry(
      new StateEventEntry(t.getNextState(), guard, action, isDerived));
  }

  private void addStateStateCell(String label, Transition t, String guard, 
    String action, boolean isDerived) {

    if(stateStateCells.get(t.getNextState()) == null) 
    {
      stateStateCells.put(t.getNextState(), new StateTableCell());
    }

    stateStateCells.get(t.getNextState()).addStateTableEntry(
      new StateStateEntry(label, guard, action, isDerived));
  }

  // Output the first cell in the row of the table, i.e. the state name with indentation
  private StringBuilder firstCellInRow(StringBuilder sb) 
  {
    sb.append("      <td class=\"state-header\" data-parent=\"");

    if(this.parent != null) 
    {
      sb.append(String.valueOf(this.parent.getTableRowId()));
    }

    sb.append("\">");

    for(int i=0; i<nestingLevel; i++) 
    {
      sb.append("- ");
    }
    sb.append(sLabel);
    sb.append("</td>\n");
    return(sb);
  }

  private String extractGuardString(Guard guard, 
                                    State curState, 
                                    Event event, 
                                    StateTableRow curRow)
  {
    JavaGenerator gen = new JavaGenerator();
    UmpleClass umpClass = curState.getStateMachine().getUmpleClass();
    
    if(umpClass == null) 
    {
      return extractGuardString(
        guard, curRow.getParent().getUState(), event, curRow.getParent());
    }
    else 
    {
      gen.setModel(umpClass.getSourceModel());
      return guard.getCondition(gen).replaceAll("\"","&quot;");
    }
  }
}

// Cell in a state table containing the resulting state or the event that results in transition
class StateTableCell 
{
  1 -> * StateTableEntry;
  
  public StringBuilder htmlString()
  {
    StringBuilder sb = new StringBuilder();
    boolean isFirst = true;
    for(StateTableEntry entry : getStateTableEntries())
    {
      if(isFirst)
      {
        isFirst = false;
        sb.append(entry.htmlString());
      } 
      else
      {
        sb.append("<br>");
        sb.append(entry.htmlString());
      }
    }

    return sb;
  }
}

//Interface for each individual entry within a cell
interface StateTableEntry
{
  public StringBuilder htmlString();
}

//Cell entries for state-event tables
class StateEventEntry
{
  isA StateTableEntry;
  State uState;
  String guard;
  String action;
  boolean isDerived;

  // Output this state cell as html - appears in state-event table
  public StringBuilder htmlString() 
  {
    StringBuilder sb = new StringBuilder();
    sb.append("<span");
    if(isDerived) sb.append(" class=\"derived\"");

    if(action != null && !action.equals("")) {
      sb.append(" data-action=\"");
      sb.append(action);
      sb.append("\"");
    }

    sb.append(">");

    if(guard != null && !guard.equals(""))
    {
      sb.append("[");
      sb.append(guard);
      sb.append("] ");
    }

    sb.append(uState.getName());
    sb.append("</span>");
    return(sb);
  }
}

//Cell entries for state-state tables
class StateStateEntry
{
  isA StateTableEntry;
  String label;
  String guard;
  String action;
  boolean isDerived;

  // Output this state cell as html - appears in state-state table
  public StringBuilder htmlString() 
  {
    StringBuilder sb = new StringBuilder();
    sb.append("<span");
    if(isDerived) sb.append(" class=\"derived\"");
    sb.append(">");
    sb.append(label);

    if(guard != null && !guard.equals(""))
    {
      sb.append(" [");
      sb.append(guard);
      sb.append("]");
    }

    sb.append("</span>");
    return(sb);
  }
}

class StateTable 
{
	depend java.util.ArrayList;
	depend java.util.Map;
	depend java.util.HashMap;
  UmpleClass uClass;
  StateMachine sm;
  List<String> allEvents = null; // will be populated by call to buildAllEvents
  1 -- * StateTableRow rows;  // Rows to be output for each state
  //will likely have to change this one so it conforms to umple standards.
  ArrayList<CompositeStateWrapper> primaryCswList = new ArrayList<CompositeStateWrapper>();
  ArrayList<Transition> transitionList = new ArrayList<Transition>();
  HashMap<String,CompositeTransitionWrapper> ctwMap = new HashMap<String,CompositeTransitionWrapper>(); 
  // Outputs the Event State table - with states as cells
  public StringBuilder stateEventTableHtml(StringBuilder sb) 
  {
    sb.append("<div class=\"statetable-container\">\n");
    sb.append("  <table class=\"statetable event-statetable\">\n");

    // Output row headers - blank cell + list of events
    sb.append("    <tr>\n      <td class=\"event-header\">&nbsp;</td>\n");
    for(String e : allEvents) 
    {
      sb.append("      <td class=\"event-header\">");
      sb.append(e);
      sb.append("</td>\n");
    }
    sb.append("    </tr>\n\n");

    // Output each row
    for(StateTableRow row : rows) 
    {
      sb.append("    <tr>\n");
      sb.append(row.stateEventTableRowHtml());
      sb.append("    </tr>\n\n");
    }

    sb.append("  </table>\n");
    sb.append("</div>\n\n");
    return(sb);
  }
  
  //gets formatted event header from ctwMap based on given key
  private String getFormattedEventHeader(String eventKey)
  {
  	CompositeTransitionWrapper ctw = ctwMap.get(eventKey);
  	if(ctw.getTransitionList().size() == 0)
  	{
  		return "ERROR: CompositeTransitionWrapper missing transitions!";
  	}
  	Transition t = ctw.getTransitionList().get(0);
  	Event event = t.getEvent();
  	if(event.isAutoTransition()) 
   {
      return "(auto)";
   }
   if(event.getIsTimer())
   {
   	return "after(" + event.getTimerInSeconds() + ")";
   }
   
   
   return event.getName();
  	
  }
  
  public StringBuilder compositeStateEventTableHtml(StringBuilder sb)
  {//stateeventtopcheckpoint
  	ArrayList<String> eventList = new ArrayList<String>(ctwMap.keySet());
  	ArrayList<String> autoTransitionList = new ArrayList<String>();
  	HashMap<String,ArrayList<String>> timerTransitionMap = new HashMap<String,ArrayList<String>>();
  	HashMap<String,String> timerAssociationMap = new HashMap<String,String>();
  	boolean autoEventCreated = false;
  	//HashMap<String,Boolean> timerEventCreatedMap = new HashMap<String,Boolean>();
  	sb.append("<div class=\"statetable-container\">\n");
  	sb.append("  <table class=\"statetable event-statetable\">\n");
  	
  	sb.append("    <tr>\n      <td class=\"event-header\">&nbsp;</td>\n");
  	for(String e : eventList)
  	{
  		String eventName = getFormattedEventHeader(e);
  		CompositeTransitionWrapper ctw = ctwMap.get(e);
  		Transition t = ctw.getTransitionList().get(0);
  		if(t == null)
  		{
  			System.out.println("ERROR: Event " + e + " points to null CompositeStateWrapper.");
  		}
  		if(eventName == "(auto)" && !autoEventCreated)
  		{
			autoTransitionList.add(e);  			
  			autoEventCreated = true;
  		}
  		else if(eventName == "(auto)" && autoEventCreated)
  		{
  			autoTransitionList.add(e);
  			continue;//skip column, auto already created
  		}
  		
  		//boolean timerChecked = false;
  		//if(timerEventCreatedMap.containsKey()
  		if(t.getEvent().getIsTimer())
  		{
  			if(timerTransitionMap.containsKey(eventName))
  			{
  				timerTransitionMap.get(eventName).add(e);
  				timerAssociationMap.put(e,eventName);
  				continue;
  			}
  			else 
  			{
  				ArrayList<String> timerEventNameList = new ArrayList<String>();
  				timerEventNameList.add(e);
  				timerTransitionMap.put(eventName,timerEventNameList);
  				timerAssociationMap.put(e,eventName);
  			}
  		}
  		sb.append("      <td class=\"event-header\">");
  		sb.append(eventName);
  		sb.append("</td>\n");
  		
  	}
  	sb.append("    </tr>\n");
  	for(CompositeStateWrapper csw : primaryCswList)
  	{
  		CompositeStateTableRow cstRow = new CompositeStateTableRow(csw,csw.getCompositeName());
  		sb.append("    <tr>\n");
  		sb.append(cstRow.stateEventTableRowHtml(eventList,
  		                                        ctwMap,
  		                                        primaryCswList,
  		                                        autoTransitionList,
  		                                        timerTransitionMap,
  		                                        timerAssociationMap));//may need to change args
  		sb.append("    </tr>\n\n");
  	}
  	
  	sb.append("  </table>\n");
  	sb.append("</div>\n\n");
  	return(sb);
  	
  }
  // Outputs the State State table - with events as cells
  public StringBuilder stateStateTableHtml(StringBuilder sb) 
  {
    sb.append("<div class=\"statetable-container\">\n");
    sb.append("  <table class=\"statetable state-statetable\">\n");

    // Output row headers - blank cell + list of states (same as rows)
    sb.append("    <tr>\n      <td class=\"state-header\">&nbsp;</td>\n");
    for(StateTableRow col : rows) {
      String stateName = col.getSLabel();
      sb.append("      <td class=\"state-header\">");
      sb.append(stateName);
      sb.append("</td>\n");
    }
    sb.append("    </tr>\n\n");

    // Output each row
    for(StateTableRow row : rows) 
    {
      sb.append("    <tr>\n");
      sb.append(row.stateStateTableRowHtml());
      sb.append("    </tr>\n\n");
    }

    sb.append("  </table>\n");
    sb.append("</div>\n\n");
    return(sb);
  }
  
  public StringBuilder compositeStateStateTableHtml(StringBuilder sb)
  {
  	 sb.append("<div class=\"statetable-container\">\n");
    sb.append("  <table class=\"statetable state-statetable\">\n");
    
    sb.append("    <tr>\n      <td class=\"state-header\">&nbsp;</td>\n");
    for(CompositeStateWrapper csw : primaryCswList)
    {
    	String compositeStateName = csw.getCompositeName();
    	sb.append("      <td class=\"state-header\">");
    	sb.append(compositeStateName);
    	sb.append("</td>\n");
    }
    sb.append("    </tr>\n\n");
    
    for(CompositeStateWrapper csw : primaryCswList)
    {
    	CompositeStateTableRow cstRow = new CompositeStateTableRow(csw,csw.getCompositeName());
    	sb.append("    <tr>\n");
    	sb.append(cstRow.stateStateTableRowHtml(ctwMap,primaryCswList));
    	sb.append("    </tr>\n\n");
    }
    
    sb.append("  </table>\n");
    sb.append("</div>\n\n");
    return(sb);
  }

  // Builds the columns after the rest of the tables are made
  public void buildAllEvents() 
  {
    HashSet<String> eventSet = new HashSet<String>();
    for (StateTableRow row : rows) 
    {
      eventSet.addAll(row.getStateEventCells().keySet());
    }
    allEvents = new ArrayList<String>(eventSet);

    Collections.sort(allEvents);
  }

  // The first call to the recursive state machine walking
  public void buildRecursivelyEntry(StateMachine theSm) {
    int nestingLevel = 0;
    int currentId = 0;
    buildRecursively(theSm, nestingLevel, currentId, null);
  }
	
	public void addTransitionsToList(State s)
	{
		for(Transition t : s.getTransitions())
		{
			transitionList.add(t);
		}
	}	
	
	public void buildRecursivelyCompositeEntry(StateMachine theSm)
	{
		System.out.println("Call to buildRecursivelyCompositeEntry...");
		int nestingLevel = 0;
		int currentId = 0;
		CompositeStateWrapper csw = new CompositeStateWrapper();
		buildRecursivelyComposite(theSm, nestingLevel, currentId, null);
		System.out.println("Finished recursive build...");
		System.out.println("Size of primaryCswList: " + primaryCswList.size());
		
	}
	
	public int buildRecursivelyComposite(StateMachine theSm,
													 int nestingLevel,
													 int currentId,
													 StateTableRow parent
													 )
	{
		System.out.println("Call to buildRecursivelyComposite...");
		String sLabel;
		StateTableRow stateRow = null;
		String smName, clSmName;
		boolean isPseudo = false;
		ArrayList<CompositeStateWrapper> cswList = new ArrayList<CompositeStateWrapper>();
		
		Boolean isFirstState = true;
		CompositeStateWrapper csw = new CompositeStateWrapper();
		for(State s : theSm.getStates())
		{
			sLabel=s.getName();
			if(sLabel.equals("HStar")) sLabel="H*";
         isPseudo = sLabel.equals("H") || sLabel.equals("H*");
         CompositeStateWrapper compositeStateWrapper = new CompositeStateWrapper();
         compositeStateWrapper.addState(s);
         //compositeStateWrapper.setStatePrimacy(s.getName(),true);
         //compositeStateWrapper.displayPrimacy(true);
         System.out.println(compositeStateWrapper.getCompositeName());
         //adds state to master list
         addTransitionsToList(s);
         //if(s.getIsConcurrent())
         //{
         	cswList.add(compositeStateWrapper);
         //}
         //else
         //{
         //	primaryCswList.add(compositeStateWrapper);
         //}
		   currentId++;
         
         
			for(StateMachine nestedSm : s.getNestedStateMachines())
			{
				
				//if(s.getIsConcurrent())
				//{
					//invoke concurrency version of recursion
					currentId = buildRecursivelyCompositeArray(nestedSm, nestingLevel + 1, currentId, s, cswList);
				//}
				//else 
				//{
					//do normal processing of nested state machine
					currentId = buildRecursivelyComposite(nestedSm, nestingLevel + 1, currentId, stateRow);
				//}
			}
         //if(s.getIsConcurrent())
         //{
         	//process cswList
         	for(CompositeStateWrapper cswConcurrent : cswList)
         	{
         		primaryCswList.add(cswConcurrent);
         		currentId++;
         	}
         	cswList.clear();
         //}
		}
		
		return currentId;
		
		
	}
	
	public int buildRecursivelyCompositeArray(StateMachine theSm,
															int nestingLevel,
															int currentId,
															State parentState,
															ArrayList<CompositeStateWrapper> cswList)
	{
		System.out.println("Call to buildRecursivelyCompositeArray...");
		String sLabel;
		String parent = null;
		if(parentState != null)
		{
			parent = parentState.getName();
		}
		//get all transitions
		for(State s : theSm.getStates())
		{
			addTransitionsToList(s);
		}
		// this list is for nested concurrent states.
		ArrayList<CompositeStateWrapper> nestedCswList = new ArrayList<CompositeStateWrapper>();
		StateTableRow stateRow = null;
		//unpack CSWs from cswList
		ArrayList<CompositeStateWrapper> tempCswList = new ArrayList<CompositeStateWrapper>();
		System.out.println("Unpacking cswList...");
		//unpacks current CSW list and adds it to a temporary list
		for(CompositeStateWrapper csw : cswList) 
		{
			System.out.println("Unpacked csw: " + csw.getCompositeName());
			tempCswList.add(csw);
		}
		System.out.println("Size of tempCswList: " + tempCswList.size());
		//empty cswList so it can be replaced with new composites.
		cswList.clear();
		//for every CSW, create a new CSW for every state and add it back to the cswList
		if(tempCswList.size() == 0)
		{
			System.out.println("No existing CSWs detected, creating new CSWs...");
			for(State s : theSm.getStates())
			{
				CompositeStateWrapper newCsw = new CompositeStateWrapper();
				newCsw.addState(s);
				//newCsw.setStatePrimacy(s.getName(),true);
				//newCsw.displayPrimacy(true);
				System.out.println("New csw name1: " + newCsw.getCompositeName());
				cswList.add(newCsw);
			}
		}
		else
		{
			for(CompositeStateWrapper csw : tempCswList)
			{
				if(parentState == null)
				{
					boolean initialState = true;
					for(State s : theSm.getStates())
					{
						
						//CompositeStateWrapper newCsw = new CompositeStateWrapper(csw,s);
						CompositeStateWrapper newCsw = csw.getCopy();
						newCsw.addState(s);
						//newCsw.setStatePrimacy(s.getName(),initialState);
						//newCsw.displayPrimacy(true);
						System.out.println("New csw name2: " + newCsw.getCompositeName());
						cswList.add(newCsw);
						initialState = false;
					}
				}
				else if(csw.containsState(parent))
				{
					boolean initialState = true;
					for(State s : theSm.getStates())
					{
						CompositeStateWrapper newCsw = csw.getCopy();//we create a copy of the csw
						newCsw.addRecursiveChildState(parent,s);//we add the state to the csw
						//newCsw.setStatePrimacy(s.getName(),initialState);
						//newCsw.displayPrimacy(true);
						System.out.println("New csw name3: " + newCsw.getCompositeName());
						cswList.add(newCsw);
						initialState = false;
					}
				}
				else//not a parent state, add csw back to list.
				{
					cswList.add(csw);
				}
			}
	   }
		
		//now that the composite states for this branch have been created, proceed with rest of build
		for(State s : theSm.getStates())
		{			
			for(StateMachine nestedSm : s.getNestedStateMachines())
			{
				currentId = buildRecursivelyCompositeArray(nestedSm, nestingLevel + 1, currentId, s, cswList);	
			}
		}
		return currentId;
		
	}
	
	public String getTransitionInfo(Transition transition)
	{
		String name;
		name = transition.getFromState().getName();
		name = name + " --(";
		name = name + transition.getEvent().getName();
		name = name + ")--> ";
		name = name + transition.getNextState().getName();
		return name;
	}
	
	public void consolidateTransitions(ArrayList<Transition> transitionList)
	{
		//HashMap<String,CompositeTransitionWrapper> ctwMap = new HashMap<String,CompositeTransitionWrapper>();
		for(Transition t : transitionList)
		{
			String tName = t.getEvent().getName();
			CompositeTransitionWrapper ctw = ctwMap.get(tName);
			if(ctw == null)
			{
				ctw = new CompositeTransitionWrapper(tName);
				ctwMap.put(tName,ctw);
			}
			ctw.addTransition(t);
		}
		//return ctwMap;
	}
  // Walks the state machine adding rows as needed
  public int buildRecursively(StateMachine theSm, 
                              int nestingLevel, 
                              int currentId,
                              StateTableRow parent) 
  {
    String sLabel;
    StateTableRow stateRow = null;
    String smName, clSmName;
    boolean isPseudo = false;

    // We haven't processed any states yet in this statemachine
    Boolean isFirstState = true;

    // Iterate (recursively) through the states of this state machine
    for (State s : theSm.getStates())
    {
      sLabel=s.getName();  // This is what is displayed
      
      if(sLabel.equals("HStar")) sLabel="H*";
      isPseudo = sLabel.equals("H") || sLabel.equals("H*");
	
      // Add a row for this state  - automatically adds to 'rows' as there is an association
      stateRow = new StateTableRow(s, sLabel, nestingLevel, parent, currentId, this);
      stateRow.build();
      currentId++;
		
		
      for (StateMachine nestedSm : s.getNestedStateMachines())
      {
      	currentId = buildRecursively(nestedSm, nestingLevel + 1, currentId, stateRow);
      }

    }  // End iteration through the states, adding rows at this level of nesting

    return currentId;
  }
}


class StateTablesGenerator
{
  StringBuilder code = new StringBuilder();

  // Basic templates
  topHeader <<!
  <style>
    .statetable { border-collapse: collapse; }
    .statetable td { border: 1px solid black; padding: 2px 10px 2px 10px; white-space: nowrap; }
    .statetable .state-header, .statetable .event-header { font-weight: bold; background-color: #ecf0f1; border: 2px solid black; }
    .statetable .derived { font-style: italic; }
    .statetable-container { overflow-x: auto; }
  </style>
  
  <h1>State tables generated by Umple from <<=fn>>.ump</h1>
  !>>


  emit genTopHeader(String fn)(topHeader);

  cr <<!
  !>>

  td <<!<td><<=content>></td>!>>
  emit genCell(String content)(td,cr);

  public StringBuilder genCellString(StringBuilder code, String s) {
    return _genCell(0, code, s);
  }
  

  // CENTRAL GENERATE METHOD

  public void generate()
  {
    // Output basic file header
    _genTopHeader(0, code, model.getUmpleFile().getSimpleFileName());

    String className;

    // Determine if there are multiple classes with state machines
    // or multiple state machines in any class
    // If so, we will need to put boxes around the state machines
    int smCount = 0;
    for (UmpleClass uClass : model.getUmpleClasses()) {
      for (StateMachine sm : uClass.getStateMachines()) {
        smCount++;
      }
    }
    System.out.println("Number of statemachines: " + smCount);
    if(smCount == 0) {
      // Special case. No state machine.

      code.append("<p>No State machines found in this model</p>\n");

      terminateCode(code);
      return;
    }

    // We now know we have to output one or more state machines
    // Iterate through each class.
    for (UmpleClass uClass : model.getUmpleClasses())
    {
      className = uClass.getName();

      // Process the top level state machines in a class
      for (StateMachine sm : uClass.getStateMachines())
      {
        code.append("<h2>Class ");
        code.append(className);
        code.append(" state machine ");
        code.append(sm.getName());
        code.append("</h2>\n\n");
        // Set up the state table
        StateTable st = new StateTable(uClass, sm);
	
		  st.buildRecursivelyCompositeEntry(sm);
		  ArrayList<CompositeStateWrapper> cswList = st.getPrimaryCswList();
		  for(CompositeStateWrapper csw : cswList)
		  {
		  	csw.displayPrimacy(false);
		  	System.out.println("Composite State: " + csw.getCompositeName());
		  }
		  ArrayList<Transition> tList = st.getTransitionList();
		  for(Transition t : tList)
		  {
		  	System.out.println("Transition: " + st.getTransitionInfo(t));
		  }
		  for(CompositeStateWrapper fromCsw : cswList)
		  {
		  	for(CompositeStateWrapper nextCsw : cswList)
		  	{
		  		for(Transition t : tList)
		  		{
		  			/*
		  			System.out.println("Checking...");
		  			System.out.println("From: " + fromCsw.getCompositeName());
		  			System.out.println("Tran: " + st.getTransitionInfo(t));
		  			System.out.println("Next: " + nextCsw.getCompositeName());
		  			*/
		  			if(fromCsw.isTransition(nextCsw,t))
		  			{
		  				System.out.println("CTC: " + fromCsw.getCompositeName() + " == " + st.getTransitionInfo(t) + " == " + nextCsw.getCompositeName());
		  			}
		  		}
		  	}
		  }
		  st.consolidateTransitions(tList);
        // Build the contents of the state tables
        st.buildRecursivelyEntry(sm);
        // Now figure out the headers
        st.buildAllEvents();

        // Output the headers of the State Event table
        code.append("<h3>State-event table</h3>\n");

        // Output the body of the state event table
        st.stateEventTableHtml(code);

        // Output the headers of the State State table
        code.append("<h3>State-state table</h3>\n");

        // Output the body of the state state table
        st.stateStateTableHtml(code);
        
        code.append("<h3>Composite state-event table</h3>\n");
        StringBuilder compositeStateEventTable = new StringBuilder();
        try
        {
        	st.compositeStateEventTableHtml(compositeStateEventTable);
        	code.append(compositeStateEventTable);
        }
        catch(Exception e)
        {
        	code.append(e + "\n");
        }
        
        code.append("<h3>Composite state-state table</h3>\n");
        StringBuilder compositeStateStateTable = new StringBuilder();
        try
        {
        	st.compositeStateStateTableHtml(compositeStateStateTable);
        	code.append(compositeStateStateTable);
        }
        catch(Exception e)
        {
        	code.append(e + "\n");
        }

      } // End iteration through state machines of a class
    } // End iteration through classes

    terminateCode(code);
    return;
  }

  private void terminateCode(StringBuilder code) {
    model.setCode(code.toString());
    writeModel();
    return;
  }

  // Output the graphviz file to a file with the .gv suffix
  private void writeModel()
  {
    try
    {
      String path = model.getUmpleFile().getPath();
      File file = new File(path);
      file.mkdirs();
      String modelFilename = path + File.separator + model.getUmpleFile().getSimpleFileName() + ".html";
      BufferedWriter bw = new BufferedWriter(new FileWriter(modelFilename));
      bw.write(model.getCode());
      bw.flush();
      bw.close();
    }
    catch (Exception e)
    {
      throw new UmpleCompilerException("There was a problem with generating State Tables." + e, e);
    }
    return;
  }
}

