/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
http://umple.org/license

*/

namespace cruise.umple.compiler;

class JavaGenerator
{
  depend cruise.umple.util.StringFormatter;
  
  private static Map<String,String> UpperCaseSingularLookupMap;
  private static Map<String,String> UpperCasePluralLookupMap;
  private static Map<String,String> AsIsSingularLookupMap;
  private static Map<String,String> AsIsPluralLookupMap;
  private static List<String> OneOrManyLookup;  
  
  static
  {
    UpperCaseSingularLookupMap = new HashMap<String, String>();
    UpperCaseSingularLookupMap.put("parameterOne", "a{0}");
    UpperCaseSingularLookupMap.put("removeParameterOne", "placeholder{0}");    
    UpperCaseSingularLookupMap.put("parameterNew", "aNew{0}");
    UpperCaseSingularLookupMap.put("parameterNext", "next{0}");
    UpperCaseSingularLookupMap.put("addMethod", "add{0}");
    UpperCaseSingularLookupMap.put("addAtMethod", "add{0}At");
    UpperCaseSingularLookupMap.put("addOrMoveAtMethod", "addOrMove{0}At");
    UpperCaseSingularLookupMap.put("removeMethod", "remove{0}");
    UpperCaseSingularLookupMap.put("indexOfMethod", "indexOf{0}");
    UpperCaseSingularLookupMap.put("parameterOld", "anOld{0}");
    UpperCaseSingularLookupMap.put("parameterExisting", "existing{0}");
    UpperCaseSingularLookupMap.put("parameterIsNew", "isNew{0}");
    UpperCaseSingularLookupMap.put("parameterGetUnique", "retrievedBy{0}");
    UpperCaseSingularLookupMap.put("parameterHasUnique", "hasUnique{0}");
    UpperCaseSingularLookupMap.put("associationNew", "new{0}");
    UpperCaseSingularLookupMap.put("canSetMethod", "canSet{0}");
    UpperCaseSingularLookupMap.put("parameterCurrent", "current{0}");
    UpperCaseSingularLookupMap.put("deleteMethod", "delete{0}");
    UpperCaseSingularLookupMap.put("setMethod", "set{0}");
    UpperCaseSingularLookupMap.put("enterMethod", "enter{0}");
    UpperCaseSingularLookupMap.put("exitMethod", "exit{0}");
    UpperCaseSingularLookupMap.put("resetMethod", "reset{0}");
    UpperCaseSingularLookupMap.put("getMethod", "get{0}");
    UpperCaseSingularLookupMap.put("isMethod", "is{0}");
    UpperCaseSingularLookupMap.put("getFullMethod", "get{0}FullName");    
    UpperCaseSingularLookupMap.put("isFinalMethod", "is{0}Final");
    UpperCaseSingularLookupMap.put("getDefaultMethod", "getDefault{0}");
    UpperCaseSingularLookupMap.put("didAdd", "didAdd{0}");
    UpperCaseSingularLookupMap.put("hasMethod", "has{0}");
    UpperCaseSingularLookupMap.put("associationCanSetOne","canSet{0}");
    UpperCaseSingularLookupMap.put("attributeCanSetOne","canSet{0}");
    UpperCaseSingularLookupMap.put("eventStartMethod", "start{0}Handler");
    UpperCaseSingularLookupMap.put("eventStopMethod", "stop{0}Handler");    
    UpperCaseSingularLookupMap.put("stateNull", "Null");
    UpperCaseSingularLookupMap.put("doExitMethod", "doExit{0}");
    UpperCaseSingularLookupMap.put("doEventMethod", "do{0}");

    UpperCasePluralLookupMap = new HashMap<String, String>();
    UpperCasePluralLookupMap.put("parameterMany", "new{0}");
    UpperCasePluralLookupMap.put("parameterAll", "all{0}");
    UpperCasePluralLookupMap.put("numberOfMethod", "numberOf{0}");
    UpperCasePluralLookupMap.put("minimumNumberOfMethod", "minimumNumberOf{0}");
    UpperCasePluralLookupMap.put("maximumNumberOfMethod", "maximumNumberOf{0}");
    UpperCasePluralLookupMap.put("isNumberOfValidMethod", "isNumberOf{0}Valid");
    UpperCasePluralLookupMap.put("parameterVerifiedMany", "verified{0}");
    UpperCasePluralLookupMap.put("parameterOldMany", "old{0}");
    UpperCasePluralLookupMap.put("parameterCheckNewMany", "checkNew{0}");
    UpperCasePluralLookupMap.put("parameterCopyOfMany", "copyOf{0}");
    UpperCasePluralLookupMap.put("getManyMethod", "get{0}");
    UpperCasePluralLookupMap.put("parameterMany", "new{0}");
    UpperCasePluralLookupMap.put("setManyMethod", "set{0}");
    UpperCasePluralLookupMap.put("didAddMany", "didAdd{0}");
    UpperCasePluralLookupMap.put("hasManyMethod", "has{0}");
    UpperCasePluralLookupMap.put("associationCanSetMany","canSet{0}");
    UpperCasePluralLookupMap.put("attributeCanSetMany","canSet{0}");
    UpperCasePluralLookupMap.put("requiredNumberOfMethod", "requiredNumberOf{0}");

    AsIsSingularLookupMap = new HashMap<String, String>();
    AsIsSingularLookupMap.put("associationOne","{0}");
    AsIsSingularLookupMap.put("attributeOne","{0}");
    AsIsSingularLookupMap.put("stateMachineOne","{0}");
    AsIsSingularLookupMap.put("stateOne","{0}");
    AsIsSingularLookupMap.put("stateString","\"{0}\"");
    AsIsSingularLookupMap.put("eventMethod","{0}");
    AsIsSingularLookupMap.put("eventHandler", "{0}Handler");
        
    AsIsPluralLookupMap = new HashMap<String, String>();
    AsIsPluralLookupMap.put("associationMany","{0}");
    AsIsPluralLookupMap.put("attributeMany","{0}");
    
    OneOrManyLookup = new ArrayList<String>();
    OneOrManyLookup.add("attribute");
    OneOrManyLookup.add("parameter");
  }
  
  public void generate()
  {
    prepare();
    UmpleElement lastElement = null;
    try{
      for (UmpleElement currentElement : getModel().getUmpleElements())
      {
        if ("external".equals(currentElement.getModifier()))
        {
          continue;
        }
        writeFile(currentElement);
        
        lastElement = currentElement;
      }
    }
    catch(Exception e){
      throw new UmpleCompilerException("There was a problem with generating classes. " + e, e);	
    }
    
    if (lastElement == null)
    {
      System.err.println("No classes were compiled. It is likely the source .ump file(s) contained no compilable code.");
    }
    
    if(mainClasses.size()>0)
    {
      writeUncaughtExceptionFile(mainClasses.get(0));
    }
    postpare();
  }
  
  
  public ILang getLanguageFor(UmpleElement aElement)
  {
    if (aElement instanceof UmpleInterface)
    {
      return new JavaInterfaceGenerator();
    }
    else if (aElement instanceof UmpleClass)
    {
      return new JavaClassGenerator();
    } 
    else{
        return null;        
    }
  }
  
  public boolean isNullable(UmpleVariable av)
  {
    return !UmpleToPrimitiveMap.containsKey(av.getType());
  }
  
  public String relatedTranslate(String name, AssociationVariable av)
  {
    return translate(name,av.getRelatedAssociation());
  }
  
  public String translate(String keyName, State state)
  {
    String singularName = state.getName();
    String pluralName = getModel().getGlossary().getPlural(singularName);
  
    if (UpperCasePluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCasePluralLookupMap.get(keyName),getUpperCaseName(pluralName));
    }
    else if (UpperCaseSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCaseSingularLookupMap.get(keyName),getUpperCaseName(singularName));
    }
    else if (AsIsPluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsPluralLookupMap.get(keyName),pluralName);
    }
    else if (AsIsSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsSingularLookupMap.get(keyName),singularName);
    }
    else if ("type".equals(keyName))
    {
      return getUpperCaseName(state.getStateMachine().getName());
    }
    
    return "UNKNOWN ID: " + keyName;
  }

  public String translate(String keyName, Activity a)
  {
    State s = a.getState();
    String threadNum = "";
    if (s.numberOfActivities() > 1)
    {
      threadNum = "" + a.getState().getActivities().indexOf(a);
    }
    if ("doActivityMethod".equals(keyName))
    {
      return StringFormatter.format("doActivity{0}{1}", threadNum,  GeneratorHelper.getFullActivityName(a.getState())); 
    }
    else if ("doActivityThread".equals(keyName))
    {
      return StringFormatter.format("doActivity{0}{1}Thread", threadNum, GeneratorHelper.getFullActivityName(a.getState())); 
    }
    return "UNKNOWN ID: " + keyName;
  }
  
  public String translate(String keyName, StateMachine sm)
  {
    String singularName = sm.getFullName();
    String pluralName = getModel().getGlossary().getPlural(singularName);
  
    if (UpperCasePluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCasePluralLookupMap.get(keyName),getUpperCaseName(pluralName));
    }
    else if (UpperCaseSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCaseSingularLookupMap.get(keyName),getUpperCaseName(singularName));
    }
    else if (AsIsPluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsPluralLookupMap.get(keyName),pluralName);
    }
    else if (AsIsSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsSingularLookupMap.get(keyName),singularName);
    }
    else if ("typeGet".equals(keyName) || "typeFull".equals(keyName))
    {
      return "String";
    }
    else if ("type".equals(keyName))
    {
      return getUpperCaseName(sm.getFullName());
    }
    else if ("listStates".equals(keyName))
    {
      String allEnums = "";
      for(State state : sm.getStates())
      {
        if (allEnums.length() > 0)
        {
          allEnums += ", ";
        }
        allEnums += translate("stateOne",state);
      }
      return allEnums;
    }
       
    else if ("listMessageTypesStates".equals(keyName))
    {
      String allEnums = "";
      
      if(sm.getNestedStateMachines().isEmpty())
      {
        for(State state : sm.getStates())
        {
          if (allEnums.length() > 0)
          {
            allEnums += "\n  ";
          }
          allEnums+="  stateMessageMap.put(";
          allEnums+=translate("type",sm);
          allEnums+=".";
          allEnums +=state.getName();
          allEnums+=",new HashSet<MessageType>(Arrays.asList(";
          String allEventEnums = "";
          if(!state.getTransitions().isEmpty())
          {
            for (Transition t : state.getTransitions())
            {
              if(!t.getEvent().isAutoTransition())
              {
                if(!t.getEvent().isUnspecified())
                {
                  if (allEventEnums.length() > 0)
                  {
                    allEventEnums += ", ";
                  }
                  allEventEnums += "MessageType.";
                  allEventEnums += t.getEvent().getName();
                  allEventEnums += "_M";
                }
              }
            }
          
            int countingAutoTrans = 0;
            int countingUnspec = 0;
            int countingResult = 0;
            int countingSize = state.getTransitions().size();
            for(Transition t : state.getTransitions())
            {
              if(t.getEvent().isAutoTransition())
              {
                countingAutoTrans++;
              }
              if(t.getEvent().isUnspecified())
              {
                countingUnspec++;
              }    
            }
            countingResult = countingAutoTrans+countingUnspec;
            if(countingResult == countingSize)
            {
              allEventEnums += "MessageType.null_M";
            }
          }
          else if(state.getTransitions().isEmpty())
          {
            allEventEnums += "MessageType.null_M";
          }
          allEnums += allEventEnums;
          allEnums += ")));";
        }
      }
      else if(!sm.getNestedStateMachines().isEmpty())
      {
        for(State state : sm.getStates())
        {
          if (allEnums.length() > 0)
          {
            allEnums += "\n  ";
          }
          allEnums+="  stateMessageMap.put(";
          allEnums+=translate("type",sm);
          allEnums+=".";
          allEnums +=state.getName();
          allEnums+=",new HashSet<MessageType>(Arrays.asList(";
          String allEventEnums = "";
          if(!state.getTransitions().isEmpty())
          {
            for (Transition t : state.getTransitions())
            {
              if(!t.getEvent().isAutoTransition())
              {
                if(!t.getEvent().isUnspecified())
                {
                  if (allEventEnums.length() > 0)
                  {
                    allEventEnums += ", ";
                  }
                  allEventEnums += "MessageType.";
                  allEventEnums += t.getEvent().getName();
                  allEventEnums += "_M";
                }
              }
            }
          
            int countAutoTrans = 0;
            int countUnspec = 0;
            int result = 0;
            int size = state.getTransitions().size();
            for(Transition t : state.getTransitions())
            {
              if(t.getEvent().isAutoTransition())
              {
                countAutoTrans++;
              }
              if(t.getEvent().isUnspecified())
              {
                countUnspec++;
              }
            }
            result = countAutoTrans+countUnspec;
            if(result == size)
            {
              allEventEnums += "MessageType.null_M";
            }
          }
          else if(state.getTransitions().isEmpty())
          {
            allEventEnums += "MessageType.null_M";
          }
          allEnums += allEventEnums;
          allEnums += ")));";
        }

        String exitEveName ="";
        String enterEveName ="";
        for(StateMachine nsm : sm.getNestedStateMachines())
        {
          String exitEve=null;
          String enterEve=null;
          
          if (nsm.getParentState() != null)
          {
            State parentState = nsm.getParentState();
            exitEve = translate("exitMethod",parentState); //for parent stat of nsm
            enterEve = translate("enterMethod",parentState);
          }
          for(State s:sm.getStates())
          {
            String exitE = translate("exitMethod",s);
            String enterE = translate("enterMethod",s);
            if(exitE.equals(exitEve) && enterE.equals(enterEve))
            {
              exitEveName = exitE;
              enterEveName = enterE;
              break;
            }
          }
          for(State state : nsm.getStates())
          {
            if (allEnums.length() > 0)
            {
              allEnums += "\n  ";
            }
            allEnums+="  stateMessageMap.put(";
            allEnums+=translate("type",nsm);
            allEnums+=".";
            allEnums +=state.getName();
            allEnums+=",new HashSet<MessageType>(Arrays.asList(";
            String allEventEnums = "";
            if(!state.getTransitions().isEmpty())
            {
              for (Transition t : state.getTransitions())
              {
                if(!t.getEvent().isAutoTransition())
                {
                  if(!t.getEvent().isUnspecified())
                  {
                    if(!t.getEvent().getName().equals(exitEve))
                    {
                      if(!t.getEvent().getName().equals(enterEve))
                      {
                        if(!t.getEvent().getName().equals(exitEveName))
                        {
                          if(!t.getEvent().getName().equals(enterEveName))
                          {
                            if (allEventEnums.length() > 0)
                            {
                              allEventEnums += ", ";
                            }
                            allEventEnums += "MessageType.";
                            allEventEnums += t.getEvent().getName();
                            allEventEnums += "_M";
                          }
                        }
                      }
                    }
                  }
                }
              }
            
              int countNestedAutoTrans = 0;
              int countNestedUnspec = 0;
              int nestedResult = 0;
              int nestedSize = state.getTransitions().size();
              for(Transition t : state.getTransitions())
              {
                if(t.getEvent().isAutoTransition())
                {
                  countNestedAutoTrans++;
                }
                if(t.getEvent().isUnspecified())
                {
                  countNestedUnspec++;
                }
              }
              nestedResult = countNestedAutoTrans+countNestedUnspec;
              if(nestedResult == nestedSize)
              {
                allEventEnums += "MessageType.null_M";
              }
          
              String exEvent ="";
              String enEvent ="";
              int sizeTrans = state.getTransitions().size();
              for(State s : sm.getStates())
              {
                int exCount = 0;
                int enCount = 0;
                int countResult = 0;
                exEvent = translate("exitMethod",s);  
                enEvent = translate("enterMethod",s);
                for(Transition t : state.getTransitions())
                {
                  if(t.getEvent().getName().equals(exEvent))
                  {
                    exCount++;
                  }
                  if(t.getEvent().getName().equals(enEvent))
                  {
                    enCount++;
                  }
                }
                countResult = exCount+enCount;
                if(countResult == sizeTrans)
                {
                  allEventEnums += "MessageType.null_M";
                }
              }     
            }
            else if(state.getTransitions().isEmpty())
            {
              allEventEnums += "MessageType.null_M";
            }
            
            allEnums += allEventEnums;
            allEnums += ")));";
          }       
        }
      }
      return allEnums;
    } 
        
    return "UNKNOWN ID: " + keyName;
  }
  
  public String translate(String keyName, Event event)
  {
    String singularName = event.getName();
    String pluralName = getModel().getGlossary().getPlural(singularName);

    if (UpperCasePluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCasePluralLookupMap.get(keyName),getUpperCaseName(pluralName));
    }
    else if (UpperCaseSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCaseSingularLookupMap.get(keyName),getUpperCaseName(singularName));
    }
    else if (AsIsPluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsPluralLookupMap.get(keyName),pluralName);
    }
    else if (AsIsSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsSingularLookupMap.get(keyName),singularName);
    }
    
    return "UNKNOWN ID: " + keyName;
  }  
  
  public String translate(String name, UmpleInterface aInterface)
  {
    if ("packageDefinition".equals(name))
    {
      return aInterface.getPackageName().length() == 0 ? "" : "package " + aInterface.getPackageName() + ";"; 
    }
    if ("isA".equals(name))
    {
      return getImplementsForInterfaces(aInterface);
    }
    return "";
  }
  
  public String translate(String methodType)
  {
    if ("String".equals(methodType))
    {
      return "\"\"";
    }
    if ("int".equals(methodType) || "double".equals(methodType) || "float".equals(methodType))
    {
      return "0";
    }
    if ("boolean".equals(methodType))
    {
      return "false";
    }
    if ("void".equals(methodType))
    {
      return "";
    }        
    return "null";
  }
  
  public String translate(String keyName, UmpleClass aClass)
  {
    if ("constructorMandatory".equals(keyName))
    {
      return aClass.getGeneratedClass().getLookup("constructorSignature_mandatory");
    }
    else if ("packageDefinition".equals(keyName))
    {
      return aClass.getPackageName().length() == 0 ? "" : "package " + aClass.getPackageName() + ";"; 
    }
    else if ("type".equals(keyName))
    {
      return aClass.getName();
    }
    else if ("isA".equals(keyName))
    {
      return getExtendAndImplements(aClass);
    }
    else if ("deleteMethod".equals(keyName))
    {
      return "delete";
    }
    
    else if ("listEventsForQSM".equals(keyName))
    {
      String allEnums = "";
      
      String evName="";
      boolean sameEvName=false;
      List<String> evList=new ArrayList<String>();         
      
      for(StateMachine stm : aClass.getStateMachines())
      {
        List<StateMachine> allNested = stm.getNestedStateMachines();
        boolean nestedSMhasEvent=false;
        
        if (!stm.getNestedStateMachines().isEmpty() && !stm.getEvents().isEmpty())
        {
          for(StateMachine nestedSm : allNested)
          {
            for (Event event : nestedSm.getEvents())
            {
              if(event.getIsInternal() == false && event != null)
              {
                nestedSMhasEvent=true;
              }
            }
          }
        
          if (nestedSMhasEvent == true)
          {
            String allNesEvenEnums = "";          
          
            for(Event event : stm.getEvents())
            {
              for(int i=0; i<evList.size(); i++)
              {
                if(evList.get(i).equals(event.getName()))
                {
                  sameEvName=true;
                }
              }
         
              if(sameEvName == false)
              {
                if (!event.isAutoTransition())
                {
                  if(!event.isUnspecified())
                  {
                    if(!evName.equals(event.getName()))
                    {
                      evList.add(event.getName());
             
                      if (allEnums.length() > 0)
                      {
                        allEnums += ", ";
                      }
                      allEnums += translate("eventMethod",event);
                      allEnums += "_M";
                      evName=event.getName();
                    }
                  }
                }
              }
              sameEvName=false;
            }
            
            boolean found = false;
            for (StateMachine nsm : stm.getNestedStateMachines())
            {
              for (Event event : nsm.getEvents())
              {
                for(int i=0; i<evList.size(); i++)
                {
                  if(evList.get(i).equals(event.getName()))
                  {
                    sameEvName=true;
                  }
                }
          
                if(sameEvName == false)
                {
                  if(event.getIsInternal() == false)
                  {
                    if (!event.isAutoTransition())
                    {
                      if(!event.isUnspecified())
                      {
                        found =true;
                      }
                    }
                  }
                }
                sameEvName=false;
              }
            }
            
            if(allEnums.length() > 0 && found == true)
            {
              allEnums += ", ";
            }
            
            for (StateMachine nsm : stm.getNestedStateMachines())
            {
              for (Event event : nsm.getEvents())
              {
                for(int i=0; i<evList.size(); i++)
                {
                  if(evList.get(i).equals(event.getName()))
                  {
                    sameEvName=true;
                  }
                }
          
                if(sameEvName == false)
                {
                  if(event.getIsInternal() == false)
                  {
                    if (!event.isAutoTransition())
                    {
                      if(!event.isUnspecified())
                      {
                        if(!evName.equals(event.getName()))
                        {
                          evList.add(event.getName());
              
                          if (allNesEvenEnums.length() > 0)
                          {
                            allNesEvenEnums += ", ";
                          }
                          allNesEvenEnums += translate("eventMethod",event);
                          allNesEvenEnums += "_M"; 
                          evName=event.getName();
                        } 
                      }
                    }
                  }
                }
                sameEvName=false;
              }
            }
            allEnums += allNesEvenEnums;
            nestedSMhasEvent=false;
          }
          else
          {
            for(Event event : stm.getEvents())
            {
              for(int i=0; i<evList.size(); i++)
              {
                if(evList.get(i).equals(event.getName()))
                {
                  sameEvName=true;
                }
              }
              
              if(sameEvName == false)
              {
                if (!event.isAutoTransition())
                {
                  if(!event.isUnspecified())
                  {
                    if( !evName.equals(event.getName()))
                    {
                      evList.add(event.getName());
             
                      if (allEnums.length() > 0)
                      {
                        allEnums += ", ";
                      }
                      allEnums += translate("eventMethod",event);
                      allEnums += "_M";
                      evName=event.getName();
                    }
                  }
                }
              }
              sameEvName=false;
            }
          }  
        }
        else if (!stm.getNestedStateMachines().isEmpty() && stm.getEvents().isEmpty())
        {
          for (StateMachine nsm : stm.getNestedStateMachines())
          {
            for (Event event : nsm.getEvents())
            {
              for(int i=0; i<evList.size(); i++)
              {
                if(evList.get(i).equals(event.getName()))
                {
                  sameEvName=true;
                }
              }
          
              if(sameEvName == false)
              {
                if(event.getIsInternal() == false)
                {
                  if (!event.isAutoTransition())
                  {
                    if(!event.isUnspecified())
                    {
                      if( !evName.equals(event.getName()))
                      {
                        evList.add(event.getName());
             
                        if (allEnums.length() > 0 )
                        {
                          allEnums += ", ";
                        }
                        allEnums += translate("eventMethod",event);
                        allEnums += "_M"; 
                        evName=event.getName();
                      }
                    } 
                  }
                }
              }
              sameEvName=false;
            }
          }
        }
        else
        {
          for(Event event : stm.getEvents())
          {
          
            for(int i=0; i<evList.size(); i++)
            {
              if(evList.get(i).equals(event.getName()))
              {
                sameEvName=true;
              }
            }
              
            if(sameEvName == false)
            {
              if (!event.isAutoTransition())
              {
                if(!event.isUnspecified())
                {
                  if( !evName.equals(event.getName()))
                  {
                    evList.add(event.getName());
              
                    if (allEnums.length() > 0)
                    {
                      allEnums += ", ";
                    }
                    allEnums += translate("eventMethod",event);
                    allEnums += "_M";
                    evName=event.getName();
                  }
                }
              }
            }
            sameEvName=false;
          }
        }
      }
      return allEnums;
    }
    
    else if ("listEventsForPooledSM".equals(keyName))
    {
      String allEnums = "";
      
      String evName="";
      boolean sameEvName=false;
      List<String> evList=new ArrayList<String>();         

      for(StateMachine sm : aClass.getStateMachines())
      {
        List<StateMachine> allNested = sm.getNestedStateMachines();
        boolean nestedSMhasEvent=false;       
        
        if (!sm.getNestedStateMachines().isEmpty() && !sm.getEvents().isEmpty())
        {
          for(StateMachine nestedSm : allNested)
          {
            for (Event event : nestedSm.getEvents())
            {
              if(event.getIsInternal() == false && event != null)
              {
                nestedSMhasEvent=true;
              }
            } 
          }

          if (nestedSMhasEvent == true)
          {
            String allNesEvenEnums = "";
            for(Event event : sm.getEvents())
            {
              for(int i=0; i<evList.size(); i++)
              {
                if(evList.get(i).equals(event.getName()))
                {
                  sameEvName=true;
                }
              }

              if(sameEvName == false)
              {
                if (!event.isAutoTransition())
                {
                  if(!event.isUnspecified())
                  {
                    if( !evName.equals(event.getName()))
                    {
                      evList.add(event.getName());
                      if (allEnums.length() > 0)
                      {
                        allEnums += ", ";
                      }
                      allEnums += translate("eventMethod",event);
                      allEnums += "_M";
                      evName=event.getName();
                    }
                  }
                }
              }
              sameEvName=false;
            }
            
            boolean foundNotSameEv = false;
            
            for (StateMachine nsm : sm.getNestedStateMachines())
            {
              for (Event event : nsm.getEvents())
              {
                for(int i=0; i<evList.size(); i++)
                {
                  if(!evList.get(i).equals(event.getName()))
                  {
                    foundNotSameEv=true;
                  }
                }
              }
            }
            if(foundNotSameEv == true)
            {
              allEnums += ", ";
            }
            for (StateMachine nsm : sm.getNestedStateMachines())
            {
              for (Event event : nsm.getEvents())
              {
                for(int i=0; i<evList.size(); i++)
                {
                  if(evList.get(i).equals(event.getName()))
                  {
                    sameEvName=true;
                  }
                }
          
                if(sameEvName == false)
                {
                  if(event.getIsInternal() == false)
                  {
                    if (!event.isAutoTransition())
                    {
                      if(!event.isUnspecified())
                      {
                        if( !evName.equals(event.getName()))
                        {
                          evList.add(event.getName());
             
                          if (allNesEvenEnums.length() > 0)
                          {
                            allNesEvenEnums += ", ";
                          }
                          allNesEvenEnums += translate("eventMethod",event);
                          allNesEvenEnums += "_M"; 
                          evName=event.getName();
                        }
                      }
                    }
                  }
                }
                sameEvName=false;
              }
            }
            allEnums += allNesEvenEnums;
            nestedSMhasEvent=false;
          }

          else
          {
            for(Event event : sm.getEvents())
            {

              for(int i=0; i<evList.size(); i++)
              {
                if(evList.get(i).equals(event.getName()))
                {
                  sameEvName=true;
                }
              }

              if(sameEvName == false)
              {
                if (!event.isAutoTransition())
                {
                  if(!event.isUnspecified())
                  {
                    if( !evName.equals(event.getName()))
                    {
                      evList.add(event.getName());
                      if (allEnums.length() > 0)
                      {
                        allEnums += ", ";
                      }
                      allEnums += translate("eventMethod",event);
                      allEnums += "_M";
                      evName=event.getName();
                    }
                  }
                }
              }
              sameEvName = false;
            }
          }  
        }
        else if (!sm.getNestedStateMachines().isEmpty() && sm.getEvents().isEmpty())
        {
          for (StateMachine nsm : sm.getNestedStateMachines())
          {
            for (Event event : nsm.getEvents())
            {
              for(int i=0; i<evList.size(); i++)
              {
                if(evList.get(i).equals(event.getName()))
                {
                  sameEvName=true;
                }
              }
          
              if(sameEvName == false)
              {
                if(event.getIsInternal() == false)
                {
                  if (!event.isAutoTransition())
                  {
                    if(!event.isUnspecified())
                    {
                      if(!evName.equals(event.getName()))
                      {
                        evList.add(event.getName());
             
                        if (allEnums.length() > 0 )
                        {
                          allEnums += ", ";
                        }
                        allEnums += translate("eventMethod",event);
                        allEnums += "_M"; 
                        evName=event.getName();
                      }
                    } 
                  }
                }
              }
              sameEvName=false;
            }
          }
        }
        else
        {
          for(Event event : sm.getEvents())
          {

            for(int i=0; i<evList.size(); i++)
            {
                if(evList.get(i).equals(event.getName()))
                {
                  sameEvName=true;
                }
            }

            if(sameEvName == false)
            {
              if (!event.isAutoTransition())
              {
                if(!event.isUnspecified())
                {
                  if(!evName.equals(event.getName()))
                  {
                    evList.add(event.getName());
                    if (allEnums.length() > 0)
                    {
                      allEnums += ", ";
                    }
                    allEnums += translate("eventMethod",event);
                    allEnums += "_M";
                    evName=event.getName();
                  }
                }
              }
            }
            sameEvName=false;
          }
        }
        
        
        if(sm.getNestedStateMachines().isEmpty())
        {
          for(State state : sm.getStates())
          {
            if(!state.getTransitions().isEmpty())
            {
              int cAutoTrans = 0;
              int cUnspec = 0;
              int cResult = 0;
              int cSize = state.getTransitions().size();
              for(Transition t : state.getTransitions())
              {
                if(t.getEvent().isAutoTransition())
                {
                  cAutoTrans++;
                }
                if(t.getEvent().isUnspecified())
                {
                  cUnspec++;
                }
              }
              cResult = cAutoTrans+cUnspec;
              if(cSize == cResult)
              {
                if (!allEnums.contains("null_M"))
                {
                  if(!allEnums.equals(""))
                  {
                    allEnums += ", null_M";
                  }
                  else
                  {
                    allEnums += "null_M";
                  }
                }
              }
            }
            else if(state.getTransitions().isEmpty())
            {
              if (!allEnums.contains("null_M")) 
              {
                if(!allEnums.equals(""))
                {
                  allEnums += ", null_M";
                }
                else
                {
                  allEnums += "null_M";
                }
              }
            }
          }
        }
        else if(!sm.getNestedStateMachines().isEmpty())
        {
          for(State state : sm.getStates())
          {
            if(!state.getTransitions().isEmpty())
            {
              int countAutoTrans = 0;
              int countUnspec = 0;
              int result = 0;
              int size = state.getTransitions().size();
              for(Transition t : state.getTransitions())
              {
                if(t.getEvent().isAutoTransition())
                {
                  countAutoTrans++;
                }
                if(t.getEvent().isUnspecified())
                {
                  countUnspec++;
                }
              }
              result = countAutoTrans+countUnspec;
              if(result == size)
              {
                if (!allEnums.contains("null_M")) 
                {
                  if(!allEnums.equals(""))
                  {
                    allEnums += ", null_M";
                  }
                  else
                  {
                    allEnums += "null_M";
                  }
                }
              }
            }
            else if(state.getTransitions().isEmpty())
            {
              if (!allEnums.contains("null_M")) 
              {
                if(!allEnums.equals(""))
                {
                  allEnums += ", null_M";
                }
                else
                {
                  allEnums += "null_M";
                }
              }
            }
          }
          for(StateMachine nsm : sm.getNestedStateMachines())
          {
            String exitEve=null;
            String enterEve=null;
            if (nsm.getParentState() != null)
            {
              State parentState = nsm.getParentState();
              exitEve = translate("exitMethod",parentState);
              enterEve = translate("enterMethod",parentState);
            }
        
            for(State state : nsm.getStates())
            {
              String allEventEnums = "";
              if(!state.getTransitions().isEmpty())
              { 
                int countNestedAutoTrans = 0;
                int countNestedUnspec = 0;
                int countExit = 0;
                int countEnter = 0;
                int nestedResult = 0;
                int nestedSize = state.getTransitions().size();
                for(Transition t : state.getTransitions())
                {
                  if(t.getEvent().isAutoTransition())
                  {
                    countNestedAutoTrans++;
                  }
                  if(t.getEvent().isUnspecified())
                  {
                    countNestedUnspec++;
                  }
                  if(t.getEvent().getName().equals(exitEve))
                  {
                    countExit++;
                  }
                  if(t.getEvent().getName().equals(enterEve))
                  {
                    countEnter++;
                  }
                }
                nestedResult = countNestedAutoTrans+countNestedUnspec+countExit+countEnter;
                if(nestedResult == nestedSize)
                {
                  if (!allEnums.contains("null_M")) 
                  {
                    if(!allEnums.equals(""))
                    {
                      allEnums += ", null_M";
                    }
                    else
                    {
                      allEnums += "null_M";
                    }
                  }
                }
              }
              else if(state.getTransitions().isEmpty())
              {
                if (!allEnums.contains("null_M")) 
                {
                  if(!allEnums.equals(""))
                  {
                    allEnums += ", null_M";
                  }
                  else
                  {
                    allEnums += "null_M";
                  }
                }
              }
            }        
          }
        }
      }
      return allEnums;
    } 
    
    return "UNKNOWN ID: " + keyName;
  }
  
  public String umpleCVarToLanguagePrimitive(String name, ConstraintVariable expr) {
    if ((expr instanceof ConstraintAttribute)&&"Date".equals(((ConstraintAttribute)expr).getAttribute().getType()))
    {
      return name + ".getTime()";
    }
    else
    {
      return name;
    }
  }
  
  private String getImplementsForInterfaces(UmpleInterface uInterface)
  {
      String implementedInterfaces = "";

      if (uInterface.hasExtendsInterface() == false){
          return "";
      }
      else{
          for (UmpleInterface aInterface : uInterface.getExtendsInterface())
          {
              implementedInterfaces += aInterface.getName() + ", " ; 
          }
          implementedInterfaces = implementedInterfaces.substring(0, implementedInterfaces.length()-2); 
          return " extends " + implementedInterfaces;
      }
  }

  private String getExtendAndImplements(UmpleClass uClass)
  {
      String extendsString = "";
      String implementsString = "";

      extendsString = getExtendClassesNames(uClass);
      implementsString = getImplementsInterfacesNames(uClass);

      return extendsString + implementsString; 
  }

  private String getExtendClassesNames(UmpleClass uClass)
  {
      UmpleClass parent = uClass.getExtendsClass();
      if (parent == null)
      {
          return "";
      }
      else{
          return   " extends " + parent.getName();  
      }
  }

  private String getImplementsInterfacesNames(UmpleClass uClass)
  {
      String implementedInterfaces = "";

      if (uClass.hasParentInterface() == false){
          return "";
      }
      else{
          for (UmpleInterface uInterface : uClass.getParentInterface())
          {
              implementedInterfaces += uInterface.getName() + "," ; 
          }
          implementedInterfaces = implementedInterfaces.substring(0, implementedInterfaces.length()-1); 
          return " implements " + implementedInterfaces;
      }
  }

  public String translate(String keyName, Attribute av)
  {
    return translate(keyName,av,av.getIsList());
  }
  
  public String translate(String keyName, AssociationVariable av)
  {
    return translate(keyName,av,av.isMany());
  }

  // Translates Date and Time values, has to be used for interfaces as they do not use attributes. 
  public String translateInterfaceValue(String value, String type)
  {
    if (value == null)
    {
      return "null";
    }
      
    boolean isString = value.startsWith("\"") && value.endsWith("\"");
    if (isString && "Date".equals(type))
    {
      return "Date.valueOf("+ value +")";      
    }
    else if (isString && "Time".equals(type))
    {
      return "Time.valueOf("+ value +")";
    }
    else
    {
      return value;
    }
  }

  // Translates primitive data types to their Java equivalent. Used for interfaces as they do not use attributes.
  public String translateInterfaceType(String type)
  {
      return typeOf(type);
  }
  
  private String translate(String keyName, UmpleVariable av, boolean isMany)
  {
    if (OneOrManyLookup.contains(keyName))
    {
      String realKeyName = isMany ? keyName + "Many" : keyName + "One";
      return translate(realKeyName,av,isMany);
    }
    
    String singularName = isMany ? getModel().getGlossary().getSingular(av.getName()) : av.getName();
    String pluralName = isMany ? av.getName() : getModel().getGlossary().getPlural(av.getName());

    if (UpperCasePluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCasePluralLookupMap.get(keyName),getUpperCaseName(pluralName));
    }
    else if (UpperCaseSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(UpperCaseSingularLookupMap.get(keyName),getUpperCaseName(singularName));
    }
    else if (AsIsPluralLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsPluralLookupMap.get(keyName),pluralName);
    }
    else if (AsIsSingularLookupMap.containsKey(keyName))
    {
      return StringFormatter.format(AsIsSingularLookupMap.get(keyName),singularName);
    }
    else if ("parameterValue".equals(keyName))
    {
      if (av.getValue() == null)
      {
        return "null";
      }
      
      
      
      boolean isString = av.getValue().startsWith("\"") && av.getValue().endsWith("\"");
      if (isString && "Date".equals(av.getType()))
      {
        return "Date.valueOf("+ av.getValue() +")";      
      }
      else if (isString && "Time".equals(av.getType()))
      {
        return "Time.valueOf("+ av.getValue() +")";
      }
      else if ("Float".equals(av.getType()))
      {
        return "(float) " + av.getValue();
      }
      else
      {
        return av.getValue();
      }
    }
    else if ("type".equals(keyName))
    {
      return getType(av);
    }
    else if ("typeMany".equals(keyName))
    {
      return isNullable(av) ? getType(av) : av.getType();
    }
    
    if (av instanceof AssociationVariable)
    {
      AssociationVariable assVar = (AssociationVariable)av;
      if ("callerArgumentsExcept".equals(keyName))
      {
        UmpleClass classToRemove = getModel().getUmpleClass(getType(assVar.getRelatedAssociation()));
        GeneratedClass generatedClassToRemove = classToRemove.getGeneratedClass();
        String   callerNameToRemove = translate("parameterOne",assVar);
        return StringFormatter.replaceParameter(generatedClassToRemove.getLookup("constructorSignature_caller"), callerNameToRemove, "this");
      }
      else if ("methodArgumentsExcept".equals(keyName))
      {
        UmpleClass classToRemove = getModel().getUmpleClass(getType(assVar.getRelatedAssociation()));
        GeneratedClass generatedClassToRemove = classToRemove.getGeneratedClass();
        String parameterNameToRemove = StringFormatter.format("{0} {1}", translate("type",assVar), translate("parameterOne",assVar));
        return StringFormatter.replaceParameter(generatedClassToRemove.getLookup("constructorSignature"), parameterNameToRemove, ""); 
      }
      else if ("callerArgumentsForMandatory".equals(keyName))
      {
        UmpleClass classToLookup = getModel().getUmpleClass(getType(av));
        String lookup = "constructorSignature_mandatory_" + assVar.getRelatedAssociation().getName();
        String parameters = classToLookup.getGeneratedClass().getLookup(lookup);
        return parameters;
      }
      else if ("associationCanSet".equals(keyName))
      {
        String actualLookup = assVar.isMany() ? "associationCanSetMany" : "associationCanSetOne";
        return translate(actualLookup,av,isMany);
      }
    }
    else if (av instanceof Attribute)
    {
      Attribute attVar = (Attribute)av;
      if ("attributeCanSet".equals(keyName))
      {
        String actualLookup = attVar.getIsList() ? "attributeCanSetMany" : "attributeCanSetOne";
        return translate(actualLookup,av,isMany);
      }
      else if ("hasUniqueMethod".equals(keyName)) 
      {
        return "hasWith" + attVar.getUpperCaseName();
      } 
      else if ("getUniqueMethod".equals(keyName))
      {
        return "getWith" + attVar.getUpperCaseName();
      }
      else if ("uniqueMap".equals(keyName))
      {
        return attVar.getUmpleClass().getName().toLowerCase() + "s" + "By" + attVar.getUpperCaseName();
      }
    }
    
    return "UNKNOWN ID: " + keyName;
  }
  
  public void prepare()
  {
    List<UmpleClass> allClasses = new ArrayList<UmpleClass>(getModel().getUmpleClasses());
    for (UmpleClass aClass : allClasses)
    {
      prepare(aClass);
    }
    
    for (UmpleClass aClass : getModel().getUmpleClasses())
    {
      GeneratedClass genClass = aClass.getGeneratedClass();
      generateSecondaryConstructorSignatures(genClass);
      addImports(aClass,genClass);
    }
    
    if( getModel().getTracer().getName().equals("log4j") )
    {
      addLog4jVarImport();
    }
    
    if( getModel().getTracer().getName().equals("javaapi") )
    {
      addJavaLogAPIImport();
    }
    
    if( getModel().getTracer().getName().equals("lttngjni") )
    {
      addJavaLttngJniImport();
    }
    
    addRelatedImports();
  }
  
  private void addLog4jVarImport() {
    for(UmpleClass umpleClass : getModel().getUmpleClasses())
    {
      Attribute loggerAttr = new Attribute("logger", "Logger", "const", "LogManager.getLogger("+umpleClass.getName()+".class)", false, umpleClass);
      loggerAttr.addComment( new Comment("log4j version 2") );
      loggerAttr.addComment( new Comment("requires jars (log4j-api-2.0.1.jar) and (log4j-core-2.0.1.jar)") );
      umpleClass.addAttribute(loggerAttr);
      umpleClass.addDepend(new Depend("org.apache.logging.log4j.LogManager"));
      umpleClass.addDepend(new Depend("org.apache.logging.log4j.Logger"));
    }
  }

  private void addJavaLogAPIImport(){
    for(UmpleClass umpleClass : getModel().getUmpleClasses())
    {
      Attribute loggerAttr = new Attribute("logger", "Logger", "const", "Logger.getLogger("+umpleClass.getName()+".class.getName())", false, umpleClass);
      umpleClass.addAttribute(loggerAttr);
      umpleClass.addDepend(new Depend("java.util.logging.*"));
    }
  }

  private void addJavaLttngJniImport(){
    for(UmpleClass umpleClass : getModel().getUmpleClasses())
    {
      CodeBlock cb = new CodeBlock("LTTngUst.init();");
      CodeInjection init = new CodeInjection("after","constructor", cb, umpleClass);
      init.setIsInternal(true);
      umpleClass.addCodeInjection(init);
      umpleClass.addDepend(new Depend("org.lttng.ust.LTTngUst"));
    }
  }

  public static String typeOf(String aType)
  {
    if (aType == null || aType.length() == 0)
    {
      return "String";
    }
    else if (aType.equals("Integer"))
    {
      return "int";
    }
    else if (aType.equals("Double"))
    {
      return "double";
    }
    else if(aType.equals("Float"))
    {
      return "float";
    }
    else if (aType.equals("Boolean"))
    {
      return "boolean";
    }
    else
    {
      return aType;
    }
  }

  public String nameOf(String name, boolean hasMultiple)
  {
    if (name == null)
    {
      return null;
    }
    else if (hasMultiple)
    {
      //String pluralName = getModel().getGlossary().getPlural(name);
      return "all" + StringFormatter.toPascalCase(name);
    }
    else
    {
      //String singularName = getModel().getGlossary().getSingular(name);
      return "a" + StringFormatter.toPascalCase(name);
    }
  }

  
  //------------------------
  // PRIVATE METHODS
  //------------------------
  
  private String getUpperCaseName(String name)
  {
    return StringFormatter.toPascalCase(name);
  }  

  private void injectIntoUnique(String method, String injection, String when, Attribute av, UmpleClass aClass)
  {
    String code = StringFormatter.format(injection,
      translate("type", av),
	    translate("parameterOne", av),
	    translate("parameterOld", av),
	    translate("getMethod", av),
	    translate("hasUniqueMethod", av),
	    translate("uniqueMap", av));
    CodeInjection set = new CodeInjection(when, method, code, aClass);
	  aClass.addCodeInjection(set);
  }
  
  private void injectIntoUniqueSet(String injection, String when, Attribute av, UmpleClass aClass)
  {
    injectIntoUnique(translate("setMethod", av), injection, when, av, aClass);
  }
  
  private void injectIntoUniqueDelete(String injection, String when, Attribute av, UmpleClass aClass)
  {
    injectIntoUnique("delete", injection, when, av, aClass);
  }
    
  private void prepare(UmpleClass aClass)
  {

    // here we will prepare the associationVariables
    if (aClass.getAssociations().length != 0)
    {
      for (AssociationVariable av : aClass.getAssociationVariables())
      {
        try
        {
          av.setIsSpecialization(aClass.getAssociation(aClass.indexOfAssociationVariable(av)).getIsSpecialization());
          if (!av.getIsSpecialization()) continue;
          Association relatedAssoc = aClass.getAssociation(aClass.indexOfAssociationVariable(av));
          av.setNeedsCommonCode( relatedAssoc.getEnd(av.getRelevantEnd()).getNeedsCommonCode());
          av.setNeedsSuperCode( relatedAssoc.getEnd(av.getRelevantEnd()).getNeedsSuperCode());         	 
          av.setMulChangedToOne( relatedAssoc.getEnd(av.getRelevantEnd()).getMulChangedToOne());
          av.setMulChangedToN( relatedAssoc.getEnd(av.getRelevantEnd()).getMulChangedToN());
          av.setReqSetCode( relatedAssoc.getEnd(av.getRelevantEnd()).getReqSetCode());
	  av.setScName( relatedAssoc.getEnd(av.getRelevantEnd()).getSuperClassName());
        } 
        catch ( IndexOutOfBoundsException wat )
        {
          // In this situation, the association was either symmetric reflexive or there was some
          // issue with traits (it appears that it is possible for traits to have more associationVariables
          // than they have associations). Either way, these are currently unsupported with respect to specializations.
        } 
      }
    }
    
    if (aClass.getGeneratedClass() != null)
    {
      GeneratedClass genClass = aClass.createGeneratedClass(getModel());
      generateConstructorSignature(genClass);
      //return;
    }
    else if (aClass.isRoot())
    {
      GeneratedClass genClass = aClass.createGeneratedClass(getModel());
      generateConstructorSignature(genClass);
    }
    else
    {
      UmpleClass parent = getModel().getUmpleClass(aClass.getExtendsClass().getName());
      prepare(parent);
      GeneratedClass genClass = aClass.createGeneratedClass(getModel());
      genClass.setParentClass(parent.getGeneratedClass());
      generateConstructorSignature(genClass);
    }

    for(Attribute av : aClass.getAttributes())
    {
      if (av.isImmutable() || aClass.getKey().isMember(av))
      {
        String code = StringFormatter.format("if (!{0}) { return false; }",translate("attributeCanSet",av));
        CodeInjection set = new CodeInjection("before",translate("setMethod",av) , code, aClass);
        set.setIsInternal(true);
        aClass.addCodeInjection(set);
      }
    
      if (aClass.getKey().isMember(av))
      {
        String code = StringFormatter.format("if (!{0}) { return false; }",translate("attributeCanSet",av));
        String methods = StringFormatter.format("{0},{1},{2},{3}",translate("addMethod",av),translate("removeMethod",av),translate("setManyMethod",av),translate("resetMethod",av));
        CodeInjection inject = new CodeInjection("before", methods, code, aClass);
        inject.setIsInternal(true);
        aClass.addCodeInjection(inject);
      }
      
      if (av.getIsUnique())
      {
        injectIntoUniqueSet(
          av.getType() + " {2} = {3}();" + "\n" + 
          "if ({4}({1})) {" + "\n" + 
          "  return wasSet;" + "\n" +
          "}", "before", av, aClass);
        injectIntoUniqueSet(
          "if ({2} != null) {" + "\n" +
          "  {5}.remove({2});" + "\n" +
          "}" + "\n" +
          "{5}.put({1}, this);", "after", av, aClass);
        injectIntoUniqueDelete(
          "{5}.remove({3}());", "before", av, aClass);
      }
    }
    for(AssociationVariable av : aClass.getAssociationVariables())
    {
      if (aClass.getKey().isMember(av))
      {
        String code = StringFormatter.format("if (!{0}) { return false; }",translate("associationCanSet",av));
        String methods = StringFormatter.format("{0},{1},{2},{3},{4}",translate("addMethod",av),translate("removeMethod",av),translate("setManyMethod",av),translate("setMethod",av),translate("resetMethod",av));
        CodeInjection inject = new CodeInjection("before",methods , code, aClass);
        inject.setIsInternal(true);
        aClass.addCodeInjection(inject);
      }
      
      if (av.isImmutable())
      {
        String code = StringFormatter.format("if (!{0}) { return false; }\n{0} = false;",translate("associationCanSet",av));
        String methods = StringFormatter.format("{0},{1}",translate("setManyMethod",av),translate("setMethod",av));
        CodeInjection set = new CodeInjection("before", methods, code, aClass);
        set.setIsInternal(true);
        aClass.addCodeInjection(set);
      }
      
      if (av.isMany())
      {
        String code = StringFormatter.format("if ({0}.contains({1})) { return false; }",translate("attributeMany",av),translate("parameterOne",av));
        CodeInjection set = new CodeInjection("before",translate("addMethod",av) , code, aClass);
        set.setIsInternal(true);
        aClass.addCodeInjection(set);
      }
      
      if(av.isSorted())
      { 
        String codeblock = 
          "{ |x, y| "+
                "x.get_"+av.getPriority() +"() <=> "+ 
                "y.get_"+ av.getPriority() +"()"+
                "}";
        String java_code = StringFormatter.format("if(wasAdded)\n    Collections.sort({0}, {0}Priority);\n",translate("attributeMany",av));
        String php_code = StringFormatter.format("if(wasAdded)\n    usort($this->{0}, $this->{0}Priority);\n",translate("attributeMany",av));
        String ruby_code = StringFormatter.format("@{0}.sort! "+codeblock+" if wasAdded\n",translate("attributeMany",av));
        String methods = translate("addMethod",av);
        CodeInjection set = new CodeInjection("after", methods,"", aClass);
        CodeBlock cb = new CodeBlock();
        cb.setCode("Java",java_code);
        cb.setCode("Php",php_code);
        cb.setCode("Ruby",ruby_code);
        set.setSnippet(cb);
        aClass.addCodeInjection(set);
      }
    }
    
    prepareConstraints(aClass);
    
    Map<String,String> lookups = new HashMap<String,String>();
    String executeMethods = "public static void handle(String message) { getInstance().addTrace(message); }\n";
    executeMethods += "public void reset() { getInstance().traces.clear(); }";
    lookups.put("packageName","cruise.util");
    lookups.put("dependTracer","cruise.util.{0}Tracer");
    lookups.put("stringTracer",executeMethods);
    lookups.put("startTime","(int)System.currentTimeMillis()");
    lookups.put("initial","handle(\"Time,Thread,UmpleFile,LineNumber,Class,Object,Operation,Name,Value\");");
    lookups.put("static","static{getInstance();}");
    lookups.put("consoleTracer", "public static void handle(String message)\n"+
                 "  {\n"+
                 "     System.err.println(message);\n"+
                 "  }");
    lookups.put("fileTracer","public static void handle(String message)\n"+
                 "  {\n"+
               "    FileOutputStream fout = null;\n"+
               "    try\n"+
               "    {\n"+
               "      // Open an output stream\n"+
               "      fout = new FileOutputStream (filename,true);\n"+
               "    }\n"+
               "    catch (IOException e)\n"+
               "    {\n"+
               "      System.err.println (\"Unable to write to file\");\n"+
               "      System.exit(-1);\n"+
               "    }\n"+
               "    // Write traced Item information\n"+
               "    new PrintStream(fout).println(message);\n"+
               "    try\n"+
               "    {\n"+
               "      // Close output stream\n"+
               "      fout.close();\n"+
               "    }\n"+
               "    catch (IOException e)\n"+
               "    {\n"+
               "      e.printStackTrace();\n"+
               "    }\n"+
               "  }");
    lookups.put("log4jConfigDefault", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"+
        "<Configuration>\n"+
        "  <Appenders>\n"+
        "    <Console name=\"console\" target=\"SYSTEM_OUT\">\n"+
        "      <PatternLayout pattern=\"%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n"+
        "    </Console>\n"+
        "    <File name=\"file\" fileName=\"logs/trace.log\" immediateFlush=\"false\" append=\"false\">\n"+
        "      <PatternLayout pattern=\"%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n"+
        "    </File>\n"+
        "  </Appenders>\n"+
        "  <Loggers>\n"+
        "    <Root level=\"info\">\n"+
        "      <AppenderRef ref=\"console\"/>\n"+
        "    </Root>\n"+
        "  </Loggers>\n"+
        "</Configuration>");
    lookups.put("log4jConfig", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"+
        "<Configuration>\n"+
        "  <Appenders>\n"+
        "    <Console name=\"console\" target=\"SYSTEM_OUT\">\n"+
        "      <PatternLayout pattern=\"%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n"+
        "    </Console>\n"+
        "    <File name=\"file\" fileName=\"logs/trace.log\" immediateFlush=\"false\" append=\"false\">\n"+
        "      <PatternLayout pattern=\"%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\n"+
        "    </File>\n"+
        "  </Appenders>\n"+
        "  <Loggers>\n"+
        "{0}"+
        "  </Loggers>\n"+
        "</Configuration>");
    lookups.put("log4jLogger",
        "    <Root level=\"{0}\">\n"+
        "{1}"+
        "    </Root>\n");
    lookups.put("log4jAppender",
        "      <AppenderRef ref=\"{0}\" level=\"{1}\"/>\n");
    lookups.put("handleMethod","public static void handle(String name, String value, String... extra)\n  {\n {0} \n  }");
    lookups.put("ifStatement","  if ( {0} )\n  {\n  {1}\n  }");
    lookups.put("callHandle","{0}.handle(name+\" = \"+value);");
    GeneratorHelper.prepareAllTracers(this,getModel(),aClass,lookups);
    //prepareAllTraces(this,getModel(),aClass,lookups);
    
    //Add  entry / exit methods to start and stop the timed events in Java
    boolean hasTimedEvents = false;
    boolean foundQueued = false;    
    boolean foundPooled = false;
    for (StateMachine sm : aClass.getStateMachines())
    {
      // Make sure state machine name is decapitalized
      if(Character.isUpperCase(sm.getName().charAt(0))){
        char firstLetter = Character.toLowerCase(sm.getName().charAt(0));
        String decapitalizedName = firstLetter + sm.getName().substring(1);
        sm.setName(decapitalizedName);
      }
      prepareNestedStatesFor(sm,null,0);
      hasTimedEvents = prepareTimedEvents(sm) || hasTimedEvents;
      if(sm.isQueued()){
        foundQueued = true;
      }
      if(sm.isPooled()){
        foundPooled = true;
      }
    }
        
    if (hasTimedEvents)
    {
      if(!foundQueued && !foundPooled)
      {
        aClass.addDepend(new Depend("java.util.*"));
      }
    } 
    
    boolean hasTimedEvent_NestedState = false;
    for (StateMachine sm : aClass.getStateMachines())
    {
      if(!sm.getNestedStateMachines().isEmpty())
      {
        for (StateMachine nsm : sm.getNestedStateMachines())
        {
          for (Event event : nsm.getEvents())
          {
            if(event.getIsTimer())
            {
              hasTimedEvent_NestedState =  true;
            }
          }
        }
      }
    }
     
   
    if (hasTimedEvent_NestedState)
    {
      if(!foundQueued && !foundPooled)
      {
        aClass.addDepend(new Depend("java.util.*"));
      }
    }            
  }
  
  
   
  private boolean prepareTimedEvents(StateMachine sm)
  {
    boolean hasTimedEvents = false;
    if(sm.getNestedStateMachines().isEmpty())
    {
      for (State s : sm.getStates())
      {
        for (Transition t : s.getTransitions())
        {
          Event e = t.getEvent();
          if (!e.getIsTimer())
          {
            continue;
          }
          hasTimedEvents = true;
          Action entryAction = new Action(StringFormatter.format("{0}();",translate("eventStartMethod",e)));
          entryAction.setActionType("entry");
        
          Action exitAction = new Action(StringFormatter.format("{0}();",translate("eventStopMethod",e)));
          exitAction.setActionType("exit");

          t.getFromState().addAction(entryAction);
          t.getFromState().addAction(exitAction);
        }
      }
    } 
    else if(!sm.getNestedStateMachines().isEmpty())
    {
      for (StateMachine nsm : sm.getNestedStateMachines())
      {
        for (State s : nsm.getStates())
        {
          for (Transition t : s.getTransitions())
          {
            Event e = t.getEvent();
            if (!e.getIsTimer())
            {
              continue;
            }
            hasTimedEvents = true;
            Action entryAction = new Action(StringFormatter.format("{0}();",translate("eventStartMethod",e)));
            entryAction.setActionType("entry");
        
            Action exitAction = new Action(StringFormatter.format("{0}();",translate("eventStopMethod",e)));
            exitAction.setActionType("exit");

            t.getFromState().addAction(entryAction);
            t.getFromState().addAction(exitAction);
          }
        }
      }
    }
    return hasTimedEvents;
  }
  
  private void prepareDoActivityThread(StateMachine sm)
  {
    for(State state : sm.getStates())
    {
      for (Activity activity : state.getActivities())
      {
          String code = StringFormatter.format("if ({0} != null) { {0}.interrupt(); }",translate("doActivityThread",activity));
          Action interruptAction = new Action(code);
          interruptAction.setIsInternal(true);
          interruptAction.setActionType("exit");
          state.addAction(interruptAction);

          String entryCode = StringFormatter.format("{0} = new DoActivityThread(this,\"{1}\");",translate("doActivityThread",activity),translate("doActivityMethod",activity));
          Action entryAction = new Action(entryCode);
          entryAction.setIsInternal(true);
          entryAction.setActionType("entry");
          state.addAction(entryAction);
      }
    }
  }
  
  private void prepareFinalStateFor(StateMachine sm, StateMachine parentSm)
  {
    Map<String,String> lookups = new HashMap<String,String>();
    
    String deleteActionCode;
    deleteActionCode = StringFormatter.format("{0}();",translate("deleteMethod",sm.getUmpleClass()));

    lookups.put("deleteActionCode",deleteActionCode);
    GeneratorHelper.prepareFinalState(sm,lookups);
  }
  
  private void prepareNestedStatesFor(StateMachine sm, StateMachine parentSm, int concurrentIndex)
  {
    prepareFinalStateFor(sm,parentSm); 
    prepareDoActivityThread(sm); 
    if (sm.getParentState() != null && sm.getStartState() != null)
    {
      State parentState = sm.getParentState();
      while(parentState.getStateMachine().getParentState() != null)
      {
        parentState = parentState.getStateMachine().getParentState();
      }
      Map<String,String> lookups = new HashMap<String,String>();
      lookups.put("entryEventName",translate("enterMethod",parentState));
      lookups.put("exitEventName",translate("exitMethod",parentState));
      lookups.put("parentEntryActionCode",StringFormatter.format("if ({0} == {1}.{2}) { {3}({1}.{4}); }"
          ,translate("stateMachineOne",sm)
          ,translate("type",sm)
          ,translate("stateNull",sm)
          ,translate("setMethod",sm)
          ,translate("stateOne",sm.getStartState()))
      );
      lookups.put("parentExitActionCode",StringFormatter.format("{0}();",translate("exitMethod",parentState)));
      GeneratorHelper.prepareNestedStateMachine(sm,concurrentIndex,lookups);    
    }

    for (State s : sm.getStates())
    {
      int nestedSmIndex = 0;
      for (StateMachine nestedSm : s.getNestedStateMachines())
      {
        prepareNestedStatesFor(nestedSm,sm,nestedSmIndex);
        nestedSmIndex += 1;
      }
    }
    
    Map<String,String> lookups = new HashMap<String,String>();
    lookups.put("callEvent","{0}();");
    GeneratorHelper.prepareAutoTransitions(sm,this,lookups);
  }
  
  private void generateConstructorSignature(GeneratedClass genClass)
  {
    StringBuffer signature = new StringBuffer();
    StringBuffer signatureCaller = new StringBuffer();
    
    UmpleClass uClass = genClass.getUClass();
    
    for (Attribute av : uClass.getAttributes()) 
    {
      if (av.getIsAutounique() || av.getIsList() || "defaulted".equals(av.getModifier()) || av.getIsLazy() || ( av.getValue() != null && ! av.getModifier().equals("fixml")))
      {
        continue;
      }

      if (signature.length() > 0) 
      {
        signature.append(", ");
        signatureCaller.append(", ");
      }
        
      signature.append(StringFormatter.format("{0} {1}",typeOf(av),nameOf(av)));
      signatureCaller.append(nameOf(av));      
    }

    // This is the list of association variables that might use variable arguments in the constructor
    List<AssociationVariable> manyConstructorAVs = new ArrayList<AssociationVariable>();
    
    for (AssociationVariable av : uClass.getAssociationVariables()) 
    {
      if (!associationShouldAppearInConstructor(av))
      {
        continue;
      }
      if (av.isMany())
      {
        manyConstructorAVs.add(av);
        continue;
      }
      
      if (signature.length() > 0) 
      {
        signature.append(", ");
        signatureCaller.append(", ");
      }
      
      signature.append(StringFormatter.format("{0} {1}",typeOf(av),nameOf(av)));
      signatureCaller.append(nameOf(av));      
    }
    
    // Insert the parent class's contructor signature, with attention given to special
    // cases where the signature is modified if variable arguments are present.
    
    boolean parentConstructorContainsMany = false;   
    if (uClass.getExtendsClass() != null) 
    {
      GeneratedClass parent = genClass.getParentClass();
      String parentSignature = parent.getLookup("constructorSignature");
      String parentSignatureCaller = parent.getLookup("constructorSignature_caller");
      
      String parentSignatureToPrepend = "";
      String parentSignatureCallerToPrepend = "";
    
      if ((signature.length() == 0) && (manyConstructorAVs.size() == 0))
      {
        // if the child class will add nothing to the signature
        signature.append(parentSignature);
        signatureCaller.append(parentSignatureCaller);
      }
      else if (parentSignature.contains("..."))
      {
        if (manyConstructorAVs.size() > 0)
        {
          // if multiple associations in the constructor could use variable arguments, switch to using arrays.
          parentConstructorContainsMany = true;
          parentSignatureToPrepend = parentSignature.replace("...", "[]");
          parentSignatureCallerToPrepend = parentSignatureCaller;
        }
        else
        {
          //else push the variable argument parameter to the end of the constructor. 
               
          int idx = Math.max(parentSignature.lastIndexOf(","),0);
          if ((signature.length() > 0) && (idx == 0))
          {
            // if there was no comma in the parent signature, compensate.
            signature.append(", ");
            signatureCaller.append(", ");
          }   
          signature.append(parentSignature.substring(idx));
          parentSignatureToPrepend = parentSignature.substring(0, idx);
          
          idx = Math.max(parentSignatureCaller.lastIndexOf(","),0);
          signatureCaller.append(parentSignatureCaller.substring(idx));
          parentSignatureCallerToPrepend = parentSignatureCaller.substring(0, idx);
        }
      }
      else 
      {
        // else simply prepend the parent signature, as-is, to the child signature.
        parentSignatureToPrepend = parentSignature;
        parentSignatureCallerToPrepend = parentSignatureCaller;
        
        // also, check if the presence of arrays in the parent signature signals that the child
        // signature should use arrays for arguments that could otherwise use variable arguments.
        if (parentSignature.contains("[]"))
        {
          parentConstructorContainsMany = true;
        }
      }
      
      // prepend the parent signature to the child signature
      if (parentSignatureToPrepend.length() > 0)
      {
        if (signature.length() > 0)
        {
          signature.insert(0, parentSignatureToPrepend + ", ");
          signatureCaller.insert(0, parentSignatureCallerToPrepend + ", ");
        }
        else
        {
          signature.append(parentSignatureToPrepend);
          signatureCaller.append(parentSignatureCallerToPrepend);
        }
      }
    }
    
    // finally, append constructor parameter(s) that could be variable arguments or arrays depending on circumstances
    for (AssociationVariable manyAV : manyConstructorAVs)
    {
      if (signature.length() > 0) 
      {
        signature.append(", ");
        signatureCaller.append(", ");
      }
      String typeModifier = ((manyConstructorAVs.size() > 1) || (parentConstructorContainsMany)) ? "[]" : "...";
      signature.append(StringFormatter.format("{0}{1} {2}",typeOf(manyAV),typeModifier,nameOf(manyAV)));
      signatureCaller.append(nameOf(manyAV));     
    }

    genClass.setLookup("constructorSignature", signature.toString());
    genClass.setLookup("constructorSignature_caller", signatureCaller.toString());
  }
  
  
  private boolean associationShouldAppearInConstructor(AssociationVariable av)
  {
    boolean shouldAppear = true;
    AssociationVariable relatedAv = av.getRelatedAssociation();
    
    if ((av.getMultiplicity().getLowerBound() == 0 && !av.isImmutable()) || !av.getIsNavigable())
    {
      shouldAppear = false;
    }   
    else if (relatedAv.getIsNavigable())
    {
      if (av.isMandatoryMany() && relatedAv.isMandatory())
      {
        shouldAppear = false;
      }
      else if ((av.isMN() || av.isN()) && relatedAv.isOptionalN())
      {
        shouldAppear = false;
      }
      else if (av.getIsSpecialization())
      {
        shouldAppear = false;
      }
    }
    return shouldAppear;
  }
  
  private void generateSecondaryConstructorSignatures(GeneratedClass genClass)
  {
    UmpleClass uClass = genClass.getUClass();
    
    String mandatorySignature = genClass.getLookup("constructorSignature");
    
    for (AssociationVariable av : uClass.getAssociationVariables()) 
    {
      AssociationVariable relatedAv = av.getRelatedAssociation();
      if (av.isOnlyOne() && relatedAv.isOnlyOne() && av.getIsNavigable() && relatedAv.getIsNavigable())
      {
        UmpleClass relatedClass = getModel().getUmpleClass(av.getType());
        GeneratedClass relatedGen = relatedClass.getGeneratedClass();
        
        String selfParameter = StringFormatter.format("{0} {1}",typeOf(relatedAv),nameOf(relatedAv));
        String selfFor = StringFormatter.format("For{0}",av.getUpperCaseName());
        String newParameters = relatedGen.getLookup("constructorSignature");
        newParameters = StringFormatter.replaceParameter(newParameters, selfParameter, null);
        newParameters = StringFormatter.appendParameter(newParameters, selfFor);

        String relatedParameter = StringFormatter.format("{0} {1}",typeOf(av),nameOf(av));
        
        mandatorySignature = StringFormatter.replaceParameter(mandatorySignature, relatedParameter, newParameters);
        genClass.setLookup("constructorSignature_mandatory", mandatorySignature);
        
        String relatedFor = StringFormatter.format("For{0}",relatedAv.getUpperCaseName());
        String relatedCaller = genClass.getLookup("constructorSignature_caller");
        String relatedCallerParameter = nameOf(av);
        String mandatorySignatureCaller = StringFormatter.replaceParameter(relatedCaller, relatedCallerParameter, "_THIS_");
        mandatorySignatureCaller = StringFormatter.appendParameter(mandatorySignatureCaller, relatedFor);
        mandatorySignatureCaller = StringFormatter.replaceParameter(mandatorySignatureCaller, "_THIS_" + relatedFor, "this");
        
        String mandatoryCallerId = "constructorSignature_mandatory_" + relatedAv.getName();
        relatedGen.setLookup(mandatoryCallerId, mandatorySignatureCaller);
      }
    }
  }
  
  private void addRelatedImports()
  {
    for (UmpleClass aClass : getModel().getUmpleClasses())
    {
      GeneratedClass genClass = aClass.getGeneratedClass();
      
      if (aClass.getExtendsClass() != null)
      {
        if (!aClass.getPackageName().equals(aClass.getExtendsClass().getPackageName()))
        {
          genClass.addMultiLookup("import", aClass.getExtendsClass().getPackageName() + ".*");  
        }
        
        //add related imports in multilevel
        UmpleClass rootUClass = aClass;
		while (!rootUClass.isRoot()) 
		{
			addImports(rootUClass.getExtendsClass(), genClass);
			rootUClass = rootUClass.getExtendsClass();
		}
      }
      
      for (AssociationVariable av : aClass.getAssociationVariables()) 
      {
        if (!av.getIsNavigable())
        {
          continue;
        }
        
        AssociationVariable relatedAssociation = av.getRelatedAssociation();
        if (relatedAssociation.isOnlyOne())
        { 
          UmpleClass relatedClass = getModel().getUmpleClass(av.getType());
          while (relatedClass != null)
          {
            addAttributeImports(relatedClass,genClass);
            relatedClass = relatedClass.getExtendsClass();
          }
        }
      }
    }
  }
  
  private void addAttributeImports(UmpleClass aClass, GeneratedClass genClass)
  {
    String timeImport = "java.sql.Time";
    String dateImport = "java.sql.Date";
    String utilImport = "java.util.*";
    
    for (Attribute av : aClass.getAttributes()) 
    {
      
      if ("Time".equals(av.getType()))
      {
        genClass.addMultiLookup("import", timeImport);
      }
      else if ("Date".equals(av.getType()))
      {
        genClass.addMultiLookup("import", dateImport);
      }
      
      if (av.getIsList() || av.getIsUnique())
      {
        genClass.addMultiLookup("import", utilImport);
      }
    }
  }
  
  private void addImports(UmpleClass aClass, GeneratedClass genClass)
  {
    addAttributeImports(aClass,genClass);
      
    for (AssociationVariable av : aClass.getAssociationVariables()) 
    {
      if (!av.getIsNavigable())
      {
        continue;
      }
      
      if (av.isMany())
      {
        genClass.addMultiLookup("import", "java.util.*");
      }
    }
    
    for (String namespace : aClass.getNamespaces())
    {
      if (!namespace.equals(aClass.getPackageName()))
      {
        genClass.addMultiLookup("import", namespace + ".*");
      }
    }

    for (StateMachine sm : aClass.getStateMachines())
    {
      if (sm.isQueued() || sm.isPooled())
      {
        genClass.addMultiLookup("import", "java.util.*");
        genClass.addMultiLookup("import", "java.lang.Thread");
      }
    }
  }
  
  private String nameOf(Attribute av)
  {
    return nameOf(av.getName(),av.getIsList());
  }
  
  private String nameOf(AssociationVariable av)
  {
    boolean hasMultiple = av.isMany();
    return nameOf(av.getName(),hasMultiple);
  }
  
  private static String typeOf(UmpleVariable var)
  {
    String aType = var.getType();
    return typeOf(aType);
  }
  
  public void writeFile(UmpleElement aClass) throws IOException
  {
    ILang language = getLanguageFor(aClass);
    
    String path = StringFormatter.addPathOrAbsolute( 
                  getModel().getUmpleFile().getPath(), 
                            getOutput()) + 
                            aClass.getPackageName().replace(".", File.separator);
    
    String filename = path + File.separator + aClass.getName() + ".java";
    File file = new File(path);
    file.mkdirs();

    BufferedWriter bw = new BufferedWriter(new FileWriter(filename));
    String contents = language.getCode(getModel(), aClass);
    getModel().getGeneratedCode().put(aClass.getName(),contents);
    try
    {
      bw.write(contents);
      bw.flush();
    }
    finally
    {
      bw.close();
    }
    if (aClass instanceof UmpleClass)
    {
      StringBuilder exceptionBuilder = new StringBuilder();
      for(String key:((JavaClassGenerator)language).uncaughtExceptions.keySet())
      {
        exceptionBuilder.append(((JavaClassGenerator)language).uncaughtExceptions.get(key).toString()+"\n");
      }
      String exception = exceptionBuilder.toString();
      uncaughtExceptions.append(exception);
      if(((UmpleClass)aClass).getHasMainMethod())
      {
        mainClasses.add((UmpleClass)aClass);
      }
    }
  }

  public void writeUncaughtExceptionFile(UmpleClass aClass)
  {
    try {
   
    ILang language = getLanguageFor(aClass);
    
    String path = StringFormatter.addPathOrAbsolute( 
                  getModel().getUmpleFile().getPath(), 
                            getOutput()) + 
                            aClass.getPackageName().replace(".", File.separator);
    
    String filename = path + File.separator + aClass.getName() + ".java";
    File file = new File(path);
    file.mkdirs();

    BufferedWriter bw = new BufferedWriter(new FileWriter(filename,true));
    String contents = new JavaClassGenerator().getExceptionHandler(uncaughtExceptions.toString());
    getModel().getGeneratedCode().put(aClass.getName(),getModel().getGeneratedCode().get(aClass.getName())+contents);
    try
    {
      bw.write(contents);
      bw.flush();
    }
    finally
    {
      bw.close();
    }
    } catch(Exception e){ e.printStackTrace(); }
  }  

  public void initializeLangaugeBasedVariables() {
    UmpleToPrimitiveMap.put("Integer","int");
    UmpleToPrimitiveMap.put("Boolean","boolean");
    UmpleToPrimitiveMap.put("Double","double");
    UmpleToPrimitiveMap.put("Float","float");
    UmpleToPrimitiveMap.put("String","String");
    //
    TraceLookupMap.put("concatinator","+");
    TraceLookupMap.put("accessor","");
    TraceLookupMap.put("indent","    ");
    TraceLookupMap.put("template","{0}Tracer.handle( {1} );");
    TraceLookupMap.put("templatelog4j","logger.{0}( {1} );");
    TraceLookupMap.put("templatelttng","LTTngUst.{0}( {1} );");
    TraceLookupMap.put("timestamp","System.currentTimeMillis()");
    TraceLookupMap.put("identifier","System.identityHashCode({0})");
    TraceLookupMap.put("thread","Thread.currentThread().getId()");
    TraceLookupMap.put("self","this");
    TraceLookupMap.put("increment","{0}++;");
    TraceLookupMap.put("formatnonprimitive",".toString().replace(\"\\n\",\"\").replace(\",\",\";\")");
    //
    ConstraintLookupMap.put("in==","{0}.equals(\"{1}\")");
    ConstraintLookupMap.put("in!=","!{0}.equals(\"{1}\")");
    ConstraintLookupMap.put("object==","{0}.equals({1})");
    ConstraintLookupMap.put("object!=","!{0}.equals({1})");
    ConstraintLookupMap.put("accessor","");
    ConstraintLookupMap.put("paramaccessor","");
    ConstraintLookupMap.put("exception","throw new RuntimeException(\"Please provide a valid {0}\");");
    ConstraintLookupMap.put("ifstatement","if ({0})\n{");
    ConstraintLookupMap.put("end","}");
    ConstraintLookupMap.put("concatenate","{0}+{1}");
    ConstraintLookupMap.put("initialise","new {0}");
    ConstraintLookupMap.put("has","{0}.contains({1})");
    ConstraintLookupMap.put("hasAll","{0}.contains({1})");
    ConstraintLookupMap.put("cardinality==","{0}=={1}");
    ConstraintLookupMap.put("cardinality!=","{0}!={1}");
    ConstraintLookupMap.put("cardinality>=","{0}>={1}");
    ConstraintLookupMap.put("cardinality<=","{0}<={1}");
    ConstraintLookupMap.put("cardinality>","{0}>{1}");
    ConstraintLookupMap.put("cardinality<","{0}<{1}");
  }
}
