/*

Copyright: All contributers to the Umple Project

This file is made available subject to the open source license found at:
https://umple.org/license

Command line tools: To compile Umple files, or to do diffs

*/

namespace cruise.umple;

/**
 * Config is the parsed command line information for UmpleConsole.
 */
class UmpleConsoleConfig {
  depend java.util.*;
  depend java.util.stream.*;
  depend joptsimple.*;
  depend java.io.*;
  depend java.nio.file.Files;
  depend java.nio.file.Paths;
  depend java.util.regex.*;

  // See function initializeOptionParser() for the setup of the options
  defaulted boolean version = false; // option to print version only
  defaulted boolean help = false; // option to output help only
  defaulted boolean performance = false; // option to measure performance
  defaulted boolean beQuiet = false; // option q to be quiet
  defaulted boolean warningIgnore = false; // option w to ignore a warning number in filename
  defaulted boolean useExec = false; // option x to use slower but more reliable exec java compiler
  defaulted boolean exitOnFirstFailure = false; // option e to exit on first failure with the -f option 

  internal Optional<String> generate   = Optional.empty(); // option g to specify what to generate
  internal Optional<String> umpleDirect   = Optional.empty(); // option u to specify umple code directly
  defaulted boolean override           = false;
  defaulted boolean removePrevious     = false;  
  internal Optional<String> path       = Optional.empty(); // place to put output, otherwise in current directory
  internal Optional<String> compile    = Optional.empty(); // option c to specify that compilation should happen
  internal Optional<String> importFile = Optional.empty(); // option i to only import an xmi
  internal Optional<String> testUmpFilesFile = Optional.empty(); // option f file with sets of files to process 
  internal List<String[]> allLinesOfFilesToTest = null;
  internal List<String> suboptions     = Collections.<String>emptyList();

  String umpleFile; // first and maybe only umple file to compile, the main constructor argument
  String[] linkedFiles; // other umple files to compile

  UmpleConsoleConfig(OptionSet optSet) {
    // The first nonOptionArgument becomes the main file to process
    this(optSet.nonOptionArguments().size() > 0 ? optSet.nonOptionArguments().get(0) : null);

    this.version    = optSet.has("v");
    this.help       = optSet.has("help");
    this.performance = optSet.has("performance");
    this.useExec    = optSet.has("x");
    this.exitOnFirstFailure = optSet.has("e");
    this.beQuiet    = optSet.has("quiet");    
    this.warningIgnore    = optSet.has("warningignore");    
    this.importFile = Optional.ofNullable((String)optSet.valueOf("import"));
    this.generate   = Optional.ofNullable((String)optSet.valueOf("generate"));
    this.umpleDirect   = Optional.ofNullable((String)optSet.valueOf("umple"));    
    this.override   = optSet.has("override");
    this.removePrevious = optSet.has("removeprevious");
    this.path       = Optional.ofNullable((String)optSet.valueOf("path"));
    this.testUmpFilesFile = Optional.ofNullable((String)optSet.valueOf("file"));
    
    // Other files to process
    final List<String> files = optSet.nonOptionArguments();
    this.linkedFiles = (files.size() > 1 ? files.subList(1, files.size()) : Collections.<String>emptyList());

    this.suboptions = optSet.valuesOf("suboption").stream()
      .map(o -> (String)o)
      .collect(Collectors.toList());

    // compile takes a bit more logic..
    this.compile = Optional.ofNullable((String)optSet.valueOf("c"));
    
    // Open and read any file containing other files to process for testing
    if (testUmpFilesFile.isPresent())
    {
      String fileOfFiles = testUmpFilesFile.get();
      try {
        List<String> allLines = Files.readAllLines(Paths.get(fileOfFiles));
        allLinesOfFilesToTest = new ArrayList<String[]>();
        for(String aLine: allLines) {
          // Split the line based on spaces, but converting those in quotes into code
          List<String> listOfFilesThisLine = new ArrayList<String>();
          Matcher m = Pattern.compile("([^\']\\S*|\'.+?\')\\s*").matcher(aLine);
          while (m.find()) {
            String foundString = m.group(1);
            // foundString is either a file or (if second and subsequent) a single quoted string
            if(foundString.startsWith("\'")) {
              // We have a program -- convert
              foundString="__UMPLE"+
                Base64.getEncoder()
                .encodeToString(foundString.substring(1,foundString.length()-1).getBytes());
            }
            else {
              int lastSlash = foundString.lastIndexOf(File.separator);
              String umpFileRoot=foundString;
              if (lastSlash != -1) {
                umpFileRoot=foundString.substring(lastSlash+1);
              } 
              if(umpFileRoot.startsWith("W") && warningIgnore) {
                // Potential to ignore the warning
                Matcher m2 = Pattern.compile("W(\\d+)").matcher(umpFileRoot);
                if(m2.find()) {
                  String foundWarningNumber=m2.group().substring(1);
                  String supressWarningCode="strictness ignore "+foundWarningNumber+";";
                  listOfFilesThisLine.add(foundString); // Add file, then below add warning suppress
                  foundString="__UMPLE"+
                    Base64.getEncoder().encodeToString(supressWarningCode.getBytes());
                }
              }
            }
            listOfFilesThisLine.add(foundString);
          }
          //allLinesOfFilesToTest.add(aLine.split(" "));
          allLinesOfFilesToTest
            .add(listOfFilesThisLine.toArray(new String[listOfFilesThisLine.size()]));
        }
      }
      catch  (IOException e) {
        System.out.println("File with files "+fileOfFiles+" from -f option cannot be opened. Ignoring");
      }
    }
  }

  public void setLinkedFiles(List<String> newLinkedFiles) {
    this.linkedFiles=newLinkedFiles;
  }

  public List<File> getLinkedFilesAsFile() {
    return this.linkedFiles.stream().map(p -> new File(p)).collect(Collectors.toList());
  }

 // this method returns mixset names that appear as arguments  
 public List<String> getLinkedMixsetAsString() {
    return this.linkedFiles.stream().filter(m-> ! m.endsWith(".ump")).collect(Collectors.toList());
  }
  public Optional<String> getGenerate() {
    return this.generate;
  }

  public void setGenerate(String generate) {
    this.generate = Optional.of(generate);
  }

  public Optional<String> getUmpleDirect() {
    return this.umpleDirect;
  }

  public Optional<String> getCompile() {
    return this.compile;
  }

  public void setCompile(String compile) {
    this.compile = Optional.of(compile);
  }

  public void setImportFile(String importFile) {
    this.importFile = Optional.of(importFile);
  }

  public Optional<String> getImportFile() {
    return this.importFile;
  }

  public void setTestUmpFilesFile(String testUmpFilesFile) {
    this.testUmpFilesFile = Optional.of(testUmpFilesFile);
  }

  public Optional<String> getTestUmpFilesFile() {
    return this.testUmpFilesFile;
  }
  
  public List<String[]> getAllLinesOfFilesToTest() {
    return this.allLinesOfFilesToTest;
  }

  public void setPath(String path) {
    this.path = Optional.of(path);
  }

  public Optional<String> getPath() {
    return this.path;
  }

  public List<String> getSuboptions() {
    return this.suboptions;
  }

  public void setSuboptions(List<String> suboptions) {
    this.suboptions = suboptions;
  }

  public void addSuboption(String suboption) {
    this.suboptions.add(suboption);
  }
}

/*
 * Main program for the command line Umple compiler
 * Run java -jar umple.jar --help for details 
 * Takes an umple file as an argument, which can in turn use (include) other
 */
class UmpleConsoleMain
{
  depend cruise.umple.compiler.*;
  depend cruise.umple.compiler.exceptions.*;
  depend java.util.*;
  depend joptsimple.*;
  depend java.io.*;
  depend java.text.DecimalFormat;

  UmpleConsoleConfig cfg;

  static OptionParser optparser = initializeOptionParser();

  //startTime repersents model run start time while endTime represents end time
  Double startTime = 0.0;
  Double endTime = 0.0;
  
  /**
   * Create a main console. If the args are invalid, an IllegalStateException is thrown. 
   * @throws IllegalStateException If invalid arguments are passed and joptsimple fails to parse. 
   */
  UmpleConsoleMain(String[] args) {
    optparser = initializeOptionParser();

    OptionSet optset = optParse(args);
    if (optset == null) {
      throw new IllegalStateException("Illegal arguments were passed, check usage.");
    }
    
    this.cfg = new UmpleConsoleConfig(optset);
  }

  public int runConsole() {
    // Check for options like help, version and import that don't compile arguments 
    if (preModelOptionProcess())
    {
      return 0;
    }

    String filename = "dummy__.ump"; // used when we may not want to read any file
    if (cfg.getUmpleFile() == null || "".equals(cfg.getUmpleFile()))
    {
      // We have no filename
      if(!cfg.getTestUmpFilesFile().isPresent() && !cfg.getUmpleDirect().isPresent()) {
        System.out.println("Please specify an umple_file to process or use the -f or -u options");
        printUsage();
        return 1;
      }
      else if (!cfg.getUmpleDirect().isPresent()) {
        // Will use -f option for files to process
        return 0;
      }
    }
    else {
      filename = cfg.getUmpleFile();
      if(!cfg.getBeQuiet()) {
        System.out.println("Processing -> " + filename);
      }
    }

    final UmpleFile umpleFile = new UmpleFile(filename);
    //this loop is used to add linked umple files and to show names of them.
    cfg.getLinkedFilesAsFile().stream()
        .filter(f->f.getName().endsWith(".ump"))
        .map(File::getPath)
        .forEach(umpleFile::addLinkedFiles);
    //this loop is used to add mixset names as liked umple files.
    cfg.getLinkedMixsetAsString().stream()
        .forEach(umpleFile::addLinkedFiles);
    
    // This adds any special extra statement as a linked file (not really a file but ...)
    if (cfg.getUmpleDirect().isPresent()) {
      umpleFile.addLinkedFiles("__UMPLE"+
        Base64.getEncoder().encodeToString(cfg.getUmpleDirect().orElse(null).getBytes()));
    }
       
    final UmpleModel model = new UmpleModel(umpleFile);

    // Process generators into the model
    if (postModelOptionProcess(model)) {
      // Currently the above always returns false
      return 0;
    }

    try {
      try {
        startTime = System.currentTimeMillis()/1000.0;  
        model.run();
        endTime = System.currentTimeMillis()/1000.0;  

      } catch (UmpleCompilerException e) {
        System.err.print(e.getMessage());
        if (!model.isShouldGenerate())
        {
          return -1;
        }
      }

      // Compile success means the output was generated
      boolean compileSuccess = model.getLastResult().getWasSuccess();

      // The "c" option causes an attempt to compile the resulting base language
      // code.
      if (compileSuccess && cfg.getCompile().isPresent())
      {
        if(model.isSkipcompile()) {
          if(!cfg.getBeQuiet()) {
            System.out.println("Skipping compilation of generated code due to @@@skipcompile in a comment.");
          }
        }
        else {
          for (GenerateTarget gt : model.getGenerates()) {
            String generatorCodeToCompile = gt.getLanguage();
          
            if(generatorCodeToCompile.equals("Java") && model.isSkipjavacompile()) {
              if(!cfg.getBeQuiet()) {
                System.out.println("Skipping compilation of Java due to @@@skipjavacompile in a comment.");
              }
              continue;
            }

            if(generatorCodeToCompile.equals("Php") && model.isSkipphpcompile()) {
              if(!cfg.getBeQuiet()) {
                System.out.println("Skipping compilation of Php due to @@@skipphpcompile in a comment.");
              }
              continue;
            }
          
             if(generatorCodeToCompile.equals("Python") && model.isSkippythoncompile()) {
                 if(!cfg.getBeQuiet()) {
                   System.out.println("Skipping compilation of python due to @@@skippythoncompile in a comment.");
                 }
                 continue;
               }

            if (generatorCodeToCompile.equals("Java") || generatorCodeToCompile.equals("Php") || generatorCodeToCompile.equals("Python")) {
              compileSuccess = CodeCompiler.compile(model, generatorCodeToCompile,cfg.getUseExec(), cfg.getBeQuiet(), cfg.getCompile().get(), null);
            }
            else if (generatorCodeToCompile.startsWith("Gv")) {
              compileSuccess = CodeCompiler.genDotDiagram(model, gt, cfg.getBeQuiet(), "svg");
            }
          }
        }
      }
      
       // Get the performance execution.
       // Print out performance test result.     
        if(cfg.getPerformance())
         {
        
           DecimalFormat df=new DecimalFormat("0.000");
        
           System.out.println("Performance Metrics:");
           System.out.println("--> Total Execution Time: " + df.format((endTime -startTime)) +" s");
           System.out.println("--> Parsing Time: " + df.format((model.getParsingTime() -startTime))+" s");
           for (String key : model. getHashMap().keySet()) 
           {
             Double generateTime = Double.parseDouble(model. getHashMap().get(key));
             
             System.out.println("--> Generating Target Language " + key + " time: "+df.format(generateTime)+" s");
           }                           
         }

      String successWord = compileSuccess ? "Success! " : "";
      
      // if failed but we are being quiet, we have to inform what we failed on
      if(!compileSuccess && cfg.getBeQuiet()) {
        System.out.println("Was attempting to process "+filename);
      }
      
      if(compileSuccess && !cfg.getBeQuiet()) {
        for (String key : model. getHashMap().keySet()) {
          System.out.println("  Finished generating "+key);
          if(key.compareTo("Java")==0) {
            for (UmpleClass mainClass: CodeCompiler.getMainClasses(model)) {
              System.out.println("  Main method found. Run java "+mainClass.getName());
            }
          }
        }
      }  
      
      // Output Processed either if not successful or not asking to be quiet
      if(!compileSuccess || !cfg.getBeQuiet()) {
        System.out.println(successWord + "Processed "+ cfg.getUmpleFile() + ".");
        cfg.getLinkedFilesAsFile().stream()
          .filter(File::exists)
          .forEach(f -> System.out.println(successWord + "Processed "+ f.getPath() + "."));
      }
      
      return (compileSuccess ? 0 : 1); 
    }
    catch(Exception ex)
    {
      System.err.println("Umple compiler error. Stack trace follows");
      cruise.umple.util.ExceptionDumper.dumpCompilerError(ex);
      return -1;
    }
  }

  public static void main(String[] args)
  {
    UmpleConsoleMain console = null;
    try {
      console = new UmpleConsoleMain(args);
    }
    catch (Exception e) {   
     System.err.println(e.getMessage());
     return;
    }

    // Run the compilation for the main command line files and mixsets
    // Result is 1 if failed compile, -1 if compiler crashed
    int result = console.runConsole();
    if (result != 0) {
      System.exit(result);
    }
    
    // If there are any files and mixsets specified by the -f option, then try those
    UmpleConsoleConfig cfg = console.getCfg();
    if(cfg.getAllLinesOfFilesToTest() != null) {
      int finalResult = 0;
      String failedLines ="";
      int successCases = 0;
      for(String[] fileList : cfg.getAllLinesOfFilesToTest()) {
        // Change the configuration to have the new lines
        if(fileList == null || fileList.length == 0) {
          System.out.println("One of the lines in the file specified by -f is empty. Should be a list of files or mixsets");
        }
        else {
          cfg.setUmpleFile(fileList[0]);
          cfg.setLinkedFiles(fileList.length > 1 ? (Arrays.asList(fileList)).subList(1, fileList.length) : Collections.<String>emptyList());
          result = console.runConsole();
          if (result != 0) {
            if (cfg.getExitOnFirstFailure()) {
              System.exit(result);
            }
            else {
              finalResult = result;
              for (String aFileInList : fileList) {
                failedLines += " "+aFileInList;
              }
              failedLines +="\n";
            }
          }
          else successCases++;     
        }
      }
      System.out.println("Number of successful compilations from umple -f option: "+successCases);
      if(finalResult != 0) {
        System.out.print("See the above log for the following Umple Java generation and compilation cases which failed:\n"+failedLines);
        System.exit (finalResult);
      }
    }
  }
    
  private void generateUmple(String filename)
  {
    boolean isSuccess = false;
    try
    {
      UmpleImportModel umple;
      if (filename.endsWith(".scxml")) {
        ScxmlImportHandler handler = new ScxmlImportHandler();
        umple = handler.readDataFromXML(filename);
      } else if (filename.endsWith(".uml")) {
        PapyrusImportHandler handler = new PapyrusImportHandler();
        umple = handler.readDataFromXML(filename);
      } else {
        EcoreImportHandler handler = new EcoreImportHandler();
        umple = handler.readDataFromXML(filename);
      }
      isSuccess = umple.generateUmpleFile(filename + ".ump");
    }
    catch (Exception e)
    {
      System.err.print(e.getMessage());
    } 
    if (isSuccess)
    {
      System.out.println("Success! Processed "+ filename + ".");
    }
    else
    {
      System.err.print("No file generated, parsing error.");
    }
  }

  /**
    * optionProcess: process the option arguments which does not require UmpleModel
    * Argument: optSet - set of the options and corresponding arguments
    * Return: boolean - If application should terminate immediately after return
    */
  private boolean preModelOptionProcess()
  {
    if (cfg.getVersion())
    {
      System.out.println("Version: " + UmpleModel.VERSION_NUMBER);
    }
    else if (cfg.getHelp())
    {
      printUsage();
    }
    else if (cfg.getImportFile().isPresent())
    {
      generateUmple(cfg.getImportFile().get());
    }
    else
    {
      return false;
    }
    return true;
  }

  private boolean postModelOptionProcess(UmpleModel model) {
    if (cfg.getGenerate().isPresent()) {
      String path = cfg.getPath().orElse("");
      boolean override = cfg.getOverride();
      String lang = cfg.getGenerate().orElse(null);

      GenerateTarget gt = new GenerateTarget(lang, path);
      gt.setOverrideAll(override);
      
      cfg.getSuboptions().stream().forEach(gt::addSuboption); 

      model.addGenerate(Arrays.asList(gt));
      
      // If we have requested it, get rid of previously generated files in path matching this generator
      if(cfg.getRemovePrevious()) {
        String startPath = path;
        if (path.equals("")) {startPath = ".";}
        deletePreviouslyGenerated(startPath, "."+lang.toLowerCase());
        
        // If java we also delete class files
        if(lang.equals("Java")) {
          deletePreviouslyGenerated(startPath, ".class");
        }
      }
    }
    
    return false;
  }
  
  // Recursively delete files ending in suffix; used to clean up before new generation
  private void deletePreviouslyGenerated(String startPath, String suffix) {
    File folder = new File(startPath);
    for (File file : folder.listFiles()) {
      if (file.getName().endsWith(suffix)) {
        file.delete();
      }
      else if(file.isDirectory()) {
        deletePreviouslyGenerated(startPath+File.separator+file.getName(),suffix);
      }
    }
  }
  
  private static OptionParser initializeOptionParser()
  {
    OptionParser optparser = new OptionParser();
    
    String languages = String.join(",", UmpleModel.validLanguages );
    String suboptionsAvail = "(With GvStateDiagram: hideactions, hideguards, showtransitionlabels, showguardlabels, Java, Cpp) ";
    suboptionsAvail += "(With GvClassDiagram or GvClassTraitDiagram or GvEntityRelationshipDiagram: hideattributes, showmethods)";
    suboptionsAvail += " (With all Gv: gvseparator=n.n where n.n is greater than 1.0 to separate nodes more than default, or less than one to make the diagram tighter)";
    suboptionsAvail += " (With all Requirements: reqSortID to sort requirements by their ID, reqSortStat to sort requirements by their Statement)";
    suboptionsAvail += " (With all Requirements: reqHideNotImpl to hide the not implemented requirements. )";

      optparser.acceptsAll(Arrays.asList("version", "v"), "Print out the current Umple version number");
      optparser.acceptsAll(Arrays.asList("performance", "p"), "Indicate time taken to parse and generate code");
      optparser.acceptsAll(Arrays.asList("help"), "Display the help message");

    optparser.acceptsAll(Arrays.asList("g", "generate"), "Specify the output language: " + languages).withRequiredArg().ofType(String.class);
    optparser.acceptsAll(Arrays.asList("u", "umple"), "Include umple code directly as a single string, instead of or addition to in files.").withRequiredArg().ofType(String.class);
    optparser.acceptsAll(Arrays.asList("d","debug"), "Debug. For developers of the compiler. Turns on internal debug statements wrapped in blocks that check model.isDebugMode().");    
    optparser.acceptsAll(Arrays.asList("override"), "If a output language <lang> is specified using option -g, output will only generate language <lang>");
    optparser.acceptsAll(Arrays.asList("removeprevious", "r"), "used with -g; remove previously generated code before generating new. Can help prevent leftover code causing errors. Does not work with generators specified inside a file.");
    optparser.acceptsAll(Arrays.asList("path"), "If a output language is specified using option -g, output source code will be placed to path").withRequiredArg().ofType(String.class);
    optparser.acceptsAll(Arrays.asList("c","compile"), "Indicate to the entry class to compile, or with argument - to compile all outputfiles; compiles Java to .class, lints Php and Python, converts Graphviz to .svg").withRequiredArg().ofType(String.class);
    optparser.acceptsAll(Arrays.asList("f","file"), "Read in a file containing sets of umple-files to process, one set per line. Each is an independent compilation. Intended for testing.").withRequiredArg().ofType(String.class);
    optparser.acceptsAll(Arrays.asList("e","exitonfirstfailure"), "Used with -f. Exit with nonzero on first failure of a compile specified in the file passed to -f. Otherwise exits after completing all compilations with nonzero if any failed.");    
    optparser.acceptsAll(Arrays.asList("q","quiet"), "Be quiet. Only output compilation information in case of failure");
    optparser.acceptsAll(Arrays.asList("w","warningignore"), "Ignore a warning whose number is embedded in the file name if the file name starts with W. Used for testing.");
    optparser.acceptsAll(Arrays.asList("x","useexec"), "Use an external exec call to invoke the Java compiler when using the -c option. May be needed on some platforms or with certain examples.");    
    optparser.acceptsAll(Arrays.asList("import","i"), "Indicate to read in XMI model and generate ump files").withRequiredArg().ofType(String. class);
    optparser.acceptsAll(Arrays.asList("suboption","s"), "Indicate to generate files with suboptions "+suboptionsAvail).withRequiredArg().ofType(String.class);
    
    return optparser;
  }
  
  private static void printUsage()
  {
    System.out.println("For more detailed information go to https://manual.umple.org"+System.lineSeparator()
      +"Usage: java -jar umple.jar [options] <umple_files>"+System.lineSeparator()
      +"Example: java -jar umple.jar airline.ump");
    try
    {
      optparser.printHelpOn(System.out);
    } 
    catch (IOException e)
    {
      e.printStackTrace();
    }
  }

  static OptionSet optParse(String[] args)
  {
    OptionSet optSet = null;

    try
    {
      optSet = optparser.parse(args);
    } 
    catch (joptsimple.OptionException e)
    {
      System.out.println("Option:" + e.getMessage());
      printUsage();
    }

    return optSet;
  }
}

/*
 * Main program for a jar that can inject calls to Umple at runtime
 */
class UmpleRunMain
{

  depend cruise.umple.compiler.*;
  depend cruise.umple.compiler.exceptions.*;
  depend cruise.umple.builder.*;
  depend cruise.umple.util.*;
  depend java.net.*;
  depend java.io.*;
  depend java.net.InetAddress;

  public static void main(String[] args)
  {
    if (args.length < 2)
    {
      System.out.println("Usage: java -jar umplerun.jar <umple_file> <cmd_file>\nExample: java -jar umple.jar airline.ump airline.cmd");
      return;
    }

    String filename = args[0];
    String cmdFilename = args[1];
    UmpleFile umpleFile = new UmpleFile(filename);
    UmpleModel model = new UmpleModel(umpleFile);
    boolean shouldDebug = args.length >= 3 && args[2].equals("--debug");
    boolean shouldCompile = !shouldDebug;

    try
    {
      if (shouldCompile)
      {
        System.out.print("Compiling "+ filename +"... ");
        model.run();
        System.out.println("success.");
      }
      else
      {
        System.out.print("Skipping compilation, entering debug mode");
      }

      System.out.print("Building model... ");
      Builder b = new Builder();
      URL jarfile = b.compile(".",umpleFile.getSimpleFileName() + ".jar",umpleFile.getSimpleFileName(),"1.6");

      if (jarfile == null)
      {
        System.out.println("failed");
        return;
      }
      System.out.println("success.");

      System.out.print("Loading model into memory... ");
      URL urls [] = { jarfile };
      URLClassLoader cl = new URLClassLoader(urls);
      System.out.println("success.");

      Command cmd = new Command(cl);

      System.out.println("Running commands:");
      boolean isFirst = true;
      for (String input : SampleFileWriter.readContent(new File(cmdFilename)).split("\n"))
      {
        if (isFirst)
        {
          cmd.addAttributes(input);
          isFirst = false;
          continue;
        }
        cmd.exec(input);
        for (String message : cmd.popMessages())
        {
          System.out.println("  " + message);
        }
      }

      System.out.println("Done.");
    }
    catch(Exception e)
    {
      System.out.println("failed.");
      System.err.print(e.getMessage());
    }
  }
}

/*
 * Main program for umplesync.jar which is used by umpleonline
 * when it wants to send changes to the diagram and have them applied to
 * the text and vice versa
 *
 * TODO: Code smell - rename?
 */
use AbstractServer.ump; 
use ConnectionToClient.ump;
 
class PlaygroundMain
{
  isA AbstractServer;
  
  depend cruise.umple.sync.*;
  depend cruise.umple.compiler.*;
  depend cruise.umple.compiler.exceptions.*;
  depend cruise.umple.util.*;
  depend java.io.*;
  depend java.util.*;
  depend java.net.*;
  depend com.sun.management.OperatingSystemMXBean;
  depend java.lang.management.*;
  depend java.text.SimpleDateFormat;

  Boolean isServer=false;
  int commandsRun = 0;
  int commandsEverRun = 0;
  int checkpointCommandsRun = 0;
  int checkpoint2CommandsRun = 0;
  int cpDiffCmds = 0;
  long cpDiffTime = 0L;
    
  int logCommandsRun = 0;
  int addClassCommandsRun = 0;
  int editClassCommandsRun = 0;
  int addPositioningCommandsRun = 0;
  int sourceCommandsRun = 0;
  
  int generateJsonCommandsRun = 0;
  int generateJsonMixedCommandsRun = 0;
  int generateGvClassDiagramCommandsRun = 0;
  int generateGvStateDiagramCommandsRun = 0;
  
  static String[] previousCommand = new String[1];
  static String[] lastCommand = new String[1];
  static String[] currentCommand = new String[1];

  static InetAddress previousIP = null;
  static InetAddress lastIP = null;
  static InetAddress currentIP = null;

  long lastCommandStartTime = 0L;  
  long lastCommandEndTime = 0L;
  long lastCommandElapsed = 0L;
  long previousCommandElapsed = 0L;
  long previousCommandEndTime = 0L;

  long checkpointTime = 0L;
  long checkpoint2Time = 0L;
  
  long maxElapsed = 0L;
  long checkpointMaxElapsed = 0L;
  long checkpoint2MaxElapsed = 0L;

  static PlaygroundMain theInstance;

  public PlaygroundMain(int port) 
  {
    super(port);
    previousCommand[0]="";    
    lastCommand[0]="";    
    currentCommand[0]="";
  }
  
  // The main method when started from the command line
  public static void main(String[] args) {
    theInstance = new PlaygroundMain(0);
    theInstance.processCommand(args, null);
  }
    
  // A command arriving when this is a server
  public void handleMessageFromClient
    (String msg, ConnectionToClient client)
  {
     // DEBUG Uncomment the following line to debug
    // System.err.println("Received client command <"+msg+">");
    // Split the message from the client into tokens and process as a command
    List<String> ls = ArgumentTokenizer.tokenize(msg,false);
    lastCommandStartTime = System.currentTimeMillis();
    processCommand(ls.toArray(new String[ls.size()]), client);
    previousCommandElapsed=lastCommandElapsed;
    previousCommandEndTime=lastCommandEndTime;    
    lastCommandEndTime = System.currentTimeMillis();
    lastCommandElapsed = lastCommandEndTime-lastCommandStartTime;
    if (lastCommandElapsed > maxElapsed) {
      maxElapsed = lastCommandElapsed;
    }
    if (lastCommandElapsed > checkpointMaxElapsed) {
      checkpointMaxElapsed = lastCommandElapsed;
    }
    if (lastCommandElapsed > checkpoint2MaxElapsed) {
      checkpoint2MaxElapsed = lastCommandElapsed;
    }
    
    try {
      client.close();
    }
    catch (IOException e) {
    }    
  } 
  
  public void returnCommandResult(String resultToOutput, ConnectionToClient client) {
    if(isServer) {
      // Client must not be null
      try {
        client.sendToClient(resultToOutput);
      }
      catch (IOException e) {
        System.err.print("Unable to send to client "+resultToOutput);
        // TO DO this is serious; should shut down?
      }
    }
    else {
      System.out.print(resultToOutput);
    }
  }

  // Process arguments either from the command line, or through a socket
  // If through a socket, the socket must be closed after returning
  public void processCommand(String[] args, ConnectionToClient client)
  {
    // Shortcut command does not get counted as a real command ... just to determine if up
    if ("-ping".equals(args[0])) {
      if(isServer) {
        returnCommandResult("Server is up\n", client);        
      }
      else {
        returnCommandResult("Not running as a server\n", client);        
      }
      return;
    }

    String answer = "";
    commandsRun++;
    commandsEverRun++;
    
    if(commandsRun%100==0) { // We have hit a checkpoint
      checkpoint2CommandsRun = checkpointCommandsRun;
      checkpoint2Time = checkpointTime;
      checkpointCommandsRun = commandsRun;
      checkpointTime = System.currentTimeMillis();
      checkpoint2MaxElapsed = checkpointMaxElapsed;
      checkpointMaxElapsed = 0; // start counting max again
    }

    if(commandsEverRun%1000==0) {
      //write commandcount.txt with commandsEverRun (to allow for crashes)
      saveCommandsCount();
    }
    
    previousCommand = lastCommand;
    previousIP = lastIP;
    lastCommand = currentCommand;
    lastIP = currentIP;
    currentCommand = args;
    
    if(currentCommand[0].equals("-log")) logCommandsRun++;
    else if(currentCommand[0].equals("-addClass"))  addClassCommandsRun++;
    else if(currentCommand[0].equals("-editClass"))  editClassCommandsRun++;
    else if(currentCommand[0].equals("-addPositioning"))  addPositioningCommandsRun++;
    else if(currentCommand[0].equals("-source"))  sourceCommandsRun++;

    else if(currentCommand[0].equals("-generate")) {
      if (currentCommand[1].equals("Json"))  generateJsonCommandsRun++;
      else if (currentCommand[1].equals("GvClassDiagram"))  generateGvClassDiagramCommandsRun++;
      else if (currentCommand[1].equals("GvStateDiagram"))  generateGvStateDiagramCommandsRun++;
      else if (currentCommand[1].equals("JsonMixed"))  generateJsonMixedCommandsRun++;
    }
    
    if(client != null) {
      currentIP = client.getInetAddress();
    }

    if (args.length == 0 || ("-help".equals(args[0])) )
    {
      returnCommandResult("Syntax:\n", client);
      returnCommandResult("-version  : give umple version running\n", client);
      returnCommandResult("-help  : give command line syntax\n", client);
      returnCommandResult("-classList <filename>\n", client);
      returnCommandResult("-interfaceList <filename>\n", client);
      returnCommandResult("-source <filename>  : generate code using an embedded generate directive\n", client);
      returnCommandResult("-server <port>  : start this as a server to take commends\n", client);
      returnCommandResult("-quit  : quit if running as a server\n", client);

      
      returnCommandResult("-generate "+
        "<Java|Cpp|Ruby|Python|Ecore|Papyrus|TextUml|GvStateDiagram|"+
        "GvClassDiagram|GvClassTraitDiagram|GvEntityRelationshipDiagram|GvFeatureDiagram|"+
        "Alloy|NuSMV|NuSMVOptimizer|Violet|Umlet> <filename>\n", client); // Compile filename and generate output
      returnCommandResult("<action> <deltaCode> <filename>\n", client);  
      return;
    }

    SimpleDateFormat sdf = new SimpleDateFormat("EEE yyyy MMM dd HH:mm:ss z");    
    if ("-version".equals(args[0])) {
      returnCommandResult("Version: " + UmpleModel.VERSION_NUMBER
        + " Compiled: "+sdf.format(CompileDate.getClassBuildTime())
        +"\n", client);
      return;
    }    

    if ("-log".equals(args[0])) {
      if(isServer) {
          long uptime = ManagementFactory.getRuntimeMXBean().getUptime();
          Date startDate = new Date(System.currentTimeMillis()-uptime);
          
          String hn="unknown";
          try {
            hn=java.net.InetAddress.getLocalHost().getCanonicalHostName();
          }
          catch (Exception e) {}
         
          returnCommandResult("UmpleOnline Log         recorded "
            +sdf.format(System.currentTimeMillis()) 
            +"  at "+hn+"\n\n", client);
          
          returnCommandResult("JVM up: "
            +uptime/1000+"s  "+String.format("%.3f",uptime/60000/1440.0)+"d   restart "+
            sdf.format(startDate)+"\n\n", client);

          returnCommandResult("Version: " + UmpleModel.VERSION_NUMBER
            + " Jar "+sdf.format(CompileDate.getClassBuildTime())
            +"\n\n", client);
          
          cpDiffCmds = commandsRun - checkpoint2CommandsRun;
          cpDiffTime = System.currentTimeMillis()-checkpoint2Time;
          
          returnCommandResult("Number of commands run since start: "
            +commandsRun+"  (pace "+String.format("%.1f", 3600000.0*commandsRun/uptime)+"/h"
               + ((checkpoint2Time > 0) ? 
                  " recent "+String.format("%.1f", 3600000.0*cpDiffCmds/cpDiffTime)+"/h"
                  : "")
               +"\n", client);          
          returnCommandResult(
              "  log: " +logCommandsRun
              +"  addClass: " +addClassCommandsRun
              +"  editClass: " +editClassCommandsRun
              +"  addPositioning: " +addPositioningCommandsRun
              +"  source: " +sourceCommandsRun
              +"\n"
              +"   gen: Json: " +generateJsonCommandsRun
              +"  GvClass: " +generateGvClassDiagramCommandsRun
              +"  GvState: " +generateGvStateDiagramCommandsRun
              +"  JsonMixed: " +generateJsonMixedCommandsRun
              +"\n\n", client);          

          returnCommandResult("Number of commands run since July 2019: "
            +commandsEverRun+"\n\n", client);

          returnCommandResult("Number of clients queued: "
            +getClientConnections().length+"\n\n", client);

          OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);         
          returnCommandResult("CPU load % of this JVM: "
            +(String.format("%.3f",100.0*osBean.getProcessCpuLoad()))
            +"\n\n", client);   
          returnCommandResult("CPU load % overall: "
            +(String.format("%.3f",100.0*osBean.getSystemCpuLoad()))
            +"\n\n", client);  

          returnCommandResult("Max elapsed ms of any command: "+maxElapsed
            + "  recent: "+checkpoint2MaxElapsed
            +"\n\n", client);

          returnCommandResult("Port: "+getPort()+"  Process:"
              +ManagementFactory.getRuntimeMXBean().getName().split("@")[0]
              +"\n\n", client);

          if(lastIP != null) {
            returnCommandResult("Last command      from "
              +lastIP+" ("+lastIP.getCanonicalHostName()+")\n"
              +" Elapsed "+lastCommandElapsed+"ms  Ended "
              +(System.currentTimeMillis()-lastCommandEndTime)/1000+"s ago :\n"
              +concatForLog(lastCommand)+"\n", client);
          }

          if(previousIP != null) {            
            returnCommandResult("Previous command  from "
              +previousIP+" ("+previousIP.getCanonicalHostName()+")\n"
              +" Elapsed "+previousCommandElapsed+"ms  Ended "
              +(System.currentTimeMillis()-previousCommandEndTime)/1000+"s ago :\n"
              +concatForLog(previousCommand), client);
          }

      }
      else {
        returnCommandResult("Not running as a server\n", client);        
      }
      return;
    }  

    // Start a server to process a series of commands that can be controlled from Php
    if ("-server".equals(args[0])) {
      isServer = true;

      // Start server on port 5556 if in a test environment, otherwise use port 5555
      // Test environment means that the directory has 'test' in it
      int port = 5555;
      File specialPort = new File(System.getProperty("user.dir")+File.separator+"specialPort.txt");
      if(specialPort.exists()) {
        try {
          FileReader reader = new FileReader(specialPort);
          BufferedReader in = new BufferedReader(reader);
          port = Integer.parseInt(in.readLine());
          in.close();
        }
        catch (IOException e) {
          System.err.println("Could not read the contents of specialPort.txt. Should be a port number. Using 5555.");
        } 
      }
      else if(System.getProperty("user.dir").contains("test")) {
        port = 5556;
      }
      

      if(args.length >=2) {
        try {
         port = Integer.parseInt(args[1]);
        }
        catch (NumberFormatException e)
        {}
      }
      setPort(port);
      try 
      {
        this.listen(); //Start listening for connections
      } 
      catch (Exception ex) 
      {
        System.out.println("ERROR - Could not listen for clients!");
      }
      finally {
        // write out the umple version
      File versionRunning = new File(System.getProperty("user.dir")+File.separator+"versionRunning.txt");
        try {
          FileWriter writer = new FileWriter(versionRunning);
          BufferedWriter out = new BufferedWriter(writer);
          out.write(UmpleModel.VERSION_NUMBER+"\n");
          out.close();
        }
        catch (IOException e) {
          // Do nothing if we can't write out the version
        } 
      }
      
      return;
    }
    
    if ("-quit".equals(args[0])) {
      if(isServer) {
        try {
          saveCommandsCount();
          this.close();
        }
        catch (IOException e) {
        }
      }
      System.exit(0);
    }

    // Anything other than -generate, and must have 3+ args
    if (args.length >= 3 && !"-generate".equals(args[0]))
    {
      String actionType = args[0];
      String deltaCode = args[1];
      String filename = args[2];
      String umpleCode = SampleFileWriter.readContent(new File(filename));

      SynchronizationAction action = action(actionType,deltaCode,umpleCode,filename);
      if (action != null)
      {
        action.go();
        returnCommandResult(action.getUmpleCode(), client);
        return;
      }
    }

    UmpleFile umpleFile = null;
    UmpleModel model = null;
    boolean compilationRequired = false;
    boolean executionRequired = false;
    String errorFileName = null;

    // Valid values include Java, Cpp, PhP, Ruby, Json, Yuml, Xmi, Ecore, Papyrus, TextUml,
    // GvStateDiagram, GvStructureDiagram, GvClassDiagram,GvClassTraitDiagram, GvEntityRelationshipDiagram, Alloy, NuSMV, NuSMVOptimizer, GvFeatureDiagram
    if ("-generate".equals(args[0]) && args.length >= 2)
    {
      String filename = args[2];
      GenerateTarget target = new GenerateTarget(args[1], ""); // output path goes here
      // Add any suboptions specified as -s blah -s blah
      for (int argno = 3; argno <= args.length-2; argno += 2)
      {
        if (args[argno].equals("-s"))
        {
          target.addSuboption(args[argno+1]);
        }
      }

      // Check for compilation flag
      for (int argno = 3; argno < args.length; argno++) 
      {
        if (args[argno].equals("-c"))
        {
          compilationRequired = true;
        }
        else if (args[argno].equals("-cx")) 
        {
          compilationRequired = true;
          executionRequired = true;
        }
        else if(args[argno].equals("2>") && argno < args.length-1) 
        {
          errorFileName = args[argno+1];
        }
      }
      
      umpleFile = new UmpleFile(filename);
      
      // Add any special direct code specified in a -u option
      for (int argno = 3; argno <= args.length-2; argno += 2)
      {
        if (args[argno].equals("-u"))
        {
          umpleFile.addLinkedFiles("__UMPLE"+
            Base64.getEncoder().encodeToString(args[argno+1].getBytes()));
        }
      }
      model = new UmpleModel(umpleFile);
      
      target.setOverrideAll(true);
      model.addGenerate(target);
    }
    else
    {
      // All other commands have filename at second argument
      if(args.length == 1) {
        System.err.println("Filename argument required after command. Quitting");
        System.exit(1);
      }
      String filename = args[1];
      umpleFile = new UmpleFile(filename);
      model = new UmpleModel(umpleFile);
    }

    try
    {
      model.run();
    }
    catch(UmpleCompilerException e)
    {
      String errorToReport = model.getLastResult().toJSON();
      if(client == null) {
        System.err.print(errorToReport);
      }
      else {
        try {
          client.sendToClient("ERROR!!"+errorToReport+"!!ERROR");
        }
          catch (IOException e2) {
        }
      }
    }

    // Compile code if required (-c after -generate option)
    boolean successPreviousStep = model.getLastResult().getWasSuccess();
    if(successPreviousStep && compilationRequired) 
    {
      for (GenerateTarget gt : model.getGenerates()) 
      {
        String generatorCodeToCompile = gt.getLanguage();
        if (generatorCodeToCompile.equals("Java") || generatorCodeToCompile.equals("Php") || generatorCodeToCompile.equals("Python")) 
        {
          // TODO: Remove default options in future when syncing umplesync.jar with umple.jar
          successPreviousStep = CodeCompiler.compile(model, generatorCodeToCompile,false, false, "-", errorFileName);
        }
      }
    }

    // Delete main file if any existing
    String javaPath = model.getUmpleFile().getPath() + File.separator + "JavaMainClasses.txt";
    String PythonPath = model.getUmpleFile().getPath() + File.separator + "PythonMainClasses.txt";
    deleteFileIfExists(javaPath);
    deleteFileIfExists(PythonPath);

    // If execution required, output the main classes to a file
    if(successPreviousStep && executionRequired) 
    {
      outputMainClassesToFile(model);
    }

    if ("-classList".equals(args[0]))
    {
      for (UmpleClass aClass : model.getUmpleClasses())
      {
        if (answer.length() > 0)
        {
          answer += ",";
        }
        answer += aClass.getName();
      }
    }
    if ("-interfaceList".equals(args[0]))
    {
      for (UmpleInterface aInterface : model.getUmpleInterfaces()) {
        if (answer.length() > 0)
        {
          answer += ",";
        }
        answer += aInterface.getName();
      }
    }
    else if ("-source".equals(args[0]))
    {
      String langCommentDelimiter = "//"; // Default for Java, PHP, C++
      for (GenerateTarget gt : model.getGenerates()) 
      {
        String lang = gt.getLanguage();
        if (lang.equals("Ruby") || lang.equals("Python")) 
        {
          langCommentDelimiter = "# ";
          break;
        }
      }
      for (Map.Entry<String, String> generatedCode : model.getGeneratedCode().entrySet()) {
        if (answer.length() > 0)
        {
          answer += "\n\n\n\n";
        }
        answer += langCommentDelimiter+"%% NEW FILE " + generatedCode.getKey() + " BEGINS HERE %%\n\n";
        answer += generatedCode.getValue();
      }
    }
    else if ("-generate".equals(args[0]))
    {
      answer = model.getCode();
    }

    returnCommandResult(answer, client);
  }

  /**
   * Output the names of the main classes if available
   */
  private void outputMainClassesToFile(UmpleModel model) 
  {
    for (String key : model.getHashMap().keySet()) 
    {
      if(key.compareTo("Java") == 0 || key.compareTo("Python") == 0) 
      {
        // Get all main file names and make a single string
        StringBuilder builder = new StringBuilder();
        for (UmpleClass mainClass: CodeCompiler.getMainClasses(model)) 
        {
          builder = builder.append(mainClass.getName() + " ");
        }
        String mainFileNames = builder.toString().trim();
        String filePath = model.getUmpleFile().getPath() + File.separator + key + "MainClasses.txt";
        if(!mainFileNames.isEmpty())
        {
          // Create or override JavaMainClasses.txt
          try
          {
            File newFile = new File(filePath);
            newFile.createNewFile();   
          }
          catch (IOException ex)  
          {
            System.out.println(ex);
          }

          // Write to the file
          try (PrintWriter out = new PrintWriter(filePath)) 
          {
            out.println(mainFileNames);
          }  
          catch (FileNotFoundException ex) 
          {
            System.out.println(ex);
          }
        }
      }
    }
  }

  private void deleteFileIfExists(String path) 
  {
    try 
    {
      File existingFile = new File(path);
      if(existingFile.exists())
      {
        existingFile.delete();
      }
    }
    catch(Exception ex) 
    {
      System.out.println(ex);
    }
  }
  
  private boolean saveCommandsCount(){
    boolean saved = false;

    try {
        FileWriter writer = new FileWriter("commandcount.txt", false);
        writer.write(Integer.toString(commandsEverRun));
        writer.close();
        saved = true;
    } catch (IOException e) {
        System.err.println(e.getMessage());
    }

    return saved;
  }

  private boolean loadCommandsCount(){
    boolean loaded = false;
    try {
      BufferedReader myReader = new BufferedReader(new FileReader("commandcount.txt"));

      int number = 0;
      String token;
      if ((token = myReader.readLine()) != null) {
        try {
            number = Integer.parseInt(token);
        } catch (NumberFormatException ex) {
            System.err.println(token + " is not a number");
        } 
      } 
      myReader.close();
      commandsEverRun = number;
      loaded = true;

    } catch(FileNotFoundException e){
      System.err.println(e.getMessage());

    } catch(IOException e){
      System.err.println(e.getMessage());
    }
    return loaded;
  }

  protected void serverStarted() {
    // Uncomment the following to debug
    // System.err.println("Umple server started on port "+getPort());
    // System.err.println("Working directory "+System.getProperty("user.dir"));
    loadCommandsCount();
  }
  
  protected void serverStopped() {
    // Uncomment the following to debug
    // System.err.println("Umple server stopped accepting connections "+getPort());
  }
  
  protected void serverClosed() {
    // Uncomment the following to debug  
    //  System.err.println("Umple server closed on port "+getPort());
  }
  
  String concatForLog(String[] theCommand) {
    String result = "";
    for (String aString : theCommand) {
      result = result+"  ["+aString+"]\n"; // not used often so OK to be inefficient
    }
    return result;
  }
    
  private static SynchronizationAction action(String type, String deltaCode, String umpleCode, String filename)
  {
    if ("-addClass".equals(type))
    {
      return new NewAction(deltaCode,umpleCode,filename);
    }
    else if ("-addInterface".equals(type))
    {
      return new NewAction(deltaCode,umpleCode,filename);
    }
    else if ("-removeClass".equals(type))
    {
      return new DeleteAction(deltaCode,umpleCode,filename);
    }
    else if ("-editClass".equals(type))
    {
      return new EditAction(deltaCode,umpleCode,filename);
    }
    else if ("-removeInterface".equals(type))
    {
      return new DeleteAction(deltaCode,umpleCode,filename);
    }
    else if ("-editInterface".equals(type))
    {
      return new EditAction(deltaCode,umpleCode,filename);
    }
    else if ("-addAssociation".equals(type))
    {
      return new NewAssociationAction(deltaCode,umpleCode,filename);
    }
    else if ("-editAssociation".equals(type))
    {
      return new EditAssociationAction(deltaCode,umpleCode,filename);
    }
    else if ("-removeAssociation".equals(type))
    {
      return new DeleteAssociationAction(deltaCode,umpleCode,filename);
    }
    else if ("-addTransition".equals(type))
    {
    	return new NewTransitionAction(deltaCode, umpleCode, filename);
    }
    else if ("-removeTransition".equals(type))
    {
    	return new DeleteTransitionAction(deltaCode, umpleCode, filename);
    }
    else if ("-addGeneralization".equals(type))
    {
      return new NewGeneralizationAction(deltaCode,umpleCode,filename);
    }
    else if ("-removeGeneralization".equals(type))
    {
      return new DeleteGeneralizationAction(deltaCode,umpleCode,filename);
    }
    else if ("-addPositioning".equals(type))
    {
      return new UpdatePositioningAction(deltaCode,umpleCode,filename);
    }
    else
    {
      return null;
    }
  }
}

use Compiler.ump;
use ArgumentTokenizer.ump;

class CompileDate {
  depend java.net.URISyntaxException;
  depend java.util.Date;
  depend java.util.jar.JarFile;
  depend java.util.zip.ZipFile;
  depend java.io.IOException;
  depend java.io.File;
  depend java.util.zip.ZipEntry;
  depend java.net.URL;
  
  // From https://stackoverflow.com/questions/3336392/java-print-time-of-last-compilation

  public static Date getClassBuildTime() {
    Date d = null;
    Class<?> currentClass = new Object() {}.getClass().getEnclosingClass();
    URL resource = currentClass.getResource(currentClass.getSimpleName() + ".class");
    if (resource != null) {
        if (resource.getProtocol().equals("file")) {
            try {
                d = new Date(new File(resource.toURI()).lastModified());
            } catch (URISyntaxException ignored) { }
        } else if (resource.getProtocol().equals("jar")) {
            String path = resource.getPath();
            d = new Date( new File(path.substring(5, path.indexOf("!"))).lastModified() );    
        } else if (resource.getProtocol().equals("zip")) {
            String path = resource.getPath();
            File jarFileOnDisk = new File(path.substring(0, path.indexOf("!")));
            //long jfodLastModifiedLong = jarFileOnDisk.lastModified ();
            //Date jfodLasModifiedDate = new Date(jfodLastModifiedLong);
            try(JarFile jf = new JarFile (jarFileOnDisk)) {
                ZipEntry ze = jf.getEntry (path.substring(path.indexOf("!") + 2));//Skip the ! and the /
                long zeTimeLong = ze.getTime ();
                Date zeTimeDate = new Date(zeTimeLong);
                d = zeTimeDate;
            } catch (IOException|RuntimeException ignored) { }
        }
    }
    return d;
}

}

